{"version":3,"sources":["webpack:///main.628e1f0bb7939d35db16.js","webpack:///./src/index.js","webpack:///./~/@uirouter/angularjs/release/ui-router-angularjs.js","webpack:///./~/@uirouter/core/_bundles/ui-router-core.js","webpack:///./~/ngstorage/ngStorage.js","webpack:///./src/index.config.js","webpack:///./src/index.run.js","webpack:///./src/components/navbar/index.js","webpack:///./src/components/navbar/navbar.controller.js","webpack:///./src/components/navbar/navbar.directive.js","webpack:///./src/components/navbar/navbar.html","webpack:///./src/components/landing/index.js","webpack:///./src/components/landing/landing.routes.js","webpack:///./src/components/landing/landing.html","webpack:///./src/components/landing/home/index.js","webpack:///./src/components/landing/home/home.directive.js","webpack:///./src/components/landing/home/home.html","webpack:///./src/components/landing/features/index.js","webpack:///./src/components/landing/features/features.directive.js","webpack:///./src/components/landing/features/features.html","webpack:///./src/components/landing/features/feature/index.js","webpack:///./src/components/landing/features/feature/feature.directive.js","webpack:///./src/components/landing/features/feature/feature.html","webpack:///./src/components/landing/pricing/index.js","webpack:///./src/components/landing/pricing/pricing.directive.js","webpack:///./src/components/landing/pricing/pricing.html","webpack:///./src/components/landing/pricing/price/index.js","webpack:///./src/components/landing/pricing/price/price.directive.js","webpack:///./src/components/landing/pricing/price/price.html","webpack:///./src/components/landing/about/index.js","webpack:///./src/components/landing/about/about.directive.js","webpack:///./src/components/landing/about/about.html","webpack:///./src/components/landing/about/card/index.js","webpack:///./src/components/landing/about/card/card.directive.js","webpack:///./src/components/landing/about/card/card.html","webpack:///./src/components/login/index.js","webpack:///./src/components/login/login.routes.js","webpack:///./src/components/login/login.html","webpack:///./src/components/login/login.controller.js","webpack:///./src/services/authentication.service.js","webpack:///./src/components/monitor/index.js","webpack:///./src/components/monitor/monitor.routes.js","webpack:///./src/components/monitor/monitor.html","webpack:///./src/components/monitor/monitor.controller.js","webpack:///./src/components/affiliate/index.js","webpack:///./src/components/affiliate/affiliate.routes.js","webpack:///./src/components/affiliate/affiliate.html","webpack:///./src/components/affiliate/affiliate.controller.js","webpack:///./src/services/userdata.service.js","webpack:///./src/components/deals/index.js","webpack:///./src/components/deals/deals.routes.js","webpack:///./src/components/deals/deals.html","webpack:///./src/components/deals/deals.controller.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_angular","_angular2","_angularjs","_angularjs2","_ngstorage","_ngstorage2","_index","_index2","_index3","_index4","_navbar","_navbar2","_landing","_landing2","_login","_login2","_monitor","_monitor2","_affiliate","_affiliate2","_deals","_deals2","name","config","run","global","factory","this","ng_from_import","_uirouter_core","getNg1ViewConfigFactory","templateFactory","path","view","services","$injector","get","Ng1ViewConfig","ng1ViewsBuilder","state","parent","tplKeys","ctrlKeys","compKeys","nonCompKeys","concat","allViewKeys","isDefined","views","hasAnyKey","Error","filter","key","join","viewsObject","$default","pick","forEach","isString","component","extend","resolveAs","$type","$context","$name","normalized","ViewService","normalizeUIViewTarget","$uiViewName","uiViewName","$uiViewContextAnchor","uiViewContextAnchor","getComponentBindings","cmpDefs","length","map","getBindings","reduce","unnestR","$uiRouter","$locationProvider","$get","$location","$browser","$sniffer","$rootScope","$http","$templateCache","ng1LocationService","_runtimeServices","router","UIRouter","stateProvider","StateProvider","stateRegistry","stateService","decorator","getStateHookBuilder","viewService","_pluginapi","_viewConfigFactory","locationService","locationConfig","Ng1LocationServices","monkeyPatchPathParameterType","$inject","runBlock","$q","x","$$state","resolvables","deps","resolvable","annotate","resolveFn","strictDi","watchDigests","$watch","trace","approximateDigests","parseStateRef","ref","parsed","paramsOnly","match","replace","paramExpr","stateContext","el","$uiView","inheritedData","parse","tail","undefined","processedDef","$state","$element","def","uiState","current","uiStateOpts","defaultOpts","href","uiStateParams","getTypeInfo","isSvg","Object","prototype","toString","call","prop","isForm","nodeName","attr","isAnchor","toUpperCase","clickable","clickHook","$timeout","type","getDef","e","button","which","target","ctrlKey","metaKey","shiftKey","transition","go","preventDefault","ignorePreventDefaultCount","cancel","relative","$current","inherit","source","bindEvents","element","scope","hookFn","events","isArray","on","_i","events_1","event_1","$on","off","events_2","event_2","$IsStateFilter","isFilter","params","options","is","$stateful","$IncludedByStateFilter","includesFilter","includes","$ViewDirectiveFill","$compile","$controller","$transitions","$view","getControllerAs","getResolveAs","restrict","priority","compile","tElement","initial","html","empty","data","contents","cfg","$cfg","viewDecl","getTemplate","noop","resolveCtx","ResolveContext","traceUIViewFill","link","controller","controllerAs","locals","getLocals","controllerInstance","$scope","children","registerControllerCallbacks","cmp_1","kebobName","kebobString","tagRegexp_1","RegExp","getComponentController","directiveEl","slice","tagName","exec","ng","deregisterWatch_1","ctrlInstance","isFunction","$onInit","hasComponentImpl","viewState","self","hookOptions","bind","uiOnParamsChanged","resolveContext","viewCreationTrans_1","getResolvable","paramsUpdated","$transition$","exiting","indexOf","toParams","fromParams","toSchema","treeChanges","to","node","paramSchema","fromSchema","from","changedToParams","param","idx","equals","id","changedKeys_1","newValues","val$$1","onSuccess","uiCanExit","id_1","_uiCanExitId","cacheProp_1","prevTruthyAnswer_1","trans","redirectedFrom","wrappedHook","promise","ids","when","then","criteria","onBefore","$ViewScrollProvider","useAnchorScroll","$anchorScroll","scrollIntoView","ng_from_global","angular","keys","acc","_this","$id","loaded","uiView","context","makeComponentTemplate","bindings","template","load","paramValues","promises","fromConfig","getController","all","results","traceViewServiceEvent","provider","controllerProvider","isInjectable","providerFn","Resolvable","TemplateFactory","_useHttp","version","minor","$templateRequest","has","useHttpService","value","defaultTemplate","asTemplate","result","str","asComponent","fromString","templateUrl","fromUrl","templateProvider","fromProvider","componentProvider","fromComponentProvider","url","cache","headers","Accept","response","prefix","kebob","camelCase","kebobed","attributeTpl","input","attrName","resolveName","res","fn","args","arrayIdxStr","attrs","scopeBindings","isObject","bindToController","bindingsObj","tuple","createProxyFunctions","val","func","definition","register","onInvalid","callback","hookName","parentFn","decoratedNg1Hook","pathname","$state$","invoke","hook","_urlListeners","_lp","dispose","onChange","push","removeFrom","html5Mode","enabled","history","newUrl","evt","_loc","_browser","pathType","urlMatcherFactory","encode","m","~","/","decode","~~","~2F","UrlRouterProvider","_router","_urlRouter","urlRouter","update","interceptDeferred","listen","rule","ruleFn","BaseUrlRule","identity","otherwise","what","handler","injectableHandler","$match","$stateParams","globals","deferIntercept","defer","mod_init","mod_util","mod_rtr","mod_state","mod_main","getProviderFor","serviceName","$urp","service","getUrlRouterProvider","uiRouter","urlRouterProvider","getStateProvider","$urlMatcherFactory","$urlRouter","uiSref","ctx","tokens","getTokens","tuples","waitPolicy","getPolicy","async","applyPairs","require","uiSrefActive","unlinkInfoFn","active","$$addStateInfo","$set","rawDef","uiSrefOpts","$eval","onStatesChanged","transitionService","inputAttrs","watchDeregFns","field","$observe","expr","newval","$interpolate","$attrs","updateAfterTransition","addState","stateName","stateParams","activeClass","stateInfo","states","splitClasses","split","getClasses","stateList","allClasses","activeEqClass","uniqR","fuzzyClasses","exactlyMatchesAny","exactClasses","addClasses","removeClasses","cls","inArray","$evalAsync","className","addClass","removeClass","uiSrefActiveEq","stateOrName","newState","newParams","deregister","onStart","directive","$animate","$uiViewScroll","getRenderer","enter","cb","leave","configsEqual","config1","config2","rootData","_rootViewContext","count","terminal","transclude","tAttrs","$transclude","configUpdatedCallback","viewConfig","traceUIViewConfigUpdated","activeUIView","updateView","cleanupLastView","previousEl","traceUIViewEvent","remove","currentScope","$destroy","currentEl","_viewData_1","renderer","$$animLeave","resolve","newScope","$new","animEnter","animLeave","$uiViewData","$uiViewAnim","$animEnter","$animLeave","$emit","cloned","clone","autoScrollExp","onloadExp","unregister","inherited","fqn","configUpdated","creationContext","fromParentTagConfig","fromParentTag","registerUIView","index","core","defineProperty","curry","curried","func_args_length","apply","arguments","initial_args","compose","start","i","pipe","funcs","reverse","and","fn1","fn2","or","fnName","pattern","struct","head","not","fnNames","latebind","bindFunction","makeLateRebindFn","_inArray","array","_removeFrom","splice","_pushTo","arr","defaults","opts","defaultsList","_defaultsList","defaultVals","ancestors","first","second","n","propNames","objCopy","prop_1","omit","pluck","collection","propName","accept","item","find","pushR","assertFn","predicateOrMap","errMsg","arrayTuples","maxArrayLen","min","Math","memo","keyValTuple","_copy","src","dest","_forEach","_extend","toObj","j","_equals","o1","o2","t1","t2","tup","_arraysEq","isDate","getTime","isRegExp","predicates","any","b","a1","a2","t","uiViewString","uiview","normalizedCat","isNumber","Category","matchState","criterion","matchGlobs","_state","globStrings","toMatch","glob","Glob","matches","matchFn","makeEvent","registry","eventType","hookRegistrationFn","matchObject","registeredHook","RegisteredHook","hooks","_deregistered","_registeredHooks","tupleSort","reverseDepthSort","l","r","factor","depthDelta","ArrayType","mode","arrayWrap","arrayUnwrap","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","left","right","paramTypeFn","wrapperFn","dynamic","$arrayMode","unwrapShorthand","getStaticDefaultValue","isShorthand","$$fn","getType","urlType","location","paramTypes","DefType","CONFIG","PATH","SEARCH","ParamType","getSquashPolicy","isOptional","defaultPolicy","squash","getReplace","arrayMode","configuredKeys","maxLength","max","substr","padString","$1","toLowerCase","functionToString","fnStr","fnToString","namedFunctionMatch","toStr","_fn","stringify","o","format","seen","stringifyPattern","JSON","splitOnDelim","delim","re","joinNeighborsR","initDefaultTypes","makeDefaultType","valToString","defaultTypeBase","String","a","ParamTypes","string","query","hash","int","parseInt","isNullOrUndefined","bool","Boolean","date","getFullYear","getMonth","getDate","capture","Date","isNaN","valueOf","json","toJson","fromJson","nameBuilder","selfBuilder","dataBuilder","pathBuilder","includesBuilder","resolvablesBuilder","objects2Tuples","resolveObj","resolvePolicies","token","policy","isResolveLiteral","isLikeNg2Provider","provide","useValue","useFactory","useExisting","useClass","isTupleFromObj","p","literal2Resolvable","dependencies","tuple2Resolvable","item2Resolvable","decl","items","resolvePolicy","quoteRegExp","surroundPattern","appendBasePath","isHtml5","absolute","baseHref","getHandlerFn","TargetState","isDef","addCoreResolvables","addResolvable","Transition","entering","makeEnterExitRetainHook","lazyLoadState","updateStateRegistry","Array","lazyLoadFn","lazyLoad","success","error","err","reject","ignoredHook","ignoredReason","_ignoredReason","traceTransitionIgnored","pending","abort","Rejection","ignored","toPromise","invalidTransitionHook","valid","parseUrl$1","orEmptyString","_a","splitHash","beforehash","_b","splitQuery","search","locationPluginFactory","serviceClass","configurationClass","configuration","servicesPlugin","propEq","ctor","constructor","eq","other","v","text","regexpString","seg","regexp","test","StateObject","create","stateDecl","isStateClass","__stateObjectCache","nameGlob","root","parameters","matchingKeys","values","hasOwnProperty","parameter","isState","tis","isUndefined","isNull","isPromise","notImplemented","fnname","w","window","copy","assign","extra","pushTo","deregAll","functions","mergeR","mapObj","allTrueR","elem","anyTrueR","flattenR","unnest","flatten","assertPredicate","assertMap","pairs","silenceUncaughtInPromise","silentRejection","Queue","_items","_limit","enqueue","shift","dequeue","size","clear","peekTail","peekHead","RejectType","message","detail","detailString","d","_transitionRejection","isRejectionPromise","superseded","rejection","SUPERSEDED","redirected","invalid","INVALID","IGNORED","aborted","ABORTED","errored","ERROR","normalize","viewConfigString","_tid","_rid","transLbl","Trace","_enabled","_set","categories","k","category","enable","disable","traceTransitionStart","TRANSITION","console","log","traceHookInvocation","step","HOOK","event","traceHookResult","hookResult","transitionOptions","traceResolvePath","RESOLVE","traceResolvableResolved","traceError","reason","traceSuccess","finalState","viewData","UIVIEW","traceViewSync","VIEWCONFIG","mapping","uiViewData","ui-view fqn","state: view name","sort","localeCompare","table","traceViewServiceUIViewEvent","TransitionHookPhase","TransitionHookScope","_identifier","_definition","_params","_options","identifier","exists","base","defaultOptions","traceData","TransitionHook","isSuperseded","hookPhase","RUN","isActive","logError","defaultErrorHandler","invokeHook","notCurrent","getNotCurrentRejection","invokeCallback","normalizeErr","handleError","getErrorHandler","handleResult","getResultHandler","synchronous","handleHookResult","isTargetState","_disposed","_aborted","chain","waitFor","createHookChainR","prev","nextHook","invokeHooks","doneCallback","remainingHooks","runAllHooks","HANDLE_RESULT","LOG_REJECTED_RESULT","LOG_ERROR","REJECT_ERROR","THROW_ERROR","tranSvc","matchCriteria","_matchingNodes","nodes","matching","_getDefaultMatchCriteria","_getPathTypes","_getMatchingNodes","paths","mn","pathtype","isStateHook","STATE","allMatched","every","HookBuilder","buildHooksForPhase","phase","_getEvents","buildHooks","hookType","matchingHooks","getMatchingHooks","baseHookOptions","makeTransitionHooks","matchingNodes","criteriaMatchPath","transitionHook","reverseSort","isCreate","CREATE","registries","reg","getHooks","$subPattern","sub","$normalize","$asArray","isSearch","hasOwn","Param","getArrayMode","arrayDefaults","arrayParamNomenclature","raw","defaultSquashPolicy","inherit$$1","isDefaultValue","getDefaultValue","_defaultValueCache","defaultValue","replaceSpecialValues","validates","encoded","values$$1","params_1","changed","values1","values2","PathNode","stateOrNode","applyRawParams","getParamVal","paramDef","pDef","paramsFn","diff","PathUtils","makeTargetState","buildPath","targetState","buildToPath","fromPath","toPath","inheritParams","applyViewConfigs","viewDecls","subPath","viewConfigs","createViewConfig","toKeys","nodeParamVals","makeInheritedParamsNode","toNode","toParamVals","incomingParamVals","fromParamVals","noInherit","ownParamVals","reloadState","applyToParams","retainedNode","keep","nodesMatch","node1","node2","nonDynamicParams","retained","retainedWithToParams","pathA","pathB","done","nodeA","nodeB","predicate","elementIdx","defaultResolvePolicy","arg1","resolved","literal","thisPolicy","statePolicy","getResolvableDependencies","getDependencies","invokeResolveFn","resolvedDeps","waitForRx","observable$","cached","take","findNode","maybeWaitForRx","applyResolvedValue","resolvedValue","fromData","LAZY","EAGER","WAIT","NOWAIT","RXWAIT","ALL_WHENS","EAGER_WHENS","NATIVE_INJECTOR_TOKEN","_path","subContext","addResolvables","newResolvables","resolvePath","whenOption","matchedWhens","matchesPolicy","acceptedVals","whenOrAsync","nodeResolvables","nowait","wait","getResult","injector","_injector","UIInjectorImpl","availableResolvables","getDependency","fromInjector","getNative","getAsync","stateSelf","_deferred","_hookBuilder","_targetState","_transitionCount","_treeChanges","createTransitionHookRegFns","onCreateHooks","onExit","onRetain","onEnter","onFinish","onError","enteringStates","$from","$to","compare","freeze","pathName","getResolveTokens","topath","targetNode","originalTransition","rf","redirect","redirects","redirectOpts","newOptions","newTransition","originalEnteringNodes","redirectEnteringNodes","nodeIsReloading","matchingEnteringNodes","_changedParams","tc","reload","pathsDiffer","nodeSchemas","toValues","fromValues","schema","toVals","fromVals","changes","same","newTC","pendTC","getHooksFor","transitionSuccess","SUCCESS","transitionError","_error","runTransition","allRunHooks","startTransition","lastStartedTransitionId","transitionHistory","allBeforeHooks","BEFORE","paramDefs","invalidParams","fromStateOrName","toStateOrName","avoidEmptyHash","toValid","diToken","stringifyPatternFn","isRejection","beforeAfterSubstr","char","typeQueue","defaultTypes","makeType","types","definitionFn","_flushTypeQueue","defaultRuleSortFn","StateParams","$inherit","parentParams","parents","inheritList","parseUrl","charAt","substring","getUrlBuilder","$urlMatcherFactoryProvider","stateDec","paramMap","paramConfig","reloadOnSearch","isMatcher","navigable","append","getNavigableBuilder","isRoot","getParamsBuilder","paramFactory","makeConfigParam","urlParams","nonUrlParams","StateBuilder","matcher","parentBuilder","parentName","builders","builder","build","segments","lastSegment","pop","StateMatcher","_states","isRelative","matchGlob","isStr","baseState","splitName","pathLength","relName","StateQueueManager","$registry","listeners","queue","flush","registered","orphans","previousQueueLength","getState","name_1","orphanIdx","existingState","existingFutureState","attachRoute","listener","s","urlRuleFactory","StateRegistry","stateQueue","_registerRoot","rootStateDef","#","abstract","_root","stateDefinition","_deregisterTree","all$$1","getChildren","deregistered","$ur","rules","removeRule","deregisteredStates","found","memoizeTo","prop$$1","splitOnSlash","UrlMatcher","pattern$$1","_cache","_children","_segments","_compiled","strict","caseInsensitive","segment","placeholder","searchPlaceholder","last","patterns","checkParamErrors","nameValidator","matchDetails","makeRegexpType","lastIndex","fromSearch","decodePathArray","reverseString","unquoteDashes","allReversed","allParams","pathParams","searchParams","nPathSegments","urlm","findParam","validParamVal","getDetails","isValid","urlMatchers","pathSegmentsAndParams","queryParams","isInvalid","pathString","encodeDashes","encodeURIComponent","queryString","paramDetails","c","charCodeAt","staticSegments","weights","padArrays","padVal","len","weightsA","weightsB","cmp","pairs$$1","UrlMatcherFactory","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","_getConfig","strictMode","object","UrlRuleFactory","makeRule","_what","fromUrlMatcher","fromState","fromRegExp","urlMatcher","matchPriority","optional","matched","_handler","details","transitionTo","sticky","redirectUrlTo","Number","isUrlRule","prioritySort","typeSort","URLMATCHER","REGEXP","RAW","OTHER","urlMatcherSort","idSort","useMatchPriority","equal","UrlRouter","_sortFn","_rules","_id","_sorted","_otherwiseFn","compareFn","stableSort","ensureSorted","arrOfWrapper","wrapperA","wrapperB","cmpDiff","wrapper","best","checkRule","weight","sync","defaultPrevented","$url","urlService","applyResult","newurl","_stopFn","read","hashPrefix","slash","port","protocol","host","handlerFn","urlParts","_uiViews","_viewConfigs","_viewConfigFactories","_registeredUIViews","_activeViewConfigs","_rootContext","viewType","cfgFactory","cfgs","deactivateViewConfig","activateViewConfig","uiViewDepth","stateDepth","viewConfigDepth","uiViewsByFqn","uiv","depthCompare","depthFn","posNeg","matchingConfigPair","matchingConfigs","configureUIView","uiViews","fqnAndTypeMatches","available","rawViewName","viewAtContext","relativeViewNameSugar","relativeMatch","anchor","vc","vcSegments","uivSegments","negOffset","fqnToFirstSegment","uiViewContext","UIRouterGlobals","successfulTransitions","makeStub","locationServicesFns","locationConfigFns","umfFns","rulesFns","syncFns","UrlService","lateBind","locationServices","umf","parts","locationServiceStub","locationConfigStub","_routerInstance","_disposables","TransitionService","StateService","_plugins","disposable","plugin","pluginInstance","getPlugin","pluginName","registerAddCoreResolvables","onCreate","redirectToHook","redirectTo","registerRedirectToHook","onExitHook","registerOnExitHook","onRetainHook","registerOnRetainHook","onEnterHook","registerOnEnterHook","eagerResolvePath","registerEagerResolvePath","lazyResolveState","registerLazyResolveState","loadEnteringViews","enteringViews","registerLoadEnteringViews","activateViews","exitingViews","registerActivateViews","updateGlobalState","transitionSuccessful","clearCurrentTransition","registerUpdateGlobalState","updateUrl","urlOptions","registerUpdateUrl","lazyLoadHook","retryTransition","orig","registerLazyLoadHook","TransitionEventType","hookOrder","registerIgnoredTransitionHook","registerInvalidTransitionHook","defaultTransOpts","notify","custom","_eventTypes","_criteriaPaths","_deregisterHookFns","_defineCorePaths","_defineCoreEvents","_registerCoreTransitionHooks","hooksArray","Phase","TH","NORMAL_SORT","REVERSE_SORT","SYNCHRONOUS","_defineEvent","_definePathType","transitionHookTypes","cmpByPhase","hookScope","fns","addCoreResolves","eagerResolve","lazyResolve","loadViews","updateGlobals","invalidCallbacks","_defaultErrorHandler","$error$","stack","getters","boundFns","enumerable","configurable","_handleInvalidTargetState","toState","invokeNextCallback","nextCallback","callbackQueue","callbackResult","checkForRedirect","latestThing","latest","defautGoOpts","transOpts","getCurrentPath","latestSuccess","rootPath","getCurrent","currentPath","rejectedTransitionHandler","isLatest","errorHandler","transitionToPromise","include","defaultHrefOpts","lossy","nav","Promise","deferred","STRIP_COMMENTS","ARGUMENT_NAMES","ensureExist","beforeAfterSubstr$1","splitEqual","trimHashVal","keyValsToObjectR","accum","getParams","buildUrl","loc","searchObject","vals","BaseLocationServices","fireAfterUpdate","_listener","_listeners","_get","_location","_history","evt_1","Event","__extends","extendStatics","setPrototypeOf","__proto__","__","HashLocationService","_super","addEventListener","title","removeEventListener","__extends$1","MemoryLocationService","_url","__extends$2","PushStateLocationService","_config","fullUrl","replaceState","pushState","MemoryLocationConfig","_baseHref","_port","_protocol","_host","_hashPrefix","BrowserLocationConfig","_isHtml5","hostname","newprefix","applyDocumentBaseHref","baseTags","document","getElementsByTagName","origin","hashLocationPlugin","pushStateLocationPlugin","memoryLocationPlugin","UIRouterPluginBase","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","isStorageSupported","$window","storageType","supported","round","random","setItem","removeItem","_storageProvider","providerWebStorage","storageKeyPrefix","setKeyPrefix","TypeError","serializer","deserializer","setSerializer","setDeserializer","getItem","set","$log","$document","_last$storage","_debounce","prefixLength","isSupported","webStorage","warn","$storage","$sync","$reset","$apply","temp$storage","$supported","doc","hasFocus","newValue","routing","$urlRouterProvider","$localStorage","currentUser","common","Authorization","next","publicPages","restrictedPage","_navbar3","_navbar4","_classCallCheck","instance","Constructor","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","NavbarController","$","LoginStatus","loggedIn","animate","scrollTop","offset","top","navbar","_home","_home2","_features","_features2","_pricing","_pricing2","_about","_about2","routes","$stateProvider","home","_feature","_feature2","features","feature","image","_price","_price2","pricing","price","cost","months","products","_card","_card2","about","card","role","sentence","motto","followers","following","projects","facebook","linkedin","github","_login3","_login4","_authentication","_authentication2","LoginController","authentication","email","password","ga","_this2","login","Authentication","http","localStorage","api","post","analytics","description","status","fatal","encodedToken","decodedToken","atob","_monitor3","_monitor4","MonitorController","userdata","user","GetUserData","_affiliate3","_affiliate4","_userdata","_userdata2","AffiliateController","userCode","getUserCode","getTokenData","affiliateData","getAffiliateData","paypal","usersReferred","users_referred","profit","checkout","UserData","_deals3","_deals4","DealsController","urlTest","alert"],"mappings":"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,UACAp2B,EAAAiF,MACAjF,EAAAi1B,UACAj1B,EAAAq2B,YACAr2B,EAAAu2B,YACAv2B,EAAAoF,WACApF,EAAAw2B,YACAx2B,EAAAgmB,QACAhmB,EAAAme,SACAne,EAAAy2B,UACAz2B,EAAA02B,WACA12B,EAAA22B,mBACA32B,EAAA42B,aACA52B,EAAAimB,WACAjmB,EAAA62B,SACA72B,EAAAomB,cACApmB,EAAAkc,aACAlc,EAAA0I,OACA1I,EAAA8mB,UACA9mB,EAAA82B,4BACA92B,EAAA+2B,mBACA/2B,EAAAy1B,kBACAz1B,EAAAwC,YACAxC,EAAA6oB,QACA7oB,EAAA8iB,QACA9iB,EAAAojB,UACApjB,EAAAujB,OACAvjB,EAAA4J,QACA5J,EAAA6zB,UACA7zB,EAAAyI,SACAzI,EAAAkkB,OACAlkB,EAAA0jB,MACA1jB,EAAA6jB,KACA7jB,EAAAgU,OACAhU,EAAA4nB,OACA5nB,EAAAyM,MACAzM,EAAAg0B,MACAh0B,EAAAoX,OACApX,EAAA+X,SACA/X,EAAA+jB,UACA/jB,EAAAs1B,eACAt1B,EAAAqD,aACArD,EAAAu1B,UACAv1B,EAAAquB,qBACAruB,EAAA4P,cACA5P,EAAAooB,YACApoB,EAAAgE,YACAhE,EAAA+W,YACA/W,EAAA4L,WACA5L,EAAAwnB,UACAxnB,EAAA0nB,YACA1nB,EAAAo1B,WACAp1B,EAAAqU,eACArU,EAAAw1B,aACAx1B,EAAAg3B,SACAh3B,EAAAmsB,YACAnsB,EAAAssB,YACAtsB,EAAAiP,cACAjP,EAAAysB,mBACAzsB,EAAA2sB,aACA3sB,EAAA+sB,YACA/sB,EAAAosC,qBACApsC,EAAAqtB,eACArtB,EAAAwtB,iBACAxtB,EAAAi5B,SACAj5B,EAAA4H,SACA5H,EAAA6gC,SACA7gC,EAAA+tB,cACA/tB,EAAA6sC,eACA7sC,EAAA2rB,aACA3rB,EAAAgiC,YACAhiC,EAAAwiC,aACAxiC,EAAA2vB,mBACA3vB,EAAA+kC,wBACA/kC,EAAAuU,cACAvU,EAAAymC,yBACAzmC,EAAAoO,kBACApO,EAAAwvB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","file":"main.628e1f0bb7939d35db16.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularjs = __webpack_require__(5);\n\t\n\tvar _angularjs2 = _interopRequireDefault(_angularjs);\n\t\n\tvar _ngstorage = __webpack_require__(7);\n\t\n\tvar _ngstorage2 = _interopRequireDefault(_ngstorage);\n\t\n\tvar _index = __webpack_require__(8);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _index3 = __webpack_require__(9);\n\t\n\tvar _index4 = _interopRequireDefault(_index3);\n\t\n\tvar _navbar = __webpack_require__(10);\n\t\n\tvar _navbar2 = _interopRequireDefault(_navbar);\n\t\n\tvar _landing = __webpack_require__(15);\n\t\n\tvar _landing2 = _interopRequireDefault(_landing);\n\t\n\tvar _login = __webpack_require__(47);\n\t\n\tvar _login2 = _interopRequireDefault(_login);\n\t\n\tvar _monitor = __webpack_require__(53);\n\t\n\tvar _monitor2 = _interopRequireDefault(_monitor);\n\t\n\tvar _affiliate = __webpack_require__(58);\n\t\n\tvar _affiliate2 = _interopRequireDefault(_affiliate);\n\t\n\tvar _deals = __webpack_require__(64);\n\t\n\tvar _deals2 = _interopRequireDefault(_deals);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('arrowfinds', [_angularjs2.default, _ngstorage2.default.name, _navbar2.default, _landing2.default, _login2.default, _monitor2.default, _affiliate2.default, _deals2.default]).config(_index2.default).run(_index4.default);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * State-based routing for AngularJS 1.x\n\t * This bundle requires the ui-router-core.js bundle from the @uirouter/core package.\n\t * @version v1.0.6\n\t * @link https://ui-router.github.io\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t(function (global, factory) {\n\t     true ? factory(exports, __webpack_require__(3), __webpack_require__(6)) :\n\t    typeof define === 'function' && define.amd ? define(['exports', 'angular', '@uirouter/core'], factory) :\n\t    (factory((global['@uirouter/angularjs'] = global['@uirouter/angularjs'] || {}),global.angular,global['@uirouter/core']));\n\t}(this, (function (exports,ng_from_import,_uirouter_core) { 'use strict';\n\t\n\tvar ng_from_global = angular;\n\tvar ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n\t\n\tfunction getNg1ViewConfigFactory() {\n\t    var templateFactory = null;\n\t    return function (path, view) {\n\t        templateFactory = templateFactory || _uirouter_core.services.$injector.get(\"$templateFactory\");\n\t        return [new Ng1ViewConfig(path, view, templateFactory)];\n\t    };\n\t}\n\tvar hasAnyKey = function (keys, obj) {\n\t    return keys.reduce(function (acc, key) { return acc || _uirouter_core.isDefined(obj[key]); }, false);\n\t};\n\t/**\n\t * This is a [[StateBuilder.builder]] function for angular1 `views`.\n\t *\n\t * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n\t * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n\t *\n\t * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n\t * and applies the state-level configuration to a view named `$default`.\n\t */\n\tfunction ng1ViewsBuilder(state) {\n\t    // Do not process root state\n\t    if (!state.parent)\n\t        return {};\n\t    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n\t    // Do not allow a state to have both state-level props and also a `views: {}` property.\n\t    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n\t    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n\t    if (_uirouter_core.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n\t        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n\t            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n\t            \"Move the following properties into a view (in the 'views' object): \" +\n\t            (\" \" + allViewKeys.filter(function (key) { return _uirouter_core.isDefined(state[key]); }).join(\", \")));\n\t    }\n\t    var views = {}, viewsObject = state.views || { \"$default\": _uirouter_core.pick(state, allViewKeys) };\n\t    _uirouter_core.forEach(viewsObject, function (config, name) {\n\t        // Account for views: { \"\": { template... } }\n\t        name = name || \"$default\";\n\t        // Account for views: { header: \"headerComponent\" }\n\t        if (_uirouter_core.isString(config))\n\t            config = { component: config };\n\t        // Make a shallow copy of the config object\n\t        config = _uirouter_core.extend({}, config);\n\t        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n\t        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n\t            throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n\t        }\n\t        config.resolveAs = config.resolveAs || '$resolve';\n\t        config.$type = \"ng1\";\n\t        config.$context = state;\n\t        config.$name = name;\n\t        var normalized = _uirouter_core.ViewService.normalizeUIViewTarget(config.$context, config.$name);\n\t        config.$uiViewName = normalized.uiViewName;\n\t        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\t        views[name] = config;\n\t    });\n\t    return views;\n\t}\n\tvar id = 0;\n\tvar Ng1ViewConfig = (function () {\n\t    function Ng1ViewConfig(path, viewDecl, factory) {\n\t        var _this = this;\n\t        this.path = path;\n\t        this.viewDecl = viewDecl;\n\t        this.factory = factory;\n\t        this.$id = id++;\n\t        this.loaded = false;\n\t        this.getTemplate = function (uiView, context) {\n\t            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;\n\t        };\n\t    }\n\t    Ng1ViewConfig.prototype.load = function () {\n\t        var _this = this;\n\t        var $q = _uirouter_core.services.$q;\n\t        var context = new _uirouter_core.ResolveContext(this.path);\n\t        var params = this.path.reduce(function (acc, node) { return _uirouter_core.extend(acc, node.paramValues); }, {});\n\t        var promises = {\n\t            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n\t            controller: $q.when(this.getController(context))\n\t        };\n\t        return $q.all(promises).then(function (results) {\n\t            _uirouter_core.trace.traceViewServiceEvent(\"Loaded\", _this);\n\t            _this.controller = results.controller;\n\t            _uirouter_core.extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n\t            return _this;\n\t        });\n\t    };\n\t    /**\n\t     * Gets the controller for a view configuration.\n\t     *\n\t     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n\t     */\n\t    Ng1ViewConfig.prototype.getController = function (context) {\n\t        var provider = this.viewDecl.controllerProvider;\n\t        if (!_uirouter_core.isInjectable(provider))\n\t            return this.viewDecl.controller;\n\t        var deps = _uirouter_core.services.$injector.annotate(provider);\n\t        var providerFn = _uirouter_core.isArray(provider) ? _uirouter_core.tail(provider) : provider;\n\t        var resolvable = new _uirouter_core.Resolvable(\"\", providerFn, deps);\n\t        return resolvable.get(context);\n\t    };\n\t    return Ng1ViewConfig;\n\t}());\n\t\n\t/** @module view */\n\t/** for typedoc */\n\t/**\n\t * Service which manages loading of templates from a ViewConfig.\n\t */\n\tvar TemplateFactory = (function () {\n\t    function TemplateFactory() {\n\t        var _this = this;\n\t        /** @hidden */ this._useHttp = ng.version.minor < 3;\n\t        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n\t                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n\t                _this.$http = $http;\n\t                _this.$templateCache = $templateCache;\n\t                return _this;\n\t            }];\n\t    }\n\t    /** @hidden */\n\t    TemplateFactory.prototype.useHttpService = function (value) {\n\t        this._useHttp = value;\n\t    };\n\t    \n\t    /**\n\t     * Creates a template from a configuration object.\n\t     *\n\t     * @param config Configuration object for which to load a template.\n\t     * The following properties are search in the specified order, and the first one\n\t     * that is defined is used to create the template:\n\t     *\n\t     * @param params  Parameters to pass to the template function.\n\t     * @param context The resolve context associated with the template's view\n\t     *\n\t     * @return {string|object}  The template html as a string, or a promise for\n\t     * that string,or `null` if no template is configured.\n\t     */\n\t    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n\t        var defaultTemplate = \"<ui-view></ui-view>\";\n\t        var asTemplate = function (result) { return _uirouter_core.services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n\t        var asComponent = function (result) { return _uirouter_core.services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n\t        return (_uirouter_core.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :\n\t            _uirouter_core.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n\t                _uirouter_core.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n\t                    _uirouter_core.isDefined(config.component) ? asComponent(config.component) :\n\t                        _uirouter_core.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n\t                            asTemplate(defaultTemplate));\n\t    };\n\t    \n\t    /**\n\t     * Creates a template from a string or a function returning a string.\n\t     *\n\t     * @param template html template as a string or function that returns an html template as a string.\n\t     * @param params Parameters to pass to the template function.\n\t     *\n\t     * @return {string|object} The template html as a string, or a promise for that\n\t     * string.\n\t     */\n\t    TemplateFactory.prototype.fromString = function (template, params) {\n\t        return _uirouter_core.isFunction(template) ? template(params) : template;\n\t    };\n\t    \n\t    /**\n\t     * Loads a template from the a URL via `$http` and `$templateCache`.\n\t     *\n\t     * @param {string|Function} url url of the template to load, or a function\n\t     * that returns a url.\n\t     * @param {Object} params Parameters to pass to the url function.\n\t     * @return {string|Promise.<string>} The template html as a string, or a promise\n\t     * for that string.\n\t     */\n\t    TemplateFactory.prototype.fromUrl = function (url, params) {\n\t        if (_uirouter_core.isFunction(url))\n\t            url = url(params);\n\t        if (url == null)\n\t            return null;\n\t        if (this._useHttp) {\n\t            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n\t                .then(function (response) {\n\t                return response.data;\n\t            });\n\t        }\n\t        return this.$templateRequest(url);\n\t    };\n\t    \n\t    /**\n\t     * Creates a template by invoking an injectable provider function.\n\t     *\n\t     * @param provider Function to invoke via `locals`\n\t     * @param {Function} injectFn a function used to invoke the template provider\n\t     * @return {string|Promise.<string>} The template html as a string, or a promise\n\t     * for that string.\n\t     */\n\t    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n\t        var deps = _uirouter_core.services.$injector.annotate(provider);\n\t        var providerFn = _uirouter_core.isArray(provider) ? _uirouter_core.tail(provider) : provider;\n\t        var resolvable = new _uirouter_core.Resolvable(\"\", providerFn, deps);\n\t        return resolvable.get(context);\n\t    };\n\t    \n\t    /**\n\t     * Creates a component's template by invoking an injectable provider function.\n\t     *\n\t     * @param provider Function to invoke via `locals`\n\t     * @param {Function} injectFn a function used to invoke the template provider\n\t     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n\t     */\n\t    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n\t        var deps = _uirouter_core.services.$injector.annotate(provider);\n\t        var providerFn = _uirouter_core.isArray(provider) ? _uirouter_core.tail(provider) : provider;\n\t        var resolvable = new _uirouter_core.Resolvable(\"\", providerFn, deps);\n\t        return resolvable.get(context);\n\t    };\n\t    \n\t    /**\n\t     * Creates a template from a component's name\n\t     *\n\t     * This implements route-to-component.\n\t     * It works by retrieving the component (directive) metadata from the injector.\n\t     * It analyses the component's bindings, then constructs a template that instantiates the component.\n\t     * The template wires input and output bindings to resolves or from the parent component.\n\t     *\n\t     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n\t     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n\t     * @param component {string} Component's name in camel case.\n\t     * @param bindings An object defining the component's bindings: {foo: '<'}\n\t     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n\t     */\n\t    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n\t        bindings = bindings || {};\n\t        // Bind once prefix\n\t        var prefix = ng.version.minor >= 3 ? \"::\" : \"\";\n\t        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n\t        var kebob = function (camelCase) {\n\t            var kebobed = _uirouter_core.kebobString(camelCase);\n\t            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n\t        };\n\t        var attributeTpl = function (input) {\n\t            var name = input.name, type = input.type;\n\t            var attrName = kebob(name);\n\t            // If the ui-view has an attribute which matches a binding on the routed component\n\t            // then pass that attribute through to the routed component template.\n\t            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n\t            if (uiView.attr(attrName) && !bindings[name])\n\t                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n\t            var resolveName = bindings[name] || name;\n\t            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n\t            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n\t            if (type === '@')\n\t                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n\t            // Wire \"&\" callbacks to resolves that return a callback function\n\t            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n\t            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n\t            if (type === '&') {\n\t                var res = context.getResolvable(resolveName);\n\t                var fn = res && res.data;\n\t                var args = fn && _uirouter_core.services.$injector.annotate(fn) || [];\n\t                // account for array style injection, i.e., ['foo', function(foo) {}]\n\t                var arrayIdxStr = _uirouter_core.isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n\t                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(\",\") + \")'\";\n\t            }\n\t            // some-attr=\"::$resolve.someResolveName\"\n\t            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n\t        };\n\t        var attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n\t        var kebobName = kebob(component);\n\t        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n\t    };\n\t    \n\t    return TemplateFactory;\n\t}());\n\t// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\n\tfunction getComponentBindings(name) {\n\t    var cmpDefs = _uirouter_core.services.$injector.get(name + \"Directive\"); // could be multiple\n\t    if (!cmpDefs || !cmpDefs.length)\n\t        throw new Error(\"Unable to find component named '\" + name + \"'\");\n\t    return cmpDefs.map(getBindings).reduce(_uirouter_core.unnestR, []);\n\t}\n\t// Given a directive definition, find its object input attributes\n\t// Use different properties, depending on the type of directive (component, bindToController, normal)\n\tvar getBindings = function (def) {\n\t    if (_uirouter_core.isObject(def.bindToController))\n\t        return scopeBindings(def.bindToController);\n\t    return scopeBindings(def.scope);\n\t};\n\t// for ng 1.2 style, process the scope: { input: \"=foo\" }\n\t// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\n\tvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n\t    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n\t    .filter(function (tuple) { return _uirouter_core.isDefined(tuple) && _uirouter_core.isArray(tuple[1]); })\n\t    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };\n\t\n\t/** @module ng1 */ /** for typedoc */\n\t/**\n\t * The Angular 1 `StateProvider`\n\t *\n\t * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\tvar StateProvider = (function () {\n\t    function StateProvider(stateRegistry, stateService) {\n\t        this.stateRegistry = stateRegistry;\n\t        this.stateService = stateService;\n\t        _uirouter_core.createProxyFunctions(_uirouter_core.val(StateProvider.prototype), this, _uirouter_core.val(this));\n\t    }\n\t    /**\n\t     * Decorates states when they are registered\n\t     *\n\t     * Allows you to extend (carefully) or override (at your own peril) the\n\t     * `stateBuilder` object used internally by [[StateRegistry]].\n\t     * This can be used to add custom functionality to ui-router,\n\t     * for example inferring templateUrl based on the state name.\n\t     *\n\t     * When passing only a name, it returns the current (original or decorated) builder\n\t     * function that matches `name`.\n\t     *\n\t     * The builder functions that can be decorated are listed below. Though not all\n\t     * necessarily have a good use case for decoration, that is up to you to decide.\n\t     *\n\t     * In addition, users can attach custom decorators, which will generate new\n\t     * properties within the state's internal definition. There is currently no clear\n\t     * use-case for this beyond accessing internal states (i.e. $state.$current),\n\t     * however, expect this to become increasingly relevant as we introduce additional\n\t     * meta-programming features.\n\t     *\n\t     * **Warning**: Decorators should not be interdependent because the order of\n\t     * execution of the builder functions in non-deterministic. Builder functions\n\t     * should only be dependent on the state definition object and super function.\n\t     *\n\t     *\n\t     * Existing builder functions and current return values:\n\t     *\n\t     * - **parent** `{object}` - returns the parent state object.\n\t     * - **data** `{object}` - returns state data, including any inherited data that is not\n\t     *   overridden by own values (if any).\n\t     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t     *   or `null`.\n\t     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n\t     *   navigable).\n\t     * - **params** `{object}` - returns an array of state params that are ensured to\n\t     *   be a super-set of parent's params.\n\t     * - **views** `{object}` - returns a views object where each key is an absolute view\n\t     *   name (i.e. \"viewName@stateName\") and each value is the config object\n\t     *   (template, controller) for the view. Even when you don't use the views object\n\t     *   explicitly on a state config, one is still created for you internally.\n\t     *   So by decorating this builder function you have access to decorating template\n\t     *   and controller properties.\n\t     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n\t     *   not including any params defined by ancestor states.\n\t     * - **path** `{string}` - returns the full path from the root down to this state.\n\t     *   Needed for state activation.\n\t     * - **includes** `{object}` - returns an object that includes every state that\n\t     *   would pass a `$state.includes()` test.\n\t     *\n\t     * #### Example:\n\t     * Override the internal 'views' builder with a function that takes the state\n\t     * definition, and a reference to the internal function being overridden:\n\t     * ```js\n\t     * $stateProvider.decorator('views', function (state, parent) {\n\t     *   let result = {},\n\t     *       views = parent(state);\n\t     *\n\t     *   angular.forEach(views, function (config, name) {\n\t     *     let autoName = (state.name + '.' + name).replace('.', '/');\n\t     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t     *     result[name] = config;\n\t     *   });\n\t     *   return result;\n\t     * });\n\t     *\n\t     * $stateProvider.state('home', {\n\t     *   views: {\n\t     *     'contact.list': { controller: 'ListController' },\n\t     *     'contact.item': { controller: 'ItemController' }\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * ```js\n\t     * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t     * // and /partials/home/contact/item.html, respectively.\n\t     * $state.go('home');\n\t     * ```\n\t     *\n\t     * @param {string} name The name of the builder function to decorate.\n\t     * @param {object} func A function that is responsible for decorating the original\n\t     * builder function. The function receives two parameters:\n\t     *\n\t     *   - `{object}` - state - The state config object.\n\t     *   - `{object}` - super - The original builder function.\n\t     *\n\t     * @return {object} $stateProvider - $stateProvider instance\n\t     */\n\t    StateProvider.prototype.decorator = function (name, func) {\n\t        return this.stateRegistry.decorator(name, func) || this;\n\t    };\n\t    StateProvider.prototype.state = function (name, definition) {\n\t        if (_uirouter_core.isObject(name)) {\n\t            definition = name;\n\t        }\n\t        else {\n\t            definition.name = name;\n\t        }\n\t        this.stateRegistry.register(definition);\n\t        return this;\n\t    };\n\t    /**\n\t     * Registers an invalid state handler\n\t     *\n\t     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n\t     */\n\t    StateProvider.prototype.onInvalid = function (callback) {\n\t        return this.stateService.onInvalid(callback);\n\t    };\n\t    return StateProvider;\n\t}());\n\t\n\t/** @module ng1 */ /** */\n\t/**\n\t * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n\t * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n\t *\n\t * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n\t * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n\t */\n\tvar getStateHookBuilder = function (hookName) {\n\t    return function stateHookBuilder(state, parentFn) {\n\t        var hook = state[hookName];\n\t        var pathname = hookName === 'onExit' ? 'from' : 'to';\n\t        function decoratedNg1Hook(trans, state) {\n\t            var resolveContext = new _uirouter_core.ResolveContext(trans.treeChanges(pathname));\n\t            var locals = _uirouter_core.extend(getLocals(resolveContext), { $state$: state, $transition$: trans });\n\t            return _uirouter_core.services.$injector.invoke(hook, this, locals);\n\t        }\n\t        return hook ? decoratedNg1Hook : undefined;\n\t    };\n\t};\n\t\n\t/**\n\t * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n\t */\n\tvar Ng1LocationServices = (function () {\n\t    function Ng1LocationServices($locationProvider) {\n\t        // .onChange() registry\n\t        this._urlListeners = [];\n\t        this.$locationProvider = $locationProvider;\n\t        var _lp = _uirouter_core.val($locationProvider);\n\t        _uirouter_core.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n\t    }\n\t    Ng1LocationServices.prototype.dispose = function () { };\n\t    Ng1LocationServices.prototype.onChange = function (callback) {\n\t        var _this = this;\n\t        this._urlListeners.push(callback);\n\t        return function () { return _uirouter_core.removeFrom(_this._urlListeners)(callback); };\n\t    };\n\t    Ng1LocationServices.prototype.html5Mode = function () {\n\t        var html5Mode = this.$locationProvider.html5Mode();\n\t        html5Mode = _uirouter_core.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n\t        return html5Mode && this.$sniffer.history;\n\t    };\n\t    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n\t        if (replace === void 0) { replace = false; }\n\t        if (newUrl)\n\t            this.$location.url(newUrl);\n\t        if (replace)\n\t            this.$location.replace();\n\t        if (state)\n\t            this.$location.state(state);\n\t        return this.$location.url();\n\t    };\n\t    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {\n\t        var _this = this;\n\t        this.$location = $location;\n\t        this.$sniffer = $sniffer;\n\t        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n\t        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n\t        var _loc = _uirouter_core.val($location);\n\t        var _browser = _uirouter_core.val($browser);\n\t        // Bind these LocationService functions to $location\n\t        _uirouter_core.createProxyFunctions(_loc, this, _loc, [\"replace\", \"path\", \"search\", \"hash\"]);\n\t        // Bind these LocationConfig functions to $location\n\t        _uirouter_core.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n\t        // Bind these LocationConfig functions to $browser\n\t        _uirouter_core.createProxyFunctions(_browser, this, _browser, ['baseHref']);\n\t    };\n\t    /**\n\t     * Applys ng1-specific path parameter encoding\n\t     *\n\t     * The Angular 1 `$location` service is a bit weird.\n\t     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n\t     *\n\t     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n\t     *\n\t     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n\t     *\n\t     * @param router\n\t     */\n\t    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n\t        var pathType = router.urlMatcherFactory.type('path');\n\t        pathType.encode = function (val$$1) {\n\t            return val$$1 != null ? val$$1.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : val$$1;\n\t        };\n\t        pathType.decode = function (val$$1) {\n\t            return val$$1 != null ? val$$1.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : val$$1;\n\t        };\n\t    };\n\t    return Ng1LocationServices;\n\t}());\n\t\n\t/** @module url */ /** */\n\t/**\n\t * Manages rules for client-side URL\n\t *\n\t * ### Deprecation warning:\n\t * This class is now considered to be an internal API\n\t * Use the [[UrlService]] instead.\n\t * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n\t *\n\t * This class manages the router rules for what to do when the URL changes.\n\t *\n\t * This provider remains for backwards compatibility.\n\t *\n\t * @deprecated\n\t */\n\tvar UrlRouterProvider = (function () {\n\t    /** @hidden */\n\t    function UrlRouterProvider(router) {\n\t        this._router = router;\n\t        this._urlRouter = router.urlRouter;\n\t    }\n\t    /** @hidden */\n\t    UrlRouterProvider.prototype.$get = function () {\n\t        var urlRouter = this._urlRouter;\n\t        urlRouter.update(true);\n\t        if (!urlRouter.interceptDeferred)\n\t            urlRouter.listen();\n\t        return urlRouter;\n\t    };\n\t    /**\n\t     * Registers a url handler function.\n\t     *\n\t     * Registers a low level url handler (a `rule`).\n\t     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n\t     *\n\t     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var app = angular.module('app', ['ui.router.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *   // Here's an example of how you might allow case insensitive urls\n\t     *   $urlRouterProvider.rule(function ($injector, $location) {\n\t     *     var path = $location.path(),\n\t     *         normalized = path.toLowerCase();\n\t     *\n\t     *     if (path !== normalized) {\n\t     *       return normalized;\n\t     *     }\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param ruleFn\n\t     * Handler function that takes `$injector` and `$location` services as arguments.\n\t     * You can use them to detect a url and return a different url as a string.\n\t     *\n\t     * @return [[UrlRouterProvider]] (`this`)\n\t     */\n\t    UrlRouterProvider.prototype.rule = function (ruleFn) {\n\t        var _this = this;\n\t        if (!_uirouter_core.isFunction(ruleFn))\n\t            throw new Error(\"'rule' must be a function\");\n\t        var match = function () {\n\t            return ruleFn(_uirouter_core.services.$injector, _this._router.locationService);\n\t        };\n\t        var rule = new _uirouter_core.BaseUrlRule(match, _uirouter_core.identity);\n\t        this._urlRouter.rule(rule);\n\t        return this;\n\t    };\n\t    \n\t    /**\n\t     * Defines the path or behavior to use when no url can be matched.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var app = angular.module('app', ['ui.router.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *   // if the path doesn't match any of the urls you configured\n\t     *   // otherwise will take care of routing the user to the\n\t     *   // specified url\n\t     *   $urlRouterProvider.otherwise('/index');\n\t     *\n\t     *   // Example of using function rule as param\n\t     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t     *     return '/a/valid/url';\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param rule\n\t     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n\t     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n\t     *\n\t     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t     */\n\t    UrlRouterProvider.prototype.otherwise = function (rule) {\n\t        var _this = this;\n\t        var urlRouter = this._urlRouter;\n\t        if (_uirouter_core.isString(rule)) {\n\t            urlRouter.otherwise(rule);\n\t        }\n\t        else if (_uirouter_core.isFunction(rule)) {\n\t            urlRouter.otherwise(function () { return rule(_uirouter_core.services.$injector, _this._router.locationService); });\n\t        }\n\t        else {\n\t            throw new Error(\"'rule' must be a string or function\");\n\t        }\n\t        return this;\n\t    };\n\t    \n\t    /**\n\t     * Registers a handler for a given url matching.\n\t     *\n\t     * If the handler is a string, it is\n\t     * treated as a redirect, and is interpolated according to the syntax of match\n\t     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t     *\n\t     * If the handler is a function, it is injectable.\n\t     * It gets invoked if `$location` matches.\n\t     * You have the option of inject the match object as `$match`.\n\t     *\n\t     * The handler can return\n\t     *\n\t     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t     *   will continue trying to find another one that matches.\n\t     * - **string** which is treated as a redirect and passed to `$location.url()`\n\t     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var app = angular.module('app', ['ui.router.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t     *     if ($state.$current.navigable !== state ||\n\t     *         !equalForKeys($match, $stateParams) {\n\t     *      $state.transitionTo(state, $match, false);\n\t     *     }\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n\t     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n\t     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n\t     *\n\t     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n\t     */\n\t    UrlRouterProvider.prototype.when = function (what, handler) {\n\t        if (_uirouter_core.isArray(handler) || _uirouter_core.isFunction(handler)) {\n\t            handler = UrlRouterProvider.injectableHandler(this._router, handler);\n\t        }\n\t        this._urlRouter.when(what, handler);\n\t        return this;\n\t    };\n\t    \n\t    UrlRouterProvider.injectableHandler = function (router, handler) {\n\t        return function (match) {\n\t            return _uirouter_core.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n\t        };\n\t    };\n\t    /**\n\t     * Disables monitoring of the URL.\n\t     *\n\t     * Call this method before UI-Router has bootstrapped.\n\t     * It will stop UI-Router from performing the initial url sync.\n\t     *\n\t     * This can be useful to perform some asynchronous initialization before the router starts.\n\t     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t     *   $urlRouterProvider.deferIntercept();\n\t     * })\n\t     *\n\t     * app.run(function (MyService, $urlRouter, $http) {\n\t     *   $http.get(\"/stuff\").then(function(resp) {\n\t     *     MyService.doStuff(resp.data);\n\t     *     $urlRouter.listen();\n\t     *     $urlRouter.sync();\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param defer Indicates whether to defer location change interception.\n\t     *        Passing no parameter is equivalent to `true`.\n\t     */\n\t    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n\t        this._urlRouter.deferIntercept(defer);\n\t    };\n\t    \n\t    return UrlRouterProvider;\n\t}());\n\t\n\t/**\n\t * # Angular 1 types\n\t *\n\t * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n\t * The customizations to the core types for Angular UI-Router are documented here.\n\t *\n\t * The optional [[$resolve]] service is also documented here.\n\t *\n\t * @module ng1\n\t * @preferred\n\t */\n\t/** for typedoc */\n\tng.module(\"ui.router.angular1\", []);\n\tvar mod_init = ng.module('ui.router.init', []);\n\tvar mod_util = ng.module('ui.router.util', ['ng', 'ui.router.init']);\n\tvar mod_rtr = ng.module('ui.router.router', ['ui.router.util']);\n\tvar mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\n\tvar mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\n\tvar mod_cmpt = ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line\n\tvar router = null;\n\t$uiRouter.$inject = ['$locationProvider'];\n\t/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\n\tfunction $uiRouter($locationProvider) {\n\t    // Create a new instance of the Router when the $uiRouterProvider is initialized\n\t    router = this.router = new _uirouter_core.UIRouter();\n\t    router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);\n\t    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n\t    router.stateRegistry.decorator(\"views\", ng1ViewsBuilder);\n\t    router.stateRegistry.decorator(\"onExit\", getStateHookBuilder(\"onExit\"));\n\t    router.stateRegistry.decorator(\"onRetain\", getStateHookBuilder(\"onRetain\"));\n\t    router.stateRegistry.decorator(\"onEnter\", getStateHookBuilder(\"onEnter\"));\n\t    router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());\n\t    var ng1LocationService = router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider);\n\t    Ng1LocationServices.monkeyPatchPathParameterType(router);\n\t    // backwards compat: also expose router instance as $uiRouterProvider.router\n\t    router['router'] = router;\n\t    router['$get'] = $get;\n\t    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n\t    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n\t        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n\t        delete router['router'];\n\t        delete router['$get'];\n\t        return router;\n\t    }\n\t    return router;\n\t}\n\tvar getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {\n\t        var service = $urp.router[serviceName];\n\t        service[\"$get\"] = function () { return service; };\n\t        return service;\n\t    }]; };\n\t// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\n\trunBlock.$inject = ['$injector', '$q', '$uiRouter'];\n\tfunction runBlock($injector, $q, $uiRouter) {\n\t    _uirouter_core.services.$injector = $injector;\n\t    _uirouter_core.services.$q = $q;\n\t    // The $injector is now available.\n\t    // Find any resolvables that had dependency annotation deferred\n\t    $uiRouter.stateRegistry.get()\n\t        .map(function (x) { return x.$$state().resolvables; })\n\t        .reduce(_uirouter_core.unnestR, [])\n\t        .filter(function (x) { return x.deps === \"deferred\"; })\n\t        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi); });\n\t}\n\t// $urlRouter service and $urlRouterProvider\n\tvar getUrlRouterProvider = function (uiRouter) {\n\t    return uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter);\n\t};\n\t// $state service and $stateProvider\n\t// $urlRouter service and $urlRouterProvider\n\tvar getStateProvider = function () {\n\t    return _uirouter_core.extend(router.stateProvider, { $get: function () { return router.stateService; } });\n\t};\n\twatchDigests.$inject = ['$rootScope'];\n\tfunction watchDigests($rootScope) {\n\t    $rootScope.$watch(function () { _uirouter_core.trace.approximateDigests++; });\n\t}\n\tmod_init.provider(\"$uiRouter\", $uiRouter);\n\tmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\n\tmod_util.provider('$urlService', getProviderFor('urlService'));\n\tmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\n\tmod_util.provider('$templateFactory', function () { return new TemplateFactory(); });\n\tmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\n\tmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\n\tmod_state.provider('$transitions', getProviderFor('transitionService'));\n\tmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\n\tmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\n\tmod_main.factory('$view', function () { return router.viewService; });\n\tmod_main.service(\"$trace\", function () { return _uirouter_core.trace; });\n\tmod_main.run(watchDigests);\n\tmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\n\tmod_state.run(['$state', function ($state) { }]);\n\tmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\n\tmod_init.run(runBlock);\n\t/** @hidden TODO: find a place to move this */\n\tvar getLocals = function (ctx) {\n\t    var tokens = ctx.getTokens().filter(_uirouter_core.isString);\n\t    var tuples = tokens.map(function (key) {\n\t        var resolvable = ctx.getResolvable(key);\n\t        var waitPolicy = ctx.getPolicy(resolvable).async;\n\t        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n\t    });\n\t    return tuples.reduce(_uirouter_core.applyPairs, {});\n\t};\n\t\n\t/**\n\t * # Angular 1 injectable services\n\t *\n\t * This is a list of the objects which can be injected using angular's injector.\n\t *\n\t * There are three different kind of injectable objects:\n\t *\n\t * ## **Provider** objects\n\t * #### injectable into a `.config()` block during configtime\n\t *\n\t * - [[$uiRouterProvider]]: The UI-Router instance\n\t * - [[$stateProvider]]: State registration\n\t * - [[$transitionsProvider]]: Transition hooks\n\t * - [[$urlServiceProvider]]: All URL related public APIs\n\t *\n\t * - [[$uiViewScrollProvider]]: Disable ui-router view scrolling\n\t * - [[$urlRouterProvider]]: (deprecated) Url matching rules\n\t * - [[$urlMatcherFactoryProvider]]: (deprecated) Url parsing config\n\t *\n\t * ## **Service** objects\n\t * #### injectable globally during runtime\n\t *\n\t * - [[$uiRouter]]: The UI-Router instance\n\t * - [[$trace]]: Enable transition trace/debug\n\t * - [[$transitions]]: Transition hooks\n\t * - [[$state]]: Imperative state related APIs\n\t * - [[$stateRegistry]]: State registration\n\t * - [[$urlService]]: All URL related public APIs\n\t * - [[$uiRouterGlobals]]: Global variables\n\t * - [[$uiViewScroll]]: Scroll an element into view\n\t *\n\t * - [[$stateParams]]: (deprecated) Global state param values\n\t * - [[$urlRouter]]: (deprecated) URL synchronization\n\t * - [[$urlMatcherFactory]]: (deprecated) URL parsing config\n\t *\n\t * ## **Per-Transition** objects\n\t *\n\t * - These kind of objects are injectable into:\n\t *   - Resolves ([[Ng1StateDeclaration.resolve]]),\n\t *   - Transition Hooks ([[TransitionService.onStart]], etc),\n\t *   - Routed Controllers ([[Ng1ViewDeclaration.controller]])\n\t *\n\t * #### Different instances are injected based on the [[Transition]]\n\t *\n\t * - [[$transition$]]: The current Transition object\n\t * - [[$stateParams]]: State param values for pending Transition (deprecated)\n\t * - Any resolve data defined using [[Ng1StateDeclaration.resolve]]\n\t *\n\t * @ng1api\n\t * @preferred\n\t * @module injectables\n\t */ /** */\n\t/**\n\t * The current (or pending) State Parameters\n\t *\n\t * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.\n\t *\n\t * The values are not updated until *after* a `Transition` successfully completes.\n\t *\n\t * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.\n\t *\n\t * ### Deprecation warning:\n\t *\n\t * The value injected for `$stateParams` is different depending on where it is injected.\n\t *\n\t * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.\n\t * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.\n\t *\n\t * Because of these confusing details, this service is deprecated.\n\t *\n\t * ### Instead of using the global `$stateParams` service object,\n\t * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]\n\t *\n\t * ```js\n\t * MyService.$inject = ['$uiRouterGlobals'];\n\t * function MyService($uiRouterGlobals) {\n\t *   return {\n\t *     paramValues: function () {\n\t *       return $uiRouterGlobals.params;\n\t *     }\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * ### Instead of using the per-transition `$stateParams` object,\n\t * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]\n\t *\n\t * ```js\n\t * MyController.$inject = ['$transition$'];\n\t * function MyController($transition$) {\n\t *   var username = $transition$.params().username;\n\t *   // .. do something with username\n\t * }\n\t * ```\n\t *\n\t * ---\n\t *\n\t * This object can be injected into other services.\n\t *\n\t * #### Deprecated Example:\n\t * ```js\n\t * SomeService.$inject = ['$http', '$stateParams'];\n\t * function SomeService($http, $stateParams) {\n\t *   return {\n\t *     getUser: function() {\n\t *       return $http.get('/api/users/' + $stateParams.username);\n\t *     }\n\t *   }\n\t * };\n\t * angular.service('SomeService', SomeService);\n\t * ```\n\t * @deprecated\n\t */\n\t\n\t/**\n\t * # Angular 1 Directives\n\t *\n\t * These are the directives included in UI-Router for Angular 1.\n\t * These directives are used in templates to create viewports and link/navigate to states.\n\t *\n\t * @ng1api\n\t * @preferred\n\t * @module directives\n\t */ /** for typedoc */\n\t/** @hidden */\n\tfunction parseStateRef(ref) {\n\t    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t    if (paramsOnly)\n\t        ref = '(' + paramsOnly[1] + ')';\n\t    parsed = ref.replace(/\\n/g, \" \").match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n\t    if (!parsed || parsed.length !== 4)\n\t        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n\t}\n\t/** @hidden */\n\tfunction stateContext(el) {\n\t    var $uiView = el.parent().inheritedData('$uiView');\n\t    var path = _uirouter_core.parse('$cfg.path')($uiView);\n\t    return path ? _uirouter_core.tail(path).state.name : undefined;\n\t}\n\t/** @hidden */\n\tfunction processedDef($state, $element, def) {\n\t    var uiState = def.uiState || $state.current.name;\n\t    var uiStateOpts = _uirouter_core.extend(defaultOpts($element, $state), def.uiStateOpts || {});\n\t    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n\t    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n\t}\n\t/** @hidden */\n\tfunction getTypeInfo(el) {\n\t    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t    var isForm = el[0].nodeName === \"FORM\";\n\t    return {\n\t        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t        clickable: !isForm\n\t    };\n\t}\n\t/** @hidden */\n\tfunction clickHook(el, $state, $timeout, type, getDef) {\n\t    return function (e) {\n\t        var button = e.which || e.button, target = getDef();\n\t        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t            var transition = $timeout(function () {\n\t                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n\t            });\n\t            e.preventDefault();\n\t            // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n\t            e.preventDefault = function () {\n\t                if (ignorePreventDefaultCount-- <= 0)\n\t                    $timeout.cancel(transition);\n\t            };\n\t        }\n\t    };\n\t}\n\t/** @hidden */\n\tfunction defaultOpts(el, $state) {\n\t    return {\n\t        relative: stateContext(el) || $state.$current,\n\t        inherit: true,\n\t        source: \"sref\"\n\t    };\n\t}\n\t/** @hidden */\n\tfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n\t    var events;\n\t    if (uiStateOpts) {\n\t        events = uiStateOpts.events;\n\t    }\n\t    if (!_uirouter_core.isArray(events)) {\n\t        events = ['click'];\n\t    }\n\t    var on = element.on ? 'on' : 'bind';\n\t    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n\t        var event_1 = events_1[_i];\n\t        element[on](event_1, hookFn);\n\t    }\n\t    scope.$on('$destroy', function () {\n\t        var off = element.off ? 'off' : 'unbind';\n\t        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n\t            var event_2 = events_2[_i];\n\t            element[off](event_2, hookFn);\n\t        }\n\t    });\n\t}\n\t/**\n\t * `ui-sref`: A directive for linking to a state\n\t *\n\t * A directive which links to a state (and optionally, parameters).\n\t * When clicked, this directive activates the linked state with the supplied parameter values.\n\t *\n\t * ### Linked State\n\t * The attribute value of the `ui-sref` is the name of the state to link to.\n\t *\n\t * #### Example:\n\t * This will activate the `home` state when the link is clicked.\n\t * ```html\n\t * <a ui-sref=\"home\">Home</a>\n\t * ```\n\t *\n\t * ### Relative Links\n\t * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n\t * You just need to be aware that the path is relative to the state that *created* the link.\n\t * This allows a state to create a relative `ui-sref` which always targets the same destination.\n\t *\n\t * #### Example:\n\t * Both these links are relative to the parent state, even when a child state is currently active.\n\t * ```html\n\t * <a ui-sref=\".child1\">child 1 state</a>\n\t * <a ui-sref=\".child2\">child 2 state</a>\n\t * ```\n\t *\n\t * This link activates the parent state.\n\t * ```html\n\t * <a ui-sref=\"^\">Return</a>\n\t * ```\n\t *\n\t * ### hrefs\n\t * If the linked state has a URL, the directive will automatically generate and\n\t * update the `href` attribute (using the [[StateService.href]]  method).\n\t *\n\t * #### Example:\n\t * Assuming the `users` state has a url of `/users/`\n\t * ```html\n\t * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n\t * ```\n\t *\n\t * ### Parameter Values\n\t * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n\t * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n\t * The content inside the parentheses is an expression, evaluated to the parameter values.\n\t *\n\t * #### Example:\n\t * This example renders a list of links to users.\n\t * The state's `userId` parameter value comes from each user's `user.id` property.\n\t * ```html\n\t * <li ng-repeat=\"user in users\">\n\t *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n\t * </li>\n\t * ```\n\t *\n\t * Note:\n\t * The parameter values expression is `$watch`ed for updates.\n\t *\n\t * ### Transition Options\n\t * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n\t * Options are restricted to `location`, `inherit`, and `reload`.\n\t *\n\t * #### Example:\n\t * ```html\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n\t * ```\n\t *\n\t * ### Other DOM Events\n\t *\n\t * You can also customize which DOM events to respond to (instead of `click`) by\n\t * providing an `events` array in the `ui-sref-opts` attribute.\n\t *\n\t * #### Example:\n\t * ```html\n\t * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n\t * ```\n\t *\n\t * ### Highlighting the active link\n\t * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n\t *\n\t * ### Examples\n\t * If you have the following template:\n\t *\n\t * ```html\n\t * <a ui-sref=\"home\">Home</a>\n\t * <a ui-sref=\"about\">About</a>\n\t * <a ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * ```\n\t *\n\t * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n\t *\n\t * ```html\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n\t * <a href=\"#/about\" ui-sref=\"about\">About</a>\n\t * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * ```\n\t *\n\t * ### Notes\n\t *\n\t * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n\t * #### Example:\n\t * Sets the `lang` parameter to `en` and remains on the same state.\n\t *\n\t * ```html\n\t * <a ui-sref=\"{ lang: 'en' }\">English</a>\n\t * ```\n\t *\n\t * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n\t *\n\t * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n\t * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n\t */\n\tvar uiSref;\n\tuiSref = ['$uiRouter', '$timeout',\n\t    function $StateRefDirective($uiRouter, $timeout) {\n\t        var $state = $uiRouter.stateService;\n\t        return {\n\t            restrict: 'A',\n\t            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t            link: function (scope, element, attrs, uiSrefActive) {\n\t                var type = getTypeInfo(element);\n\t                var active = uiSrefActive[1] || uiSrefActive[0];\n\t                var unlinkInfoFn = null;\n\t                var hookFn;\n\t                var rawDef = {};\n\t                var getDef = function () { return processedDef($state, element, rawDef); };\n\t                var ref = parseStateRef(attrs.uiSref);\n\t                rawDef.uiState = ref.state;\n\t                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n\t                function update() {\n\t                    var def = getDef();\n\t                    if (unlinkInfoFn)\n\t                        unlinkInfoFn();\n\t                    if (active)\n\t                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n\t                    if (def.href != null)\n\t                        attrs.$set(type.attr, def.href);\n\t                }\n\t                if (ref.paramExpr) {\n\t                    scope.$watch(ref.paramExpr, function (val$$1) {\n\t                        rawDef.uiStateParams = _uirouter_core.extend({}, val$$1);\n\t                        update();\n\t                    }, true);\n\t                    rawDef.uiStateParams = _uirouter_core.extend({}, scope.$eval(ref.paramExpr));\n\t                }\n\t                update();\n\t                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n\t                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n\t                if (!type.clickable)\n\t                    return;\n\t                hookFn = clickHook(element, $state, $timeout, type, getDef);\n\t                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n\t            }\n\t        };\n\t    }];\n\t/**\n\t * `ui-state`: A fully dynamic directive for linking to a state\n\t *\n\t * A directive which links to a state (and optionally, parameters).\n\t * When clicked, this directive activates the linked state with the supplied parameter values.\n\t *\n\t * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n\t *\n\t * A directive which links to a state (and optionally, parameters).\n\t * When clicked, this directive activates the linked state with the supplied parameter values.\n\t *\n\t * ### Linked State\n\t * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n\t * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n\t *\n\t * #### Example:\n\t * Create a list of links.\n\t * ```html\n\t * <li ng-repeat=\"link in navlinks\">\n\t *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n\t * </li>\n\t * ```\n\t *\n\t * ### Relative Links\n\t * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n\t * You just need to be aware that the path is relative to the state that *created* the link.\n\t * This allows a state to create relative `ui-state` which always targets the same destination.\n\t *\n\t * ### hrefs\n\t * If the linked state has a URL, the directive will automatically generate and\n\t * update the `href` attribute (using the [[StateService.href]]  method).\n\t *\n\t * ### Parameter Values\n\t * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n\t * Param values should be provided using the `ui-state-params` attribute.\n\t * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n\t *\n\t * #### Example:\n\t * This example renders a list of links with param values.\n\t * The state's `userId` parameter value comes from each user's `user.id` property.\n\t * ```html\n\t * <li ng-repeat=\"link in navlinks\">\n\t *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n\t * </li>\n\t * ```\n\t *\n\t * ### Transition Options\n\t * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n\t * Options are restricted to `location`, `inherit`, and `reload`.\n\t * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n\t *\n\t * #### Example:\n\t * ```html\n\t * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n\t * ```\n\t *\n\t * ### Other DOM Events\n\t *\n\t * You can also customize which DOM events to respond to (instead of `click`) by\n\t * providing an `events` array in the `ui-state-opts` attribute.\n\t *\n\t * #### Example:\n\t * ```html\n\t * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n\t * ```\n\t *\n\t * ### Highlighting the active link\n\t * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n\t *\n\t * ### Notes\n\t *\n\t * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n\t *   However, it might be simpler to use [[uiSref]] parameter-only links.\n\t *\n\t * #### Example:\n\t * Sets the `lang` parameter to `en` and remains on the same state.\n\t *\n\t * ```html\n\t * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n\t * ```\n\t *\n\t * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n\t * ```\n\t */\n\tvar uiState;\n\tuiState = ['$uiRouter', '$timeout',\n\t    function $StateRefDynamicDirective($uiRouter, $timeout) {\n\t        var $state = $uiRouter.stateService;\n\t        return {\n\t            restrict: 'A',\n\t            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t            link: function (scope, element, attrs, uiSrefActive) {\n\t                var type = getTypeInfo(element);\n\t                var active = uiSrefActive[1] || uiSrefActive[0];\n\t                var unlinkInfoFn = null;\n\t                var hookFn;\n\t                var rawDef = {};\n\t                var getDef = function () { return processedDef($state, element, rawDef); };\n\t                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n\t                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = _uirouter_core.noop, acc); }, {});\n\t                function update() {\n\t                    var def = getDef();\n\t                    if (unlinkInfoFn)\n\t                        unlinkInfoFn();\n\t                    if (active)\n\t                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n\t                    if (def.href != null)\n\t                        attrs.$set(type.attr, def.href);\n\t                }\n\t                inputAttrs.forEach(function (field) {\n\t                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n\t                    attrs.$observe(field, function (expr) {\n\t                        watchDeregFns[field]();\n\t                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n\t                            rawDef[field] = newval;\n\t                            update();\n\t                        }, true);\n\t                    });\n\t                });\n\t                update();\n\t                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n\t                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n\t                if (!type.clickable)\n\t                    return;\n\t                hookFn = clickHook(element, $state, $timeout, type, getDef);\n\t                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n\t            }\n\t        };\n\t    }];\n\t/**\n\t * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n\t *\n\t * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n\t * related directive's state is active (and remove them when it is inactive).\n\t *\n\t * The primary use-case is to highlight the active link in navigation menus,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ### Linking to a `ui-sref` or `ui-state`\n\t * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n\t * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n\t *\n\t * ### Matching\n\t *\n\t * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n\t * This is a \"fuzzy match\" which uses [[StateService.includes]].\n\t *\n\t * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n\t * This is an \"exact match\" which uses [[StateService.is]].\n\t *\n\t * ### Parameter values\n\t * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n\t * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n\t *\n\t * #### Example:\n\t * ```html\n\t * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n\t *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n\t * </li>\n\t * ```\n\t *\n\t * ### Examples\n\t *\n\t * Given the following template:\n\t * #### Example:\n\t * ```html\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * ```\n\t *\n\t * When the app state is `app.user` (or any child state),\n\t * and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t *\n\t * ```html\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * ```\n\t *\n\t * ### Glob mode\n\t *\n\t * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n\t * The objects keys represent active class names and values represent the respective state names/globs.\n\t * `ui-sref-active` will match if the current active state **includes** any of\n\t * the specified state names/globs, even the abstract ones.\n\t *\n\t * #### Example:\n\t * Given the following template, with \"admin\" being an abstract state:\n\t * ```html\n\t * <div ui-sref-active=\"{'active': 'admin.**'}\">\n\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t * </div>\n\t * ```\n\t *\n\t * When the current state is \"admin.roles\" the \"active\" class will be applied to both the <div> and <a> elements.\n\t * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n\t *\n\t * ### Notes:\n\t *\n\t * - The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n\t */\n\tvar uiSrefActive;\n\tuiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n\t    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n\t        return {\n\t            restrict: \"A\",\n\t            controller: ['$scope', '$element', '$attrs',\n\t                function ($scope, $element, $attrs) {\n\t                    var states = [], activeEqClass, uiSrefActive;\n\t                    // There probably isn't much point in $observing this\n\t                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t                    // slight difference in logic routing\n\t                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t                    try {\n\t                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t                    }\n\t                    catch (e) {\n\t                        // Do nothing. uiSrefActive is not a valid expression.\n\t                        // Fall back to using $interpolate below\n\t                    }\n\t                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t                    if (_uirouter_core.isObject(uiSrefActive)) {\n\t                        _uirouter_core.forEach(uiSrefActive, function (stateOrName, activeClass) {\n\t                            if (_uirouter_core.isString(stateOrName)) {\n\t                                var ref = parseStateRef(stateOrName);\n\t                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t                            }\n\t                        });\n\t                    }\n\t                    // Allow uiSref to communicate with uiSrefActive[Equals]\n\t                    this.$$addStateInfo = function (newState, newParams) {\n\t                        // we already got an explicit state provided by ui-sref-active, so we\n\t                        // shadow the one that comes from ui-sref\n\t                        if (_uirouter_core.isObject(uiSrefActive) && states.length > 0) {\n\t                            return;\n\t                        }\n\t                        var deregister = addState(newState, newParams, uiSrefActive);\n\t                        update();\n\t                        return deregister;\n\t                    };\n\t                    function updateAfterTransition(trans) {\n\t                        trans.promise.then(update, _uirouter_core.noop);\n\t                    }\n\t                    $scope.$on('$stateChangeSuccess', update);\n\t                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));\n\t                    if ($uiRouter.globals.transition) {\n\t                        updateAfterTransition($uiRouter.globals.transition);\n\t                    }\n\t                    function addState(stateName, stateParams, activeClass) {\n\t                        var state = $state.get(stateName, stateContext($element));\n\t                        var stateInfo = {\n\t                            state: state || { name: stateName },\n\t                            params: stateParams,\n\t                            activeClass: activeClass\n\t                        };\n\t                        states.push(stateInfo);\n\t                        return function removeState() {\n\t                            _uirouter_core.removeFrom(states)(stateInfo);\n\t                        };\n\t                    }\n\t                    // Update route state\n\t                    function update() {\n\t                        var splitClasses = function (str) {\n\t                            return str.split(/\\s/).filter(_uirouter_core.identity);\n\t                        };\n\t                        var getClasses = function (stateList) {\n\t                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(_uirouter_core.unnestR, []);\n\t                        };\n\t                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(_uirouter_core.uniqR, []);\n\t                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n\t                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n\t                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n\t                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(_uirouter_core.uniqR, []);\n\t                        var removeClasses = allClasses.filter(function (cls) { return !_uirouter_core.inArray(addClasses, cls); });\n\t                        $scope.$evalAsync(function () {\n\t                            addClasses.forEach(function (className) { return $element.addClass(className); });\n\t                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n\t                        });\n\t                    }\n\t                    update();\n\t                }]\n\t        };\n\t    }];\n\tng.module('ui.router.state')\n\t    .directive('uiSref', uiSref)\n\t    .directive('uiSrefActive', uiSrefActive)\n\t    .directive('uiSrefActiveEq', uiSrefActive)\n\t    .directive('uiState', uiState);\n\t\n\t/** @module ng1 */ /** for typedoc */\n\t/**\n\t * `isState` Filter: truthy if the current state is the parameter\n\t *\n\t * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n\t *\n\t * #### Example:\n\t * ```html\n\t * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n\t * ```\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t    var isFilter = function (state, params, options) {\n\t        return $state.is(state, params, options);\n\t    };\n\t    isFilter.$stateful = true;\n\t    return isFilter;\n\t}\n\t/**\n\t * `includedByState` Filter: truthy if the current state includes the parameter\n\t *\n\t * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n\t *\n\t * #### Example:\n\t * ```html\n\t * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n\t * ```\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t    var includesFilter = function (state, params, options) {\n\t        return $state.includes(state, params, options);\n\t    };\n\t    includesFilter.$stateful = true;\n\t    return includesFilter;\n\t}\n\tng.module('ui.router.state')\n\t    .filter('isState', $IsStateFilter)\n\t    .filter('includedByState', $IncludedByStateFilter);\n\t\n\t/**\n\t * @ng1api\n\t * @module directives\n\t */ /** for typedoc */\n\t/**\n\t * `ui-view`: A viewport directive which is filled in by a view from the active state.\n\t *\n\t * ### Attributes\n\t *\n\t * - `name`: (Optional) A view name.\n\t *   The name should be unique amongst the other views in the same state.\n\t *   You can have views of the same name that live in different states.\n\t *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n\t *\n\t * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n\t *   Uses [[$uiViewScroll]] to do the scrolling.\n\t *\n\t * - `onload`: Expression to evaluate whenever the view updates.\n\t *\n\t * #### Example:\n\t * A view can be unnamed or named.\n\t * ```html\n\t * <!-- Unnamed -->\n\t * <div ui-view></div>\n\t *\n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t *\n\t * <!-- Named (different style) -->\n\t * <ui-view name=\"viewName\"></ui-view>\n\t * ```\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a\n\t * single view and it is unnamed then you can populate it like so:\n\t *\n\t * ```html\n\t * <div ui-view></div>\n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * ```\n\t *\n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n\t * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n\t *\n\t * ```js\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * But typically you'll only use the views property if you name your view or have more than one view\n\t * in the same template. There's not really a compelling reason to name a view if its the only one,\n\t * but you could if you wanted, like so:\n\t *\n\t * ```html\n\t * <div ui-view=\"main\"></div>\n\t * ```\n\t *\n\t * ```js\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * Really though, you'll use views to set up multiple views:\n\t *\n\t * ```html\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div>\n\t * <div ui-view=\"data\"></div>\n\t * ```\n\t *\n\t * ```js\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * #### Examples for `autoscroll`:\n\t * ```html\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * ```\n\t *\n\t * Resolve data:\n\t *\n\t * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n\t * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n\t *\n\t * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n\t * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n\t * depends on `$resolve` data.\n\t *\n\t * #### Example:\n\t * ```js\n\t * $stateProvider.state('home', {\n\t *   template: '<my-component user=\"$resolve.user\"></my-component>',\n\t *   resolve: {\n\t *     user: function(UserService) { return UserService.fetchUser(); }\n\t *   }\n\t * });\n\t * ```\n\t */\n\tvar uiView;\n\tuiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n\t    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n\t        function getRenderer(attrs, scope) {\n\t            return {\n\t                enter: function (element, target, cb) {\n\t                    if (ng.version.minor > 2) {\n\t                        $animate.enter(element, null, target).then(cb);\n\t                    }\n\t                    else {\n\t                        $animate.enter(element, null, target, cb);\n\t                    }\n\t                },\n\t                leave: function (element, cb) {\n\t                    if (ng.version.minor > 2) {\n\t                        $animate.leave(element).then(cb);\n\t                    }\n\t                    else {\n\t                        $animate.leave(element, cb);\n\t                    }\n\t                }\n\t            };\n\t        }\n\t        function configsEqual(config1, config2) {\n\t            return config1 === config2;\n\t        }\n\t        var rootData = {\n\t            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n\t            $uiView: {}\n\t        };\n\t        var directive = {\n\t            count: 0,\n\t            restrict: 'ECA',\n\t            terminal: true,\n\t            priority: 400,\n\t            transclude: 'element',\n\t            compile: function (tElement, tAttrs, $transclude) {\n\t                return function (scope, $element, attrs) {\n\t                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n\t                    var activeUIView = {\n\t                        $type: 'ng1',\n\t                        id: directive.count++,\n\t                        name: name,\n\t                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n\t                        config: null,\n\t                        configUpdated: configUpdatedCallback,\n\t                        get creationContext() {\n\t                            var fromParentTagConfig = _uirouter_core.parse('$cfg.viewDecl.$context')(inherited);\n\t                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n\t                            // See https://github.com/angular-ui/ui-router/issues/3355\n\t                            var fromParentTag = _uirouter_core.parse('$uiView.creationContext')(inherited);\n\t                            return fromParentTagConfig || fromParentTag;\n\t                        }\n\t                    };\n\t                    _uirouter_core.trace.traceUIViewEvent(\"Linking\", activeUIView);\n\t                    function configUpdatedCallback(config) {\n\t                        if (config && !(config instanceof Ng1ViewConfig))\n\t                            return;\n\t                        if (configsEqual(viewConfig, config))\n\t                            return;\n\t                        _uirouter_core.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n\t                        viewConfig = config;\n\t                        updateView(config);\n\t                    }\n\t                    $element.data('$uiView', { $uiView: activeUIView });\n\t                    updateView();\n\t                    unregister = $view.registerUIView(activeUIView);\n\t                    scope.$on(\"$destroy\", function () {\n\t                        _uirouter_core.trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n\t                        unregister();\n\t                    });\n\t                    function cleanupLastView() {\n\t                        if (previousEl) {\n\t                            _uirouter_core.trace.traceUIViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n\t                            previousEl.remove();\n\t                            previousEl = null;\n\t                        }\n\t                        if (currentScope) {\n\t                            _uirouter_core.trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n\t                            currentScope.$destroy();\n\t                            currentScope = null;\n\t                        }\n\t                        if (currentEl) {\n\t                            var _viewData_1 = currentEl.data('$uiViewAnim');\n\t                            _uirouter_core.trace.traceUIViewEvent(\"Animate out\", _viewData_1);\n\t                            renderer.leave(currentEl, function () {\n\t                                _viewData_1.$$animLeave.resolve();\n\t                                previousEl = null;\n\t                            });\n\t                            previousEl = currentEl;\n\t                            currentEl = null;\n\t                        }\n\t                    }\n\t                    function updateView(config) {\n\t                        var newScope = scope.$new();\n\t                        var animEnter = $q.defer(), animLeave = $q.defer();\n\t                        var $uiViewData = {\n\t                            $cfg: config,\n\t                            $uiView: activeUIView,\n\t                        };\n\t                        var $uiViewAnim = {\n\t                            $animEnter: animEnter.promise,\n\t                            $animLeave: animLeave.promise,\n\t                            $$animLeave: animLeave\n\t                        };\n\t                        /**\n\t                         * @ngdoc event\n\t                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n\t                         * @eventOf ui.router.state.directive:ui-view\n\t                         * @eventType emits on ui-view directive scope\n\t                         * @description\n\t                         *\n\t                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t                         *\n\t                         * @param {Object} event Event object.\n\t                         * @param {string} viewName Name of the view.\n\t                         */\n\t                        newScope.$emit('$viewContentLoading', name);\n\t                        var cloned = $transclude(newScope, function (clone) {\n\t                            clone.data('$uiViewAnim', $uiViewAnim);\n\t                            clone.data('$uiView', $uiViewData);\n\t                            renderer.enter(clone, $element, function onUIViewEnter() {\n\t                                animEnter.resolve();\n\t                                if (currentScope)\n\t                                    currentScope.$emit('$viewContentAnimationEnded');\n\t                                if (_uirouter_core.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                                    $uiViewScroll(clone);\n\t                                }\n\t                            });\n\t                            cleanupLastView();\n\t                        });\n\t                        currentEl = cloned;\n\t                        currentScope = newScope;\n\t                        /**\n\t                         * @ngdoc event\n\t                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t                         * @eventOf ui.router.state.directive:ui-view\n\t                         * @eventType emits on ui-view directive scope\n\t                         * @description           *\n\t                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t                         *\n\t                         * @param {Object} event Event object.\n\t                         */\n\t                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n\t                        currentScope.$eval(onloadExp);\n\t                    }\n\t                };\n\t            }\n\t        };\n\t        return directive;\n\t    }];\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n\t/** @hidden */\n\tfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n\t    var getControllerAs = _uirouter_core.parse('viewDecl.controllerAs');\n\t    var getResolveAs = _uirouter_core.parse('viewDecl.resolveAs');\n\t    return {\n\t        restrict: 'ECA',\n\t        priority: -400,\n\t        compile: function (tElement) {\n\t            var initial = tElement.html();\n\t            tElement.empty();\n\t            return function (scope, $element) {\n\t                var data = $element.data('$uiView');\n\t                if (!data) {\n\t                    $element.html(initial);\n\t                    $compile($element.contents())(scope);\n\t                    return;\n\t                }\n\t                var cfg = data.$cfg || { viewDecl: {}, getTemplate: ng_from_import.noop };\n\t                var resolveCtx = cfg.path && new _uirouter_core.ResolveContext(cfg.path);\n\t                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n\t                _uirouter_core.trace.traceUIViewFill(data.$uiView, $element.html());\n\t                var link = $compile($element.contents());\n\t                var controller = cfg.controller;\n\t                var controllerAs = getControllerAs(cfg);\n\t                var resolveAs = getResolveAs(cfg);\n\t                var locals = resolveCtx && getLocals(resolveCtx);\n\t                scope[resolveAs] = locals;\n\t                if (controller) {\n\t                    var controllerInstance = $controller(controller, _uirouter_core.extend({}, locals, { $scope: scope, $element: $element }));\n\t                    if (controllerAs) {\n\t                        scope[controllerAs] = controllerInstance;\n\t                        scope[controllerAs][resolveAs] = locals;\n\t                    }\n\t                    // TODO: Use $view service as a central point for registering component-level hooks\n\t                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n\t                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n\t                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n\t                    $element.data('$ngControllerController', controllerInstance);\n\t                    $element.children().data('$ngControllerController', controllerInstance);\n\t                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n\t                }\n\t                // Wait for the component to appear in the DOM\n\t                if (_uirouter_core.isString(cfg.viewDecl.component)) {\n\t                    var cmp_1 = cfg.viewDecl.component;\n\t                    var kebobName = _uirouter_core.kebobString(cmp_1);\n\t                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", \"i\");\n\t                    var getComponentController = function () {\n\t                        var directiveEl = [].slice.call($element[0].children)\n\t                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n\t                        return directiveEl && ng.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n\t                    };\n\t                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n\t                        if (!ctrlInstance)\n\t                            return;\n\t                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n\t                        deregisterWatch_1();\n\t                    });\n\t                }\n\t                link(scope);\n\t            };\n\t        }\n\t    };\n\t}\n\t/** @hidden */\n\tvar hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';\n\t/** @hidden incrementing id */\n\tvar _uiCanExitId = 0;\n\t/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\n\tfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n\t    // Call $onInit() ASAP\n\t    if (_uirouter_core.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n\t        controllerInstance.$onInit();\n\t    }\n\t    var viewState = _uirouter_core.tail(cfg.path).state.self;\n\t    var hookOptions = { bind: controllerInstance };\n\t    // Add component-level hook for onParamsChange\n\t    if (_uirouter_core.isFunction(controllerInstance.uiOnParamsChanged)) {\n\t        var resolveContext = new _uirouter_core.ResolveContext(cfg.path);\n\t        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n\t        // Fire callback on any successful transition\n\t        var paramsUpdated = function ($transition$) {\n\t            // Exit early if the $transition$ is the same as the view was created within.\n\t            // Exit early if the $transition$ will exit the state the view is for.\n\t            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n\t                return;\n\t            var toParams = $transition$.params(\"to\");\n\t            var fromParams = $transition$.params(\"from\");\n\t            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(_uirouter_core.unnestR, []);\n\t            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(_uirouter_core.unnestR, []);\n\t            // Find the to params that have different values than the from params\n\t            var changedToParams = toSchema.filter(function (param) {\n\t                var idx = fromSchema.indexOf(param);\n\t                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n\t            });\n\t            // Only trigger callback if a to param has changed or is new\n\t            if (changedToParams.length) {\n\t                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n\t                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n\t                var newValues = _uirouter_core.filter(toParams, function (val$$1, key) { return changedKeys_1.indexOf(key) !== -1; });\n\t                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n\t            }\n\t        };\n\t        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n\t    }\n\t    // Add component-level hook for uiCanExit\n\t    if (_uirouter_core.isFunction(controllerInstance.uiCanExit)) {\n\t        var id_1 = _uiCanExitId++;\n\t        var cacheProp_1 = '_uiCanExitIds';\n\t        // Returns true if a redirect transition already answered truthy\n\t        var prevTruthyAnswer_1 = function (trans) {\n\t            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n\t        };\n\t        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n\t        var wrappedHook = function (trans) {\n\t            var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n\t            if (!prevTruthyAnswer_1(trans)) {\n\t                promise = $q.when(controllerInstance.uiCanExit(trans));\n\t                promise.then(function (val$$1) { return ids[id_1] = (val$$1 !== false); });\n\t            }\n\t            return promise;\n\t        };\n\t        var criteria = { exiting: viewState.name };\n\t        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n\t    }\n\t}\n\tng.module('ui.router.state').directive('uiView', uiView);\n\tng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\t/** @module ng1 */ /** */\n\t/** @hidden */\n\tfunction $ViewScrollProvider() {\n\t    var useAnchorScroll = false;\n\t    this.useAnchorScroll = function () {\n\t        useAnchorScroll = true;\n\t    };\n\t    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t            if (useAnchorScroll) {\n\t                return $anchorScroll;\n\t            }\n\t            return function ($element) {\n\t                return $timeout(function () {\n\t                    $element[0].scrollIntoView();\n\t                }, 0, false);\n\t            };\n\t        }];\n\t}\n\tng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * Main entry point for angular 1.x build\n\t * @module ng1\n\t */ /** */\n\tvar index = \"ui.router\";\n\t\n\texports['default'] = index;\n\texports.core = _uirouter_core;\n\texports.watchDigests = watchDigests;\n\texports.getLocals = getLocals;\n\texports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;\n\texports.ng1ViewsBuilder = ng1ViewsBuilder;\n\texports.Ng1ViewConfig = Ng1ViewConfig;\n\texports.StateProvider = StateProvider;\n\texports.UrlRouterProvider = UrlRouterProvider;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t//# sourceMappingURL=ui-router-angularjs.js.map\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * UI-Router Core: Framework agnostic, State-based routing for JavaScript Single Page Apps\n\t * @version v5.0.6\n\t * @link https://ui-router.github.io\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global['@uirouter/core'] = global['@uirouter/core'] || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\t/**\n\t * Higher order functions\n\t *\n\t * These utility functions are exported, but are subject to change without notice.\n\t *\n\t * @module common_hof\n\t */ /** */\n\t/**\n\t * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n\t *\n\t * Given a function with N parameters, returns a new function that supports partial application.\n\t * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n\t * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n\t * accept more parameters until all N parameters have been supplied.\n\t *\n\t *\n\t * This contrived example uses a partially applied function as an predicate, which returns true\n\t * if an object is found in both arrays.\n\t * @example\n\t * ```\n\t * // returns true if an object is in both of the two arrays\n\t * function inBoth(array1, array2, object) {\n\t *   return array1.indexOf(object) !== -1 &&\n\t *          array2.indexOf(object) !== 1;\n\t * }\n\t * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n\t * let foos = [obj1, obj3]\n\t * let bars = [obj3, obj4, obj5]\n\t *\n\t * // A curried \"copy\" of inBoth\n\t * let curriedInBoth = curry(inBoth);\n\t * // Partially apply both the array1 and array2\n\t * let inFoosAndBars = curriedInBoth(foos, bars);\n\t *\n\t * // Supply the final argument; since all arguments are\n\t * // supplied, the original inBoth function is then called.\n\t * let obj1InBoth = inFoosAndBars(obj1); // false\n\t *\n\t * // Use the inFoosAndBars as a predicate.\n\t * // Filter, on each iteration, supplies the final argument\n\t * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n\t * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n\t *\n\t * ```\n\t *\n\t * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n\t *\n\t * @param fn\n\t * @returns {*|function(): (*|any)}\n\t */\n\tfunction curry(fn) {\n\t    var initial_args = [].slice.apply(arguments, [1]);\n\t    var func_args_length = fn.length;\n\t    function curried(args) {\n\t        if (args.length >= func_args_length)\n\t            return fn.apply(null, args);\n\t        return function () {\n\t            return curried(args.concat([].slice.apply(arguments)));\n\t        };\n\t    }\n\t    return curried(initial_args);\n\t}\n\t/**\n\t * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n\t * given: f(x), g(x), h(x)\n\t * let composed = compose(f,g,h)\n\t * then, composed is: f(g(h(x)))\n\t */\n\tfunction compose() {\n\t    var args = arguments;\n\t    var start = args.length - 1;\n\t    return function () {\n\t        var i = start, result = args[start].apply(this, arguments);\n\t        while (i--)\n\t            result = args[i].call(this, result);\n\t        return result;\n\t    };\n\t}\n\t/**\n\t * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n\t * given: f(x), g(x), h(x)\n\t * let piped = pipe(f,g,h);\n\t * then, piped is: h(g(f(x)))\n\t */\n\tfunction pipe() {\n\t    var funcs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        funcs[_i] = arguments[_i];\n\t    }\n\t    return compose.apply(null, [].slice.call(arguments).reverse());\n\t}\n\t/**\n\t * Given a property name, returns a function that returns that property from an object\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = prop(\"name\");\n\t * getName(obj) === \"blarg\"\n\t */\n\tvar prop = function (name) {\n\t    return function (obj) { return obj && obj[name]; };\n\t};\n\t/**\n\t * Given a property name and a value, returns a function that returns a boolean based on whether\n\t * the passed object has a property that matches the value\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = propEq(\"name\", \"blarg\");\n\t * getName(obj) === true\n\t */\n\tvar propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n\t/**\n\t * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n\t * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n\t * let getName = prop(\"nestedObj.name\");\n\t * getName(obj) === \"blarg\"\n\t * let propNotFound = prop(\"this.property.doesnt.exist\");\n\t * propNotFound(obj) === undefined\n\t */\n\tvar parse = function (name) {\n\t    return pipe.apply(null, name.split(\".\").map(prop));\n\t};\n\t/**\n\t * Given a function that returns a truthy or falsey value, returns a\n\t * function that returns the opposite (falsey or truthy) value given the same inputs\n\t */\n\tvar not = function (fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return !fn.apply(null, args);\n\t    };\n\t};\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if both functions return truthy for the given arguments\n\t */\n\tfunction and(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) && fn2.apply(null, args);\n\t    };\n\t}\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if at least one of the functions returns truthy for the given arguments\n\t */\n\tfunction or(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) || fn2.apply(null, args);\n\t    };\n\t}\n\t/**\n\t * Check if all the elements of an array match a predicate function\n\t *\n\t * @param fn1 a predicate function `fn1`\n\t * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n\t */\n\tvar all = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n\t};\n\tvar any = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n\t};\n\t/** Given a class, returns a Predicate function that returns true if the object is of that class */\n\tvar is = function (ctor) {\n\t    return function (obj) {\n\t        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n\t    };\n\t};\n\t/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\n\tvar eq = function (val) { return function (other) {\n\t    return val === other;\n\t}; };\n\t/** Given a value, returns a function which returns the value */\n\tvar val = function (v) { return function () { return v; }; };\n\tfunction invoke(fnName, args) {\n\t    return function (obj) {\n\t        return obj[fnName].apply(obj, args);\n\t    };\n\t}\n\t/**\n\t * Sorta like Pattern Matching (a functional programming conditional construct)\n\t *\n\t * See http://c2.com/cgi/wiki?PatternMatching\n\t *\n\t * This is a conditional construct which allows a series of predicates and output functions\n\t * to be checked and then applied.  Each predicate receives the input.  If the predicate\n\t * returns truthy, then its matching output function (mapping function) is provided with\n\t * the input and, then the result is returned.\n\t *\n\t * Each combination (2-tuple) of predicate + output function should be placed in an array\n\t * of size 2: [ predicate, mapFn ]\n\t *\n\t * These 2-tuples should be put in an outer array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * // Here's a 2-tuple where the first element is the isString predicate\n\t * // and the second element is a function that returns a description of the input\n\t * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\t *\n\t * // Second tuple: predicate \"isNumber\", mapfn returns a description\n\t * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\t *\n\t * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\t *\n\t * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\t *\n\t * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\t *\n\t * console.log(descriptionOf(undefined)); // 'notdefined'\n\t * console.log(descriptionOf(55)); // '(55) That's a number!'\n\t * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n\t * ```\n\t *\n\t * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n\t * with a Predicate and a mapping/output function\n\t * @returns {function(any): *}\n\t */\n\tfunction pattern(struct) {\n\t    return function (x) {\n\t        for (var i = 0; i < struct.length; i++) {\n\t            if (struct[i][0](x))\n\t                return struct[i][1](x);\n\t        }\n\t    };\n\t}\n\t\n\t/**\n\t * @coreapi\n\t * @module core\n\t */\n\t/**\n\t * Matches state names using glob-like pattern strings.\n\t *\n\t * Globs can be used in specific APIs including:\n\t *\n\t * - [[StateService.is]]\n\t * - [[StateService.includes]]\n\t * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n\t *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n\t *\n\t * A `Glob` string is a pattern which matches state names.\n\t * Nested state names are split into segments (separated by a dot) when processing.\n\t * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n\t *\n\t * Globs work according to the following rules:\n\t *\n\t * ### Exact match:\n\t *\n\t * The glob `'A.B'` matches the state named exactly `'A.B'`.\n\t *\n\t * | Glob        |Matches states named|Does not match state named|\n\t * |:------------|:--------------------|:---------------------|\n\t * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n\t * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n\t * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n\t *\n\t * ### Single star (`*`)\n\t *\n\t * A single star (`*`) is a wildcard that matches exactly one segment.\n\t *\n\t * | Glob        |Matches states named  |Does not match state named |\n\t * |:------------|:---------------------|:--------------------------|\n\t * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n\t * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n\t * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n\t *\n\t * ### Double star (`**`)\n\t *\n\t * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n\t *\n\t * | Glob        |Matches states named                           |Does not match state named         |\n\t * |:------------|:----------------------------------------------|:----------------------------------|\n\t * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n\t * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n\t * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n\t * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n\t *\n\t */\n\tvar Glob = (function () {\n\t    function Glob(text) {\n\t        this.text = text;\n\t        this.glob = text.split('.');\n\t        var regexpString = this.text.split('.')\n\t            .map(function (seg) {\n\t            if (seg === '**')\n\t                return '(?:|(?:\\\\.[^.]*)*)';\n\t            if (seg === '*')\n\t                return '\\\\.[^.]*';\n\t            return '\\\\.' + seg;\n\t        }).join('');\n\t        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n\t    }\n\t    Glob.prototype.matches = function (name) {\n\t        return this.regexp.test('.' + name);\n\t    };\n\t    /** Returns true if the string has glob-like characters in it */\n\t    Glob.is = function (text) {\n\t        return !!/[!,*]+/.exec(text);\n\t    };\n\t    /** Returns a glob from the string, or null if the string isn't Glob-like */\n\t    Glob.fromString = function (text) {\n\t        return Glob.is(text) ? new Glob(text) : null;\n\t    };\n\t    return Glob;\n\t}());\n\t\n\t/**\n\t * Internal representation of a UI-Router state.\n\t *\n\t * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n\t *\n\t * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.\n\t *\n\t * This class prototypally inherits from the corresponding [[StateDeclaration]].\n\t * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n\t */\n\tvar StateObject = (function () {\n\t    /** @deprecated use State.create() */\n\t    function StateObject(config) {\n\t        return StateObject.create(config || {});\n\t    }\n\t    /**\n\t     * Create a state object to put the private/internal implementation details onto.\n\t     * The object's prototype chain looks like:\n\t     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)\n\t     *\n\t     * @param stateDecl the user-supplied State Declaration\n\t     * @returns {StateObject} an internal State object\n\t     */\n\t    StateObject.create = function (stateDecl) {\n\t        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;\n\t        var state = inherit(inherit(stateDecl, StateObject.prototype));\n\t        stateDecl.$$state = function () { return state; };\n\t        state.self = stateDecl;\n\t        state.__stateObjectCache = {\n\t            nameGlob: Glob.fromString(state.name) // might return null\n\t        };\n\t        return state;\n\t    };\n\t    /**\n\t     * Returns true if the provided parameter is the same state.\n\t     *\n\t     * Compares the identity of the state against the passed value, which is either an object\n\t     * reference to the actual `State` instance, the original definition object passed to\n\t     * `$stateProvider.state()`, or the fully-qualified name.\n\t     *\n\t     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n\t     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n\t     * @returns Returns `true` if `ref` matches the current `State` instance.\n\t     */\n\t    StateObject.prototype.is = function (ref) {\n\t        return this === ref || this.self === ref || this.fqn() === ref;\n\t    };\n\t    /**\n\t     * @deprecated this does not properly handle dot notation\n\t     * @returns Returns a dot-separated name of the state.\n\t     */\n\t    StateObject.prototype.fqn = function () {\n\t        if (!this.parent || !(this.parent instanceof this.constructor))\n\t            return this.name;\n\t        var name = this.parent.fqn();\n\t        return name ? name + \".\" + this.name : this.name;\n\t    };\n\t    /**\n\t     * Returns the root node of this state's tree.\n\t     *\n\t     * @returns The root of this state's tree.\n\t     */\n\t    StateObject.prototype.root = function () {\n\t        return this.parent && this.parent.root() || this;\n\t    };\n\t    /**\n\t     * Gets the state's `Param` objects\n\t     *\n\t     * Gets the list of [[Param]] objects owned by the state.\n\t     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n\t     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n\t     *\n\t     * @param opts options\n\t     */\n\t    StateObject.prototype.parameters = function (opts) {\n\t        opts = defaults(opts, { inherit: true, matchingKeys: null });\n\t        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n\t        return inherited.concat(values(this.params))\n\t            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n\t    };\n\t    /**\n\t     * Returns a single [[Param]] that is owned by the state\n\t     *\n\t     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n\t     * @param id the name of the [[Param]] to return\n\t     * @param opts options\n\t     */\n\t    StateObject.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        return (this.url && this.url.parameter(id, opts) ||\n\t            find(values(this.params), propEq('id', id)) ||\n\t            opts.inherit && this.parent && this.parent.parameter(id));\n\t    };\n\t    StateObject.prototype.toString = function () {\n\t        return this.fqn();\n\t    };\n\t    /** Predicate which returns true if the object is an class with @State() decorator */\n\t    StateObject.isStateClass = function (stateDecl) {\n\t        return isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;\n\t    };\n\t    /** Predicate which returns true if the object is an internal [[StateObject]] object */\n\t    StateObject.isState = function (obj) {\n\t        return isObject(obj['__stateObjectCache']);\n\t    };\n\t    return StateObject;\n\t}());\n\t\n\t/** Predicates\n\t *\n\t * These predicates return true/false based on the input.\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_predicates\n\t */\n\t/** */\n\tvar toStr = Object.prototype.toString;\n\tvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\n\tvar isUndefined = tis('undefined');\n\tvar isDefined = not(isUndefined);\n\tvar isNull = function (o) { return o === null; };\n\tvar isNullOrUndefined = or(isNull, isUndefined);\n\tvar isFunction = tis('function');\n\tvar isNumber = tis('number');\n\tvar isString = tis('string');\n\tvar isObject = function (x) { return x !== null && typeof x === 'object'; };\n\tvar isArray = Array.isArray;\n\tvar isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\n\tvar isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n\tvar isState = StateObject.isState;\n\t/**\n\t * Predicate which checks if a value is injectable\n\t *\n\t * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n\t * where all the elements in the array are Strings, except the last one, which is a Function\n\t */\n\tfunction isInjectable(val$$1) {\n\t    if (isArray(val$$1) && val$$1.length) {\n\t        var head = val$$1.slice(0, -1), tail = val$$1.slice(-1);\n\t        return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);\n\t    }\n\t    return isFunction(val$$1);\n\t}\n\t/**\n\t * Predicate which checks if a value looks like a Promise\n\t *\n\t * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n\t */\n\tvar isPromise = and(isObject, pipe(prop('then'), isFunction));\n\t\n\tvar notImplemented = function (fnname) { return function () {\n\t    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n\t}; };\n\tvar services = {\n\t    $q: undefined,\n\t    $injector: undefined,\n\t};\n\t\n\t/**\n\t * Random utility functions used in the UI-Router code\n\t *\n\t * These functions are exported, but are subject to change without notice.\n\t *\n\t * @preferred\n\t * @module common\n\t */\n\t/** for typedoc */\n\tvar w = typeof window === 'undefined' ? {} : window;\n\tvar angular = w.angular || {};\n\tvar fromJson = angular.fromJson || JSON.parse.bind(JSON);\n\tvar toJson = angular.toJson || JSON.stringify.bind(JSON);\n\tvar copy = angular.copy || _copy;\n\tvar forEach = angular.forEach || _forEach;\n\tvar extend = Object.assign || _extend;\n\tvar equals = angular.equals || _equals;\n\tfunction identity(x) { return x; }\n\tfunction noop() { }\n\t/**\n\t * Builds proxy functions on the `to` object which pass through to the `from` object.\n\t *\n\t * For each key in `fnNames`, creates a proxy function on the `to` object.\n\t * The proxy function calls the real function on the `from` object.\n\t *\n\t *\n\t * #### Example:\n\t * This example creates an new class instance whose functions are prebound to the new'd object.\n\t * ```js\n\t * class Foo {\n\t *   constructor(data) {\n\t *     // Binds all functions from Foo.prototype to 'this',\n\t *     // then copies them to 'this'\n\t *     bindFunctions(Foo.prototype, this, this);\n\t *     this.data = data;\n\t *   }\n\t *\n\t *   log() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * let myFoo = new Foo([1,2,3]);\n\t * var logit = myFoo.log;\n\t * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n\t * ```\n\t *\n\t * #### Example:\n\t * This example creates a bound version of a service function, and copies it to another object\n\t * ```\n\t *\n\t * var SomeService = {\n\t *   this.data = [3, 4, 5];\n\t *   this.log = function() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * // Constructor fn\n\t * function OtherThing() {\n\t *   // Binds all functions from SomeService to SomeService,\n\t *   // then copies them to 'this'\n\t *   bindFunctions(SomeService, this, SomeService);\n\t * }\n\t *\n\t * let myOtherThing = new OtherThing();\n\t * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n\t * ```\n\t *\n\t * @param source A function that returns the source object which contains the original functions to be bound\n\t * @param target A function that returns the target object which will receive the bound functions\n\t * @param bind A function that returns the object which the functions will be bound to\n\t * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n\t * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n\t */\n\tfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n\t    if (latebind === void 0) { latebind = false; }\n\t    var bindFunction = function (fnName) {\n\t        return source()[fnName].bind(bind());\n\t    };\n\t    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n\t        target[fnName] = bindFunction(fnName);\n\t        return target[fnName].apply(null, arguments);\n\t    }; };\n\t    fnNames = fnNames || Object.keys(source());\n\t    return fnNames.reduce(function (acc, name) {\n\t        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n\t        return acc;\n\t    }, target);\n\t}\n\t/**\n\t * prototypal inheritance helper.\n\t * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n\t */\n\tvar inherit = function (parent, extra) {\n\t    return extend(Object.create(parent), extra);\n\t};\n\t/** Given an array, returns true if the object is found in the array, (using indexOf) */\n\tvar inArray = curry(_inArray);\n\tfunction _inArray(array, obj) {\n\t    return array.indexOf(obj) !== -1;\n\t}\n\t/**\n\t * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n\t * The same array is returned\n\t */\n\tvar removeFrom = curry(_removeFrom);\n\tfunction _removeFrom(array, obj) {\n\t    var idx = array.indexOf(obj);\n\t    if (idx >= 0)\n\t        array.splice(idx, 1);\n\t    return array;\n\t}\n\t/** pushes a values to an array and returns the value */\n\tvar pushTo = curry(_pushTo);\n\tfunction _pushTo(arr, val$$1) {\n\t    return (arr.push(val$$1), val$$1);\n\t}\n\t/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\n\tvar deregAll = function (functions) {\n\t    return functions.slice().forEach(function (fn) {\n\t        typeof fn === 'function' && fn();\n\t        removeFrom(functions, fn);\n\t    });\n\t};\n\t/**\n\t * Applies a set of defaults to an options object.  The options object is filtered\n\t * to only those properties of the objects in the defaultsList.\n\t * Earlier objects in the defaultsList take precedence when applying defaults.\n\t */\n\tfunction defaults(opts) {\n\t    var defaultsList = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        defaultsList[_i - 1] = arguments[_i];\n\t    }\n\t    var _defaultsList = defaultsList.concat({}).reverse();\n\t    var defaultVals = extend.apply(null, _defaultsList);\n\t    return extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n\t}\n\t/** Reduce function that merges each element of the list into a single object, using extend */\n\tvar mergeR = function (memo, item) { return extend(memo, item); };\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t    var path = [];\n\t    for (var n in first.path) {\n\t        if (first.path[n] !== second.path[n])\n\t            break;\n\t        path.push(first.path[n]);\n\t    }\n\t    return path;\n\t}\n\t/**\n\t * Return a copy of the object only containing the whitelisted properties.\n\t *\n\t * #### Example:\n\t * ```\n\t * var foo = { a: 1, b: 2, c: 3 };\n\t * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }\n\t * ```\n\t * @param obj the source object\n\t * @param propNames an Array of strings, which are the whitelisted property names\n\t */\n\tfunction pick(obj, propNames) {\n\t    var objCopy = {};\n\t    for (var prop_1 in obj) {\n\t        if (propNames.indexOf(prop_1) !== -1) {\n\t            objCopy[prop_1] = obj[prop_1];\n\t        }\n\t    }\n\t    return objCopy;\n\t}\n\t/**\n\t * Return a copy of the object omitting the blacklisted properties.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * var foo = { a: 1, b: 2, c: 3 };\n\t * var ab = omit(foo, ['a', 'b']); // { c: 3 }\n\t * ```\n\t * @param obj the source object\n\t * @param propNames an Array of strings, which are the blacklisted property names\n\t */\n\tfunction omit(obj, propNames) {\n\t    return Object.keys(obj)\n\t        .filter(not(inArray(propNames)))\n\t        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});\n\t}\n\t/**\n\t * Maps an array, or object to a property (by name)\n\t */\n\tfunction pluck(collection, propName) {\n\t    return map(collection, prop(propName));\n\t}\n\t/** Filters an Array or an Object's properties based on a predicate */\n\tfunction filter(collection, callback) {\n\t    var arr = isArray(collection), result = arr ? [] : {};\n\t    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n\t    forEach(collection, function (item, i) {\n\t        if (callback(item, i))\n\t            accept(item, i);\n\t    });\n\t    return result;\n\t}\n\t/** Finds an object from an array, or a property of an object, that matches a predicate */\n\tfunction find(collection, callback) {\n\t    var result;\n\t    forEach(collection, function (item, i) {\n\t        if (result)\n\t            return;\n\t        if (callback(item, i))\n\t            result = item;\n\t    });\n\t    return result;\n\t}\n\t/** Given an object, returns a new object, where each property is transformed by the callback function */\n\tvar mapObj = map;\n\t/** Maps an array or object properties using a callback function */\n\tfunction map(collection, callback) {\n\t    var result = isArray(collection) ? [] : {};\n\t    forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n\t    return result;\n\t}\n\t/**\n\t * Given an object, return its enumerable property values\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = { a: 1, b: 2, c: 3 }\n\t * let vals = values(foo); // [ 1, 2, 3 ]\n\t * ```\n\t */\n\tvar values = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return obj[key]; });\n\t};\n\t/**\n\t * Reduce function that returns true if all of the values are truthy.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let vals = [ 1, true, {}, \"hello world\"];\n\t * vals.reduce(allTrueR, true); // true\n\t *\n\t * vals.push(0);\n\t * vals.reduce(allTrueR, true); // false\n\t * ```\n\t */\n\tvar allTrueR = function (memo, elem) { return memo && elem; };\n\t/**\n\t * Reduce function that returns true if any of the values are truthy.\n\t *\n\t *  * @example\n\t * ```\n\t *\n\t * let vals = [ 0, null, undefined ];\n\t * vals.reduce(anyTrueR, true); // false\n\t *\n\t * vals.push(\"hello world\");\n\t * vals.reduce(anyTrueR, true); // true\n\t * ```\n\t */\n\tvar anyTrueR = function (memo, elem) { return memo || elem; };\n\t/**\n\t * Reduce function which un-nests a single level of arrays\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\tvar unnestR = function (memo, elem) { return memo.concat(elem); };\n\t/**\n\t * Reduce function which recursively un-nests all arrays\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\tvar flattenR = function (memo, elem) {\n\t    return isArray(elem) ? memo.concat(elem.reduce(flattenR, [])) : pushR(memo, elem);\n\t};\n\t/**\n\t * Reduce function that pushes an object to an array, then returns the array.\n\t * Mostly just for [[flattenR]] and [[uniqR]]\n\t */\n\tfunction pushR(arr, obj) {\n\t    arr.push(obj);\n\t    return arr;\n\t}\n\t/** Reduce function that filters out duplicates */\n\tvar uniqR = function (acc, token) {\n\t    return inArray(acc, token) ? acc : pushR(acc, token);\n\t};\n\t/**\n\t * Return a new array with a single level of arrays unnested.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\tvar unnest = function (arr) { return arr.reduce(unnestR, []); };\n\t/**\n\t * Return a completely flattened version of an array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\tvar flatten = function (arr) { return arr.reduce(flattenR, []); };\n\t/**\n\t * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n\t * @example\n\t * ```\n\t *\n\t * let isNumber = (obj) => typeof(obj) === 'number';\n\t * let allNumbers = [ 1, 2, 3, 4, 5 ];\n\t * allNumbers.filter(assertPredicate(isNumber)); //OK\n\t *\n\t * let oneString = [ 1, 2, 3, 4, \"5\" ];\n\t * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n\t * ```\n\t */\n\tvar assertPredicate = assertFn;\n\t/**\n\t * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n\t * @example\n\t * ```\n\t *\n\t * var data = { foo: 1, bar: 2 };\n\t *\n\t * let keys = [ 'foo', 'bar' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // values is [1, 2]\n\t *\n\t * let keys = [ 'foo', 'bar', 'baz' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // throws Error(\"Key not found\")\n\t * ```\n\t */\n\tvar assertMap = assertFn;\n\tfunction assertFn(predicateOrMap, errMsg) {\n\t    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n\t    return function (obj) {\n\t        var result = predicateOrMap(obj);\n\t        if (!result) {\n\t            throw new Error(isFunction(errMsg) ? errMsg(obj) : errMsg);\n\t        }\n\t        return result;\n\t    };\n\t}\n\t/**\n\t * Like _.pairs: Given an object, returns an array of key/value pairs\n\t *\n\t * @example\n\t * ```\n\t *\n\t * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n\t * ```\n\t */\n\tvar pairs = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n\t};\n\t/**\n\t * Given two or more parallel arrays, returns an array of tuples where\n\t * each tuple is composed of [ a[i], b[i], ... z[i] ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = [ 0, 2, 4, 6 ];\n\t * let bar = [ 1, 3, 5, 7 ];\n\t * let baz = [ 10, 30, 50, 70 ];\n\t * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n\t * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n\t * ```\n\t */\n\tfunction arrayTuples() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    if (args.length === 0)\n\t        return [];\n\t    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n\t    var i, result = [];\n\t    for (i = 0; i < maxArrayLen; i++) {\n\t        // This is a hot function\n\t        // Unroll when there are 1-4 arguments\n\t        switch (args.length) {\n\t            case 1:\n\t                result.push([args[0][i]]);\n\t                break;\n\t            case 2:\n\t                result.push([args[0][i], args[1][i]]);\n\t                break;\n\t            case 3:\n\t                result.push([args[0][i], args[1][i], args[2][i]]);\n\t                break;\n\t            case 4:\n\t                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n\t                break;\n\t            default:\n\t                result.push(args.map(function (array) { return array[i]; }));\n\t                break;\n\t        }\n\t    }\n\t    return result;\n\t}\n\t/**\n\t * Reduce function which builds an object from an array of [key, value] pairs.\n\t *\n\t * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n\t *\n\t * Each keyValueTuple should be an array with values [ key: string, value: any ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\t *\n\t * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t *\n\t * // Or, more simply:\n\t * var pairsToObj = pairs.reduce(applyPairs, {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t * ```\n\t */\n\tfunction applyPairs(memo, keyValTuple) {\n\t    var key, value;\n\t    if (isArray(keyValTuple))\n\t        key = keyValTuple[0], value = keyValTuple[1];\n\t    if (!isString(key))\n\t        throw new Error(\"invalid parameters to applyPairs\");\n\t    memo[key] = value;\n\t    return memo;\n\t}\n\t/** Get the last element of an array */\n\tfunction tail(arr) {\n\t    return arr.length && arr[arr.length - 1] || undefined;\n\t}\n\t/**\n\t * shallow copy from src to dest\n\t *\n\t * note: This is a shallow copy, while angular.copy is a deep copy.\n\t * ui-router uses `copy` only to make copies of state parameters.\n\t */\n\tfunction _copy(src, dest) {\n\t    if (dest)\n\t        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n\t    if (!dest)\n\t        dest = {};\n\t    return extend(dest, src);\n\t}\n\t/** Naive forEach implementation works with Objects or Arrays */\n\tfunction _forEach(obj, cb, _this) {\n\t    if (isArray(obj))\n\t        return obj.forEach(cb, _this);\n\t    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n\t}\n\tfunction _extend(toObj) {\n\t    for (var i = 1; i < arguments.length; i++) {\n\t        var obj = arguments[i];\n\t        if (!obj)\n\t            continue;\n\t        var keys = Object.keys(obj);\n\t        for (var j = 0; j < keys.length; j++) {\n\t            toObj[keys[j]] = obj[keys[j]];\n\t        }\n\t    }\n\t    return toObj;\n\t}\n\tfunction _equals(o1, o2) {\n\t    if (o1 === o2)\n\t        return true;\n\t    if (o1 === null || o2 === null)\n\t        return false;\n\t    if (o1 !== o1 && o2 !== o2)\n\t        return true; // NaN === NaN\n\t    var t1 = typeof o1, t2 = typeof o2;\n\t    if (t1 !== t2 || t1 !== 'object')\n\t        return false;\n\t    var tup = [o1, o2];\n\t    if (all(isArray)(tup))\n\t        return _arraysEq(o1, o2);\n\t    if (all(isDate)(tup))\n\t        return o1.getTime() === o2.getTime();\n\t    if (all(isRegExp)(tup))\n\t        return o1.toString() === o2.toString();\n\t    if (all(isFunction)(tup))\n\t        return true; // meh\n\t    var predicates = [isFunction, isArray, isDate, isRegExp];\n\t    if (predicates.map(any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n\t        return false;\n\t    var key, keys = {};\n\t    for (key in o1) {\n\t        if (!_equals(o1[key], o2[key]))\n\t            return false;\n\t        keys[key] = true;\n\t    }\n\t    for (key in o2) {\n\t        if (!keys[key])\n\t            return false;\n\t    }\n\t    return true;\n\t}\n\tfunction _arraysEq(a1, a2) {\n\t    if (a1.length !== a2.length)\n\t        return false;\n\t    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n\t}\n\t// issue #2676\n\tvar silenceUncaughtInPromise = function (promise) {\n\t    return promise.catch(function (e) { return 0; }) && promise;\n\t};\n\tvar silentRejection = function (error) {\n\t    return silenceUncaughtInPromise(services.$q.reject(error));\n\t};\n\t\n\t/**\n\t * @module common\n\t */ /** for typedoc */\n\tvar Queue = (function () {\n\t    function Queue(_items, _limit) {\n\t        if (_items === void 0) { _items = []; }\n\t        if (_limit === void 0) { _limit = null; }\n\t        this._items = _items;\n\t        this._limit = _limit;\n\t    }\n\t    Queue.prototype.enqueue = function (item) {\n\t        var items = this._items;\n\t        items.push(item);\n\t        if (this._limit && items.length > this._limit)\n\t            items.shift();\n\t        return item;\n\t    };\n\t    Queue.prototype.dequeue = function () {\n\t        if (this.size())\n\t            return this._items.splice(0, 1)[0];\n\t    };\n\t    Queue.prototype.clear = function () {\n\t        var current = this._items;\n\t        this._items = [];\n\t        return current;\n\t    };\n\t    Queue.prototype.size = function () {\n\t        return this._items.length;\n\t    };\n\t    Queue.prototype.remove = function (item) {\n\t        var idx = this._items.indexOf(item);\n\t        return idx > -1 && this._items.splice(idx, 1)[0];\n\t    };\n\t    Queue.prototype.peekTail = function () {\n\t        return this._items[this._items.length - 1];\n\t    };\n\t    Queue.prototype.peekHead = function () {\n\t        if (this.size())\n\t            return this._items[0];\n\t    };\n\t    return Queue;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\n\t(function (RejectType) {\n\t    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n\t    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n\t    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n\t    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n\t    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n\t})(exports.RejectType || (exports.RejectType = {}));\n\t/** @hidden */ var id = 0;\n\tvar Rejection = (function () {\n\t    function Rejection(type, message, detail) {\n\t        this.$id = id++;\n\t        this.type = type;\n\t        this.message = message;\n\t        this.detail = detail;\n\t    }\n\t    Rejection.prototype.toString = function () {\n\t        var detailString = function (d) {\n\t            return d && d.toString !== Object.prototype.toString ? d.toString() : stringify(d);\n\t        };\n\t        var detail = detailString(this.detail);\n\t        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;\n\t        return \"Transition Rejection($id: \" + $id + \" type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n\t    };\n\t    Rejection.prototype.toPromise = function () {\n\t        return extend(silentRejection(this), { _transitionRejection: this });\n\t    };\n\t    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n\t    Rejection.isRejectionPromise = function (obj) {\n\t        return obj && (typeof obj.then === 'function') && is(Rejection)(obj._transitionRejection);\n\t    };\n\t    /** Returns a Rejection due to transition superseded */\n\t    Rejection.superseded = function (detail, options) {\n\t        var message = \"The transition has been superseded by a different transition\";\n\t        var rejection = new Rejection(exports.RejectType.SUPERSEDED, message, detail);\n\t        if (options && options.redirected) {\n\t            rejection.redirected = true;\n\t        }\n\t        return rejection;\n\t    };\n\t    /** Returns a Rejection due to redirected transition */\n\t    Rejection.redirected = function (detail) {\n\t        return Rejection.superseded(detail, { redirected: true });\n\t    };\n\t    /** Returns a Rejection due to invalid transition */\n\t    Rejection.invalid = function (detail) {\n\t        var message = \"This transition is invalid\";\n\t        return new Rejection(exports.RejectType.INVALID, message, detail);\n\t    };\n\t    /** Returns a Rejection due to ignored transition */\n\t    Rejection.ignored = function (detail) {\n\t        var message = \"The transition was ignored\";\n\t        return new Rejection(exports.RejectType.IGNORED, message, detail);\n\t    };\n\t    /** Returns a Rejection due to aborted transition */\n\t    Rejection.aborted = function (detail) {\n\t        var message = \"The transition has been aborted\";\n\t        return new Rejection(exports.RejectType.ABORTED, message, detail);\n\t    };\n\t    /** Returns a Rejection due to aborted transition */\n\t    Rejection.errored = function (detail) {\n\t        var message = \"The transition errored\";\n\t        return new Rejection(exports.RejectType.ERROR, message, detail);\n\t    };\n\t    /**\n\t     * Returns a Rejection\n\t     *\n\t     * Normalizes a value as a Rejection.\n\t     * If the value is already a Rejection, returns it.\n\t     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n\t     *\n\t     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n\t     */\n\t    Rejection.normalize = function (detail) {\n\t        return is(Rejection)(detail) ? detail : Rejection.errored(detail);\n\t    };\n\t    return Rejection;\n\t}());\n\t\n\t/**\n\t * # Transition tracing (debug)\n\t *\n\t * Enable transition tracing to print transition information to the console,\n\t * in order to help debug your application.\n\t * Tracing logs detailed information about each Transition to your console.\n\t *\n\t * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n\t *\n\t * ### ES6\n\t * ```js\n\t * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n\t * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n\t * ```\n\t *\n\t * ### CJS\n\t * ```js\n\t * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n\t * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n\t * ```\n\t *\n\t * ### Globals\n\t * ```js\n\t * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n\t * trace.enable(); // Trace everything (very verbose)\n\t * ```\n\t *\n\t * ### Angular 1:\n\t * ```js\n\t * app.run($trace => $trace.enable());\n\t * ```\n\t *\n\t * @coreapi\n\t * @module trace\n\t */ /** for typedoc */\n\t/** @hidden */\n\tfunction uiViewString(uiview) {\n\t    if (!uiview)\n\t        return 'ui-view (defunct)';\n\t    var state = uiview.creationContext ? uiview.creationContext.name || '(root)' : '(none)';\n\t    return \"[ui-view#\" + uiview.id + \" \" + uiview.$type + \":\" + uiview.fqn + \" (\" + uiview.name + \"@\" + state + \")]\";\n\t}\n\t/** @hidden */\n\tvar viewConfigString = function (viewConfig) {\n\t    var view = viewConfig.viewDecl;\n\t    var state = view.$context.name || '(root)';\n\t    return \"[View#\" + viewConfig.$id + \" from '\" + state + \"' state]: target ui-view: '\" + view.$uiViewName + \"@\" + view.$uiViewContextAnchor + \"'\";\n\t};\n\t/** @hidden */\n\tfunction normalizedCat(input) {\n\t    return isNumber(input) ? exports.Category[input] : exports.Category[exports.Category[input]];\n\t}\n\t/**\n\t * Trace categories Enum\n\t *\n\t * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n\t *\n\t * `trace.enable(Category.TRANSITION)`\n\t *\n\t * These can also be provided using a matching string, or position ordinal\n\t *\n\t * `trace.enable(\"TRANSITION\")`\n\t *\n\t * `trace.enable(1)`\n\t */\n\t\n\t(function (Category) {\n\t    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n\t    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n\t    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n\t    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n\t    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n\t})(exports.Category || (exports.Category = {}));\n\t/** @hidden */ var _tid = parse(\"$id\");\n\t/** @hidden */ var _rid = parse(\"router.$id\");\n\t/** @hidden */ var transLbl = function (trans) { return \"Transition #\" + _tid(trans) + \"-\" + _rid(trans); };\n\t/**\n\t * Prints UI-Router Transition trace information to the console.\n\t */\n\tvar Trace = (function () {\n\t    /** @hidden */\n\t    function Trace() {\n\t        /** @hidden */\n\t        this._enabled = {};\n\t        this.approximateDigests = 0;\n\t    }\n\t    /** @hidden */\n\t    Trace.prototype._set = function (enabled, categories) {\n\t        var _this = this;\n\t        if (!categories.length) {\n\t            categories = Object.keys(exports.Category)\n\t                .map(function (k) { return parseInt(k, 10); })\n\t                .filter(function (k) { return !isNaN(k); })\n\t                .map(function (key) { return exports.Category[key]; });\n\t        }\n\t        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n\t    };\n\t    Trace.prototype.enable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(true, categories);\n\t    };\n\t    Trace.prototype.disable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(false, categories);\n\t    };\n\t    /**\n\t     * Retrieves the enabled stateus of a [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enabled(\"VIEWCONFIG\"); // true or false\n\t     * ```\n\t     *\n\t     * @returns boolean true if the category is enabled\n\t     */\n\t    Trace.prototype.enabled = function (category) {\n\t        return !!this._enabled[normalizedCat(category)];\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionStart = function (trans) {\n\t        if (!this.enabled(exports.Category.TRANSITION))\n\t            return;\n\t        console.log(transLbl(trans) + \": Started  -> \" + stringify(trans));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionIgnored = function (trans) {\n\t        if (!this.enabled(exports.Category.TRANSITION))\n\t            return;\n\t        console.log(transLbl(trans) + \": Ignored  <> \" + stringify(trans));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n\t        if (!this.enabled(exports.Category.HOOK))\n\t            return;\n\t        var event = parse(\"traceData.hookType\")(options) || \"internal\", context = parse(\"traceData.context.state.name\")(options) || parse(\"traceData.context\")(options) || \"unknown\", name = functionToString(step.registeredHook.callback);\n\t        console.log(transLbl(trans) + \":   Hook -> \" + event + \" context: \" + context + \", \" + maxLength(200, name));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n\t        if (!this.enabled(exports.Category.HOOK))\n\t            return;\n\t        console.log(transLbl(trans) + \":   <- Hook returned: \" + maxLength(200, stringify(hookResult)));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvePath = function (path, when, trans) {\n\t        if (!this.enabled(exports.Category.RESOLVE))\n\t            return;\n\t        console.log(transLbl(trans) + \":         Resolving \" + path + \" (\" + when + \")\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n\t        if (!this.enabled(exports.Category.RESOLVE))\n\t            return;\n\t        console.log(transLbl(trans) + \":               <- Resolved  \" + resolvable + \" to: \" + maxLength(200, stringify(resolvable.data)));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceError = function (reason, trans) {\n\t        if (!this.enabled(exports.Category.TRANSITION))\n\t            return;\n\t        console.log(transLbl(trans) + \": <- Rejected \" + stringify(trans) + \", reason: \" + reason);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceSuccess = function (finalState, trans) {\n\t        if (!this.enabled(exports.Category.TRANSITION))\n\t            return;\n\t        console.log(transLbl(trans) + \": <- Success  \" + stringify(trans) + \", final state: \" + finalState.name);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n\t        if (extra === void 0) { extra = \"\"; }\n\t        if (!this.enabled(exports.Category.UIVIEW))\n\t            return;\n\t        console.log(\"ui-view: \" + padString(30, event) + \" \" + uiViewString(viewData) + extra);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n\t        if (!this.enabled(exports.Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewFill = function (viewData, html) {\n\t        if (!this.enabled(exports.Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + maxLength(200, html));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewSync = function (pairs) {\n\t        if (!this.enabled(exports.Category.VIEWCONFIG))\n\t            return;\n\t        var mapping = pairs.map(function (_a) {\n\t            var uiViewData = _a[0], config = _a[1];\n\t            var uiView = uiViewData.$type + \":\" + uiViewData.fqn;\n\t            var view = config && config.viewDecl.$context.name + \": \" + config.viewDecl.$name + \" (\" + config.viewDecl.$type + \")\";\n\t            return { 'ui-view fqn': uiView, 'state: view name': view };\n\t        }).sort(function (a, b) { return a['ui-view fqn'].localeCompare(b['ui-view fqn']); });\n\t        console.table(mapping);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n\t        if (!this.enabled(exports.Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n\t        if (!this.enabled(exports.Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n\t    };\n\t    return Trace;\n\t}());\n\t/**\n\t * The [[Trace]] singleton\n\t *\n\t * #### Example:\n\t * ```js\n\t * import {trace} from \"angular-ui-router\";\n\t * trace.enable(1, 5);\n\t * ```\n\t */\n\tvar trace = new Trace();\n\t\n\t(function (TransitionHookPhase) {\n\t    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"RUN\"] = 2] = \"RUN\";\n\t    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n\t})(exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\n\t\n\t(function (TransitionHookScope) {\n\t    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n\t    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n\t})(exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n\t\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t/**\n\t * Encapsulate the target (destination) state/params/options of a [[Transition]].\n\t *\n\t * This class is frequently used to redirect a transition to a new destination.\n\t *\n\t * See:\n\t *\n\t * - [[HookResult]]\n\t * - [[TransitionHookFn]]\n\t * - [[TransitionService.onStart]]\n\t *\n\t * To create a `TargetState`, use [[StateService.target]].\n\t *\n\t * ---\n\t *\n\t * This class wraps:\n\t *\n\t * 1) an identifier for a state\n\t * 2) a set of parameters\n\t * 3) and transition options\n\t * 4) the registered state object (the [[StateDeclaration]])\n\t *\n\t * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n\t * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n\t * The `TargetState` class normalizes those options.\n\t *\n\t * A `TargetState` may be valid (the state being targeted exists in the registry)\n\t * or invalid (the state being targeted is not registered).\n\t */\n\tvar TargetState = (function () {\n\t    /**\n\t     * The TargetState constructor\n\t     *\n\t     * Note: Do not construct a `TargetState` manually.\n\t     * To create a `TargetState`, use the [[StateService.target]] factory method.\n\t     *\n\t     * @param _identifier An identifier for a state.\n\t     *    Either a fully-qualified state name, or the object used to define the state.\n\t     * @param _definition The internal state representation, if exists.\n\t     * @param _params Parameters for the target state\n\t     * @param _options Transition options.\n\t     *\n\t     * @internalapi\n\t     */\n\t    function TargetState(_identifier, _definition, _params, _options) {\n\t        if (_options === void 0) { _options = {}; }\n\t        this._identifier = _identifier;\n\t        this._definition = _definition;\n\t        this._options = _options;\n\t        this._params = _params || {};\n\t    }\n\t    /** The name of the state this object targets */\n\t    TargetState.prototype.name = function () {\n\t        return this._definition && this._definition.name || this._identifier;\n\t    };\n\t    /** The identifier used when creating this TargetState */\n\t    TargetState.prototype.identifier = function () {\n\t        return this._identifier;\n\t    };\n\t    /** The target parameter values */\n\t    TargetState.prototype.params = function () {\n\t        return this._params;\n\t    };\n\t    /** The internal state object (if it was found) */\n\t    TargetState.prototype.$state = function () {\n\t        return this._definition;\n\t    };\n\t    /** The internal state declaration (if it was found) */\n\t    TargetState.prototype.state = function () {\n\t        return this._definition && this._definition.self;\n\t    };\n\t    /** The target options */\n\t    TargetState.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /** True if the target state was found */\n\t    TargetState.prototype.exists = function () {\n\t        return !!(this._definition && this._definition.self);\n\t    };\n\t    /** True if the object is valid */\n\t    TargetState.prototype.valid = function () {\n\t        return !this.error();\n\t    };\n\t    /** If the object is invalid, returns the reason why */\n\t    TargetState.prototype.error = function () {\n\t        var base = this.options().relative;\n\t        if (!this._definition && !!base) {\n\t            var stateName = base.name ? base.name : base;\n\t            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n\t        }\n\t        if (!this._definition)\n\t            return \"No such state '\" + this.name() + \"'\";\n\t        if (!this._definition.self)\n\t            return \"State '\" + this.name() + \"' has an invalid definition\";\n\t    };\n\t    TargetState.prototype.toString = function () {\n\t        return \"'\" + this.name() + \"'\" + toJson(this.params());\n\t    };\n\t    /** Returns true if the object has a state property that might be a state or state name */\n\t    TargetState.isDef = function (obj) {\n\t        return obj && obj.state && (isString(obj.state) || isString(obj.state.name));\n\t    };\n\t    return TargetState;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */\n\t/** for typedoc */\n\tvar defaultOptions = {\n\t    current: noop,\n\t    transition: null,\n\t    traceData: {},\n\t    bind: null,\n\t};\n\t/** @hidden */\n\tvar TransitionHook = (function () {\n\t    function TransitionHook(transition, stateContext, registeredHook, options) {\n\t        var _this = this;\n\t        this.transition = transition;\n\t        this.stateContext = stateContext;\n\t        this.registeredHook = registeredHook;\n\t        this.options = options;\n\t        this.isSuperseded = function () {\n\t            return _this.type.hookPhase === exports.TransitionHookPhase.RUN && !_this.options.transition.isActive();\n\t        };\n\t        this.options = defaults(options, defaultOptions);\n\t        this.type = registeredHook.eventType;\n\t    }\n\t    TransitionHook.prototype.logError = function (err) {\n\t        this.transition.router.stateService.defaultErrorHandler()(err);\n\t    };\n\t    TransitionHook.prototype.invokeHook = function () {\n\t        var _this = this;\n\t        var hook = this.registeredHook;\n\t        if (hook._deregistered)\n\t            return;\n\t        var notCurrent = this.getNotCurrentRejection();\n\t        if (notCurrent)\n\t            return notCurrent;\n\t        var options = this.options;\n\t        trace.traceHookInvocation(this, this.transition, options);\n\t        var invokeCallback = function () {\n\t            return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n\t        };\n\t        var normalizeErr = function (err) {\n\t            return Rejection.normalize(err).toPromise();\n\t        };\n\t        var handleError = function (err) {\n\t            return hook.eventType.getErrorHandler(_this)(err);\n\t        };\n\t        var handleResult = function (result) {\n\t            return hook.eventType.getResultHandler(_this)(result);\n\t        };\n\t        try {\n\t            var result = invokeCallback();\n\t            if (!this.type.synchronous && isPromise(result)) {\n\t                return result.catch(normalizeErr)\n\t                    .then(handleResult, handleError);\n\t            }\n\t            else {\n\t                return handleResult(result);\n\t            }\n\t        }\n\t        catch (err) {\n\t            // If callback throws (synchronously)\n\t            return handleError(Rejection.normalize(err));\n\t        }\n\t    };\n\t    /**\n\t     * This method handles the return value of a Transition Hook.\n\t     *\n\t     * A hook can return false (cancel), a TargetState (redirect),\n\t     * or a promise (which may later resolve to false or a redirect)\n\t     *\n\t     * This also handles \"transition superseded\" -- when a new transition\n\t     * was started while the hook was still running\n\t     */\n\t    TransitionHook.prototype.handleHookResult = function (result) {\n\t        var _this = this;\n\t        var notCurrent = this.getNotCurrentRejection();\n\t        if (notCurrent)\n\t            return notCurrent;\n\t        // Hook returned a promise\n\t        if (isPromise(result)) {\n\t            // Wait for the promise, then reprocess with the resulting value\n\t            return result.then(function (val$$1) { return _this.handleHookResult(val$$1); });\n\t        }\n\t        trace.traceHookResult(result, this.transition, this.options);\n\t        // Hook returned false\n\t        if (result === false) {\n\t            // Abort this Transition\n\t            return Rejection.aborted(\"Hook aborted transition\").toPromise();\n\t        }\n\t        var isTargetState = is(TargetState);\n\t        // hook returned a TargetState\n\t        if (isTargetState(result)) {\n\t            // Halt the current Transition and redirect (a new Transition) to the TargetState.\n\t            return Rejection.redirected(result).toPromise();\n\t        }\n\t    };\n\t    /**\n\t     * Return a Rejection promise if the transition is no longer current due\n\t     * to a stopped router (disposed), or a new transition has started and superseded this one.\n\t     */\n\t    TransitionHook.prototype.getNotCurrentRejection = function () {\n\t        var router = this.transition.router;\n\t        // The router is stopped\n\t        if (router._disposed) {\n\t            return Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n\t        }\n\t        if (this.transition._aborted) {\n\t            return Rejection.aborted().toPromise();\n\t        }\n\t        // This transition is no longer current.\n\t        // Another transition started while this hook was still running.\n\t        if (this.isSuperseded()) {\n\t            // Abort this transition\n\t            return Rejection.superseded(this.options.current()).toPromise();\n\t        }\n\t    };\n\t    TransitionHook.prototype.toString = function () {\n\t        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n\t        var event = parse(\"traceData.hookType\")(options) || \"internal\", context = parse(\"traceData.context.state.name\")(options) || parse(\"traceData.context\")(options) || \"unknown\", name = fnToString(registeredHook.callback);\n\t        return event + \" context: \" + context + \", \" + maxLength(200, name);\n\t    };\n\t    /**\n\t     * Chains together an array of TransitionHooks.\n\t     *\n\t     * Given a list of [[TransitionHook]] objects, chains them together.\n\t     * Each hook is invoked after the previous one completes.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var hooks: TransitionHook[] = getHooks();\n\t     * let promise: Promise<any> = TransitionHook.chain(hooks);\n\t     *\n\t     * promise.then(handleSuccess, handleError);\n\t     * ```\n\t     *\n\t     * @param hooks the list of hooks to chain together\n\t     * @param waitFor if provided, the chain is `.then()`'ed off this promise\n\t     * @returns a `Promise` for sequentially invoking the hooks (in order)\n\t     */\n\t    TransitionHook.chain = function (hooks, waitFor) {\n\t        // Chain the next hook off the previous\n\t        var createHookChainR = function (prev, nextHook) {\n\t            return prev.then(function () { return nextHook.invokeHook(); });\n\t        };\n\t        return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n\t    };\n\t    /**\n\t     * Invokes all the provided TransitionHooks, in order.\n\t     * Each hook's return value is checked.\n\t     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n\t     * If no hook returns a promise, then all hooks are processed synchronously.\n\t     *\n\t     * @param hooks the list of TransitionHooks to invoke\n\t     * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n\t     *\n\t     * @returns a promise for the async result, or the result of the callback\n\t     */\n\t    TransitionHook.invokeHooks = function (hooks, doneCallback) {\n\t        for (var idx = 0; idx < hooks.length; idx++) {\n\t            var hookResult = hooks[idx].invokeHook();\n\t            if (isPromise(hookResult)) {\n\t                var remainingHooks = hooks.slice(idx + 1);\n\t                return TransitionHook.chain(remainingHooks, hookResult)\n\t                    .then(doneCallback);\n\t            }\n\t        }\n\t        return doneCallback();\n\t    };\n\t    /**\n\t     * Run all TransitionHooks, ignoring their return value.\n\t     */\n\t    TransitionHook.runAllHooks = function (hooks) {\n\t        hooks.forEach(function (hook) { return hook.invokeHook(); });\n\t    };\n\t    /**\n\t     * These GetResultHandler(s) are used by [[invokeHook]] below\n\t     * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n\t     */\n\t    TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {\n\t        return hook.handleHookResult(result);\n\t    }; };\n\t    /**\n\t     * If the result is a promise rejection, log it.\n\t     * Otherwise, ignore the result.\n\t     */\n\t    TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {\n\t        isPromise(result) && result.catch(function (err) {\n\t            return hook.logError(Rejection.normalize(err));\n\t        });\n\t        return undefined;\n\t    }; };\n\t    /**\n\t     * These GetErrorHandler(s) are used by [[invokeHook]] below\n\t     * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n\t     */\n\t    TransitionHook.LOG_ERROR = function (hook) { return function (error) {\n\t        return hook.logError(error);\n\t    }; };\n\t    TransitionHook.REJECT_ERROR = function (hook) { return function (error) {\n\t        return silentRejection(error);\n\t    }; };\n\t    TransitionHook.THROW_ERROR = function (hook) { return function (error) {\n\t        throw error;\n\t    }; };\n\t    return TransitionHook;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t/**\n\t * Determines if the given state matches the matchCriteria\n\t *\n\t * @hidden\n\t *\n\t * @param state a State Object to test against\n\t * @param criterion\n\t * - If a string, matchState uses the string as a glob-matcher against the state name\n\t * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n\t *   and returns a positive match if any of the globs match.\n\t * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n\t * @returns {boolean}\n\t */\n\tfunction matchState(state, criterion) {\n\t    var toMatch = isString(criterion) ? [criterion] : criterion;\n\t    function matchGlobs(_state) {\n\t        var globStrings = toMatch;\n\t        for (var i = 0; i < globStrings.length; i++) {\n\t            var glob = new Glob(globStrings[i]);\n\t            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    var matchFn = (isFunction(toMatch) ? toMatch : matchGlobs);\n\t    return !!matchFn(state);\n\t}\n\t/**\n\t * @internalapi\n\t * The registration data for a registered transition hook\n\t */\n\tvar RegisteredHook = (function () {\n\t    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n\t        if (options === void 0) { options = {}; }\n\t        this.tranSvc = tranSvc;\n\t        this.eventType = eventType;\n\t        this.callback = callback;\n\t        this.matchCriteria = matchCriteria;\n\t        this.priority = options.priority || 0;\n\t        this.bind = options.bind || null;\n\t        this._deregistered = false;\n\t    }\n\t    /**\n\t     * Gets the matching [[PathNode]]s\n\t     *\n\t     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n\t     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n\t     *\n\t     * Returning `null` is significant to distinguish between the default\n\t     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n\t     * when the nodes is an empty array.\n\t     *\n\t     * This is useful to allow a transition match criteria of `entering: true`\n\t     * to still match a transition, even when `entering === []`.  Contrast that\n\t     * with `entering: (state) => true` which only matches when a state is actually\n\t     * being entered.\n\t     */\n\t    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n\t        if (criterion === true)\n\t            return nodes;\n\t        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n\t        return matching.length ? matching : null;\n\t    };\n\t    /**\n\t     * Gets the default match criteria (all `true`)\n\t     *\n\t     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n\t     *\n\t     * ```js\n\t     * {\n\t     *   to: true,\n\t     *   from: true,\n\t     *   entering: true,\n\t     *   exiting: true,\n\t     *   retained: true,\n\t     * }\n\t     */\n\t    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n\t        return map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n\t    };\n\t    /**\n\t     * Gets matching nodes as [[IMatchingNodes]]\n\t     *\n\t     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n\t     *\n\t     * ```js\n\t     * let matches: IMatchingNodes = {\n\t     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n\t     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n\t     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n\t     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n\t     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n\t     * };\n\t     * ```\n\t     */\n\t    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n\t        var _this = this;\n\t        var criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n\t        var paths = values(this.tranSvc._pluginapi._getPathTypes());\n\t        return paths.reduce(function (mn, pathtype) {\n\t            // STATE scope criteria matches against every node in the path.\n\t            // TRANSITION scope criteria matches against only the last node in the path\n\t            var isStateHook = pathtype.scope === exports.TransitionHookScope.STATE;\n\t            var path = treeChanges[pathtype.name] || [];\n\t            var nodes = isStateHook ? path : [tail(path)];\n\t            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n\t            return mn;\n\t        }, {});\n\t    };\n\t    /**\n\t     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n\t     *\n\t     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n\t     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n\t     */\n\t    RegisteredHook.prototype.matches = function (treeChanges) {\n\t        var matches = this._getMatchingNodes(treeChanges);\n\t        // Check if all the criteria matched the TreeChanges object\n\t        var allMatched = values(matches).every(identity);\n\t        return allMatched ? matches : null;\n\t    };\n\t    return RegisteredHook;\n\t}());\n\t/** @hidden Return a registration function of the requested type. */\n\tfunction makeEvent(registry, transitionService, eventType) {\n\t    // Create the object which holds the registered transition hooks.\n\t    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n\t    var hooks = _registeredHooks[eventType.name] = [];\n\t    // Create hook registration function on the IHookRegistry for the event\n\t    registry[eventType.name] = hookRegistrationFn;\n\t    function hookRegistrationFn(matchObject, callback, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n\t        hooks.push(registeredHook);\n\t        return function deregisterEventHook() {\n\t            registeredHook._deregistered = true;\n\t            removeFrom(hooks)(registeredHook);\n\t        };\n\t    }\n\t    return hookRegistrationFn;\n\t}\n\t\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t/**\n\t * This class returns applicable TransitionHooks for a specific Transition instance.\n\t *\n\t * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n\t * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n\t * determined by the type of hook)\n\t *\n\t * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n\t *\n\t * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n\t * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n\t * in the Transition class, so we must also provide the Transition's _treeChanges)\n\t *\n\t */\n\tvar HookBuilder = (function () {\n\t    function HookBuilder(transition) {\n\t        this.transition = transition;\n\t    }\n\t    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n\t        var _this = this;\n\t        var $transitions = this.transition.router.transitionService;\n\t        return $transitions._pluginapi._getEvents(phase)\n\t            .map(function (type) { return _this.buildHooks(type); })\n\t            .reduce(unnestR, [])\n\t            .filter(identity);\n\t    };\n\t    /**\n\t     * Returns an array of newly built TransitionHook objects.\n\t     *\n\t     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n\t     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n\t     * - For each of the [[PathNode]]s, creates a TransitionHook\n\t     *\n\t     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n\t     */\n\t    HookBuilder.prototype.buildHooks = function (hookType) {\n\t        var transition = this.transition;\n\t        var treeChanges = transition.treeChanges();\n\t        // Find all the matching registered hooks for a given hook type\n\t        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n\t        if (!matchingHooks)\n\t            return [];\n\t        var baseHookOptions = {\n\t            transition: transition,\n\t            current: transition.options().current\n\t        };\n\t        var makeTransitionHooks = function (hook) {\n\t            // Fetch the Nodes that caused this hook to match.\n\t            var matches = hook.matches(treeChanges);\n\t            // Select the PathNode[] that will be used as TransitionHook context objects\n\t            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n\t            // Return an array of HookTuples\n\t            return matchingNodes.map(function (node) {\n\t                var _options = extend({\n\t                    bind: hook.bind,\n\t                    traceData: { hookType: hookType.name, context: node }\n\t                }, baseHookOptions);\n\t                var state = hookType.criteriaMatchPath.scope === exports.TransitionHookScope.STATE ? node.state.self : null;\n\t                var transitionHook = new TransitionHook(transition, state, hook, _options);\n\t                return { hook: hook, node: node, transitionHook: transitionHook };\n\t            });\n\t        };\n\t        return matchingHooks.map(makeTransitionHooks)\n\t            .reduce(unnestR, [])\n\t            .sort(tupleSort(hookType.reverseSort))\n\t            .map(function (tuple) { return tuple.transitionHook; });\n\t    };\n\t    /**\n\t     * Finds all RegisteredHooks from:\n\t     * - The Transition object instance hook registry\n\t     * - The TransitionService ($transitions) global hook registry\n\t     *\n\t     * which matched:\n\t     * - the eventType\n\t     * - the matchCriteria (to, from, exiting, retained, entering)\n\t     *\n\t     * @returns an array of matched [[RegisteredHook]]s\n\t     */\n\t    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n\t        var isCreate = hookType.hookPhase === exports.TransitionHookPhase.CREATE;\n\t        // Instance and Global hook registries\n\t        var $transitions = this.transition.router.transitionService;\n\t        var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n\t        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n\t            .filter(assertPredicate(isArray, \"broken event named: \" + hookType.name)) // Sanity check\n\t            .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n\t            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n\t    };\n\t    return HookBuilder;\n\t}());\n\t/**\n\t * A factory for a sort function for HookTuples.\n\t *\n\t * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n\t * the EventHook priority.\n\t *\n\t * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n\t * @returns a tuple sort function\n\t */\n\tfunction tupleSort(reverseDepthSort) {\n\t    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n\t    return function nodeDepthThenPriority(l, r) {\n\t        var factor = reverseDepthSort ? -1 : 1;\n\t        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n\t        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n\t    };\n\t}\n\t\n\t/**\n\t * @coreapi\n\t * @module params\n\t */\n\t/** */\n\t/**\n\t * An internal class which implements [[ParamTypeDefinition]].\n\t *\n\t * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n\t * When a param type definition is registered, an instance of this class is created internally.\n\t *\n\t * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n\t *\n\t * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n\t *\n\t * #### Example:\n\t * ```js\n\t * var paramTypeDef = {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t *\n\t * var paramType = new ParamType(paramTypeDef);\n\t * ```\n\t * @internalapi\n\t */\n\tvar ParamType = (function () {\n\t    /**\n\t     * @param def  A configuration object which contains the custom type definition.  The object's\n\t     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n\t     * @returns a new ParamType object\n\t     */\n\t    function ParamType(def) {\n\t        /** @inheritdoc */\n\t        this.pattern = /.*/;\n\t        /** @inheritdoc */\n\t        this.inherit = true;\n\t        extend(this, def);\n\t    }\n\t    // consider these four methods to be \"abstract methods\" that should be overridden\n\t    /** @inheritdoc */\n\t    ParamType.prototype.is = function (val, key) { return true; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.encode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.decode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.equals = function (a, b) { return a == b; };\n\t    ParamType.prototype.$subPattern = function () {\n\t        var sub = this.pattern.toString();\n\t        return sub.substr(1, sub.length - 2);\n\t    };\n\t    ParamType.prototype.toString = function () {\n\t        return \"{ParamType:\" + this.name + \"}\";\n\t    };\n\t    /** Given an encoded string, or a decoded object, returns a decoded object */\n\t    ParamType.prototype.$normalize = function (val) {\n\t        return this.is(val) ? val : this.decode(val);\n\t    };\n\t    /**\n\t     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n\t     * e.g.:\n\t     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t     * - url: \"/path?queryParam=1&queryParam=2\n\t     * - $stateParams.queryParam will be [1, 2]\n\t     * if `mode` is \"auto\", then\n\t     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t     */\n\t    ParamType.prototype.$asArray = function (mode, isSearch) {\n\t        if (!mode)\n\t            return this;\n\t        if (mode === \"auto\" && !isSearch)\n\t            throw new Error(\"'auto' array mode is for query parameters only\");\n\t        return new ArrayType(this, mode);\n\t    };\n\t    return ParamType;\n\t}());\n\t/**\n\t * Wraps up a `ParamType` object to handle array values.\n\t * @internalapi\n\t */\n\tfunction ArrayType(type, mode) {\n\t    var _this = this;\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) {\n\t        return isArray(val) ? val : (isDefined(val) ? [val] : []);\n\t    }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t        switch (val.length) {\n\t            case 0: return undefined;\n\t            case 1: return mode === \"auto\" ? val[0] : val;\n\t            default: return val;\n\t        }\n\t    }\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t        return function handleArray(val) {\n\t            if (isArray(val) && val.length === 0)\n\t                return val;\n\t            var arr = arrayWrap(val);\n\t            var result = map(arr, callback);\n\t            return (allTruthyMode === true) ? filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n\t        };\n\t    }\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t        return function handleArray(val1, val2) {\n\t            var left = arrayWrap(val1), right = arrayWrap(val2);\n\t            if (left.length !== right.length)\n\t                return false;\n\t            for (var i = 0; i < left.length; i++) {\n\t                if (!callback(left[i], right[i]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        };\n\t    }\n\t    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n\t        var paramTypeFn = type[name].bind(type);\n\t        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n\t        _this[name] = wrapperFn(paramTypeFn);\n\t    });\n\t    extend(this, {\n\t        dynamic: type.dynamic,\n\t        name: type.name,\n\t        pattern: type.pattern,\n\t        inherit: type.inherit,\n\t        is: arrayHandler(type.is.bind(type), true),\n\t        $arrayMode: mode\n\t    });\n\t}\n\t\n\t/**\n\t * @coreapi\n\t * @module params\n\t */ /** for typedoc */\n\t/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;\n\t/** @hidden */ var isShorthand = function (cfg) {\n\t    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n\t};\n\t/** @internalapi */\n\t\n\t(function (DefType) {\n\t    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n\t    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n\t    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n\t})(exports.DefType || (exports.DefType = {}));\n\t/** @hidden */\n\tfunction unwrapShorthand(cfg) {\n\t    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n\t    getStaticDefaultValue['__cacheable'] = true;\n\t    function getStaticDefaultValue() {\n\t        return cfg.value;\n\t    }\n\t    return extend(cfg, {\n\t        $$fn: isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n\t    });\n\t}\n\t/** @hidden */\n\tfunction getType(cfg, urlType, location, id, paramTypes) {\n\t    if (cfg.type && urlType && urlType.name !== 'string')\n\t        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n\t    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n\t        return paramTypes.type(cfg.type);\n\t    if (urlType)\n\t        return urlType;\n\t    if (!cfg.type) {\n\t        var type = location === exports.DefType.CONFIG ? \"any\" :\n\t            location === exports.DefType.PATH ? \"path\" :\n\t                location === exports.DefType.SEARCH ? \"query\" : \"string\";\n\t        return paramTypes.type(type);\n\t    }\n\t    return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);\n\t}\n\t/**\n\t * @internalapi\n\t * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t */\n\tfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n\t    var squash = config.squash;\n\t    if (!isOptional || squash === false)\n\t        return false;\n\t    if (!isDefined(squash) || squash == null)\n\t        return defaultPolicy;\n\t    if (squash === true || isString(squash))\n\t        return squash;\n\t    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t}\n\t/** @internalapi */\n\tfunction getReplace(config, arrayMode, isOptional, squash) {\n\t    var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") },\n\t    ];\n\t    replace = isArray(config.replace) ? config.replace : [];\n\t    if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t    configuredKeys = map(replace, prop(\"from\"));\n\t    return filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n\t}\n\t/** @internalapi */\n\tvar Param = (function () {\n\t    function Param(id, type, config, location, urlMatcherFactory) {\n\t        config = unwrapShorthand(config);\n\t        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n\t        var arrayMode = getArrayMode();\n\t        type = arrayMode ? type.$asArray(arrayMode, location === exports.DefType.SEARCH) : type;\n\t        var isOptional = config.value !== undefined || location === exports.DefType.SEARCH;\n\t        var dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n\t        var raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n\t        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n\t        var replace = getReplace(config, arrayMode, isOptional, squash);\n\t        var inherit$$1 = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\t        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t        function getArrayMode() {\n\t            var arrayDefaults = { array: (location === exports.DefType.SEARCH ? \"auto\" : false) };\n\t            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t            return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t        }\n\t        extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit$$1, array: arrayMode, config: config });\n\t    }\n\t    Param.prototype.isDefaultValue = function (value) {\n\t        return this.isOptional && this.type.equals(this.value(), value);\n\t    };\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    Param.prototype.value = function (value) {\n\t        var _this = this;\n\t        /**\n\t         * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t         */\n\t        var getDefaultValue = function () {\n\t            if (_this._defaultValueCache)\n\t                return _this._defaultValueCache.defaultValue;\n\t            if (!services.$injector)\n\t                throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t            var defaultValue = services.$injector.invoke(_this.config.$$fn);\n\t            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n\t                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n\t            if (_this.config.$$fn['__cacheable']) {\n\t                _this._defaultValueCache = { defaultValue: defaultValue };\n\t            }\n\t            return defaultValue;\n\t        };\n\t        var replaceSpecialValues = function (val$$1) {\n\t            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n\t                var tuple = _a[_i];\n\t                if (tuple.from === val$$1)\n\t                    return tuple.to;\n\t            }\n\t            return val$$1;\n\t        };\n\t        value = replaceSpecialValues(value);\n\t        return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n\t    };\n\t    Param.prototype.isSearch = function () {\n\t        return this.location === exports.DefType.SEARCH;\n\t    };\n\t    Param.prototype.validates = function (value) {\n\t        // There was no parameter value, but the param is optional\n\t        if ((isUndefined(value) || value === null) && this.isOptional)\n\t            return true;\n\t        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n\t        var normalized = this.type.$normalize(value);\n\t        if (!this.type.is(normalized))\n\t            return false;\n\t        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n\t        var encoded = this.type.encode(normalized);\n\t        return !(isString(encoded) && !this.type.pattern.exec(encoded));\n\t    };\n\t    Param.prototype.toString = function () {\n\t        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n\t    };\n\t    Param.values = function (params, values$$1) {\n\t        if (values$$1 === void 0) { values$$1 = {}; }\n\t        var paramValues = {};\n\t        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n\t            var param = params_1[_i];\n\t            paramValues[param.id] = param.value(values$$1[param.id]);\n\t        }\n\t        return paramValues;\n\t    };\n\t    /**\n\t     * Finds [[Param]] objects which have different param values\n\t     *\n\t     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n\t     *\n\t     * @param params: The list of Param objects to filter\n\t     * @param values1: The first set of parameter values\n\t     * @param values2: the second set of parameter values\n\t     *\n\t     * @returns any Param objects whose values were different between values1 and values2\n\t     */\n\t    Param.changed = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n\t    };\n\t    /**\n\t     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n\t     *\n\t     * @param params The list of [[Param]] objects to check\n\t     * @param values1 The first set of param values\n\t     * @param values2 The second set of param values\n\t     *\n\t     * @returns true if the param values in values1 and values2 are equal\n\t     */\n\t    Param.equals = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return Param.changed(params, values1, values2).length === 0;\n\t    };\n\t    /** Returns true if a the parameter values are valid, according to the Param definitions */\n\t    Param.validates = function (params, values$$1) {\n\t        if (values$$1 === void 0) { values$$1 = {}; }\n\t        return params.map(function (param) { return param.validates(values$$1[param.id]); }).reduce(allTrueR, true);\n\t    };\n\t    return Param;\n\t}());\n\t\n\t/** @module path */ /** for typedoc */\n\t/**\n\t * @internalapi\n\t *\n\t * A node in a [[TreeChanges]] path\n\t *\n\t * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n\t * Each PathNode corresponds to a state being entered, exited, or retained.\n\t * The stateful information includes parameter values and resolve data.\n\t */\n\tvar PathNode = (function () {\n\t    function PathNode(stateOrNode) {\n\t        if (stateOrNode instanceof PathNode) {\n\t            var node = stateOrNode;\n\t            this.state = node.state;\n\t            this.paramSchema = node.paramSchema.slice();\n\t            this.paramValues = extend({}, node.paramValues);\n\t            this.resolvables = node.resolvables.slice();\n\t            this.views = node.views && node.views.slice();\n\t        }\n\t        else {\n\t            var state = stateOrNode;\n\t            this.state = state;\n\t            this.paramSchema = state.parameters({ inherit: false });\n\t            this.paramValues = {};\n\t            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n\t        }\n\t    }\n\t    /** Sets [[paramValues]] for the node, from the values of an object hash */\n\t    PathNode.prototype.applyRawParams = function (params) {\n\t        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n\t        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return applyPairs(memo, getParamVal(pDef)); }, {});\n\t        return this;\n\t    };\n\t    /** Gets a specific [[Param]] metadata that belongs to the node */\n\t    PathNode.prototype.parameter = function (name) {\n\t        return find(this.paramSchema, propEq(\"id\", name));\n\t    };\n\t    /**\n\t     * @returns true if the state and parameter values for another PathNode are\n\t     * equal to the state and param values for this PathNode\n\t     */\n\t    PathNode.prototype.equals = function (node, paramsFn) {\n\t        var diff = this.diff(node, paramsFn);\n\t        return diff && diff.length === 0;\n\t    };\n\t    /**\n\t     * Finds Params with different parameter values on another PathNode.\n\t     *\n\t     * Given another node (of the same state), finds the parameter values which differ.\n\t     * Returns the [[Param]] (schema objects) whose parameter values differ.\n\t     *\n\t     * Given another node for a different state, returns `false`\n\t     *\n\t     * @param node The node to compare to\n\t     * @param paramsFn A function that returns which parameters should be compared.\n\t     * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n\t     */\n\t    PathNode.prototype.diff = function (node, paramsFn) {\n\t        if (this.state !== node.state)\n\t            return false;\n\t        var params = paramsFn ? paramsFn(this) : this.paramSchema;\n\t        return Param.changed(params, this.paramValues, node.paramValues);\n\t    };\n\t    /** Returns a clone of the PathNode */\n\t    PathNode.clone = function (node) {\n\t        return new PathNode(node);\n\t    };\n\t    return PathNode;\n\t}());\n\t\n\t/** @module path */ /** for typedoc */\n\t/**\n\t * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n\t */\n\tvar PathUtils = (function () {\n\t    function PathUtils() {\n\t    }\n\t    /** Given a PathNode[], create an TargetState */\n\t    PathUtils.makeTargetState = function (path) {\n\t        var state = tail(path).state;\n\t        return new TargetState(state, state, path.map(prop(\"paramValues\")).reduce(mergeR, {}));\n\t    };\n\t    PathUtils.buildPath = function (targetState) {\n\t        var toParams = targetState.params();\n\t        return targetState.$state().path.map(function (state) { return new PathNode(state).applyRawParams(toParams); });\n\t    };\n\t    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n\t    PathUtils.buildToPath = function (fromPath, targetState) {\n\t        var toPath = PathUtils.buildPath(targetState);\n\t        if (targetState.options().inherit) {\n\t            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n\t        }\n\t        return toPath;\n\t    };\n\t    /**\n\t     * Creates ViewConfig objects and adds to nodes.\n\t     *\n\t     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n\t     */\n\t    PathUtils.applyViewConfigs = function ($view, path, states) {\n\t        // Only apply the viewConfigs to the nodes for the given states\n\t        path.filter(function (node) { return inArray(states, node.state); }).forEach(function (node) {\n\t            var viewDecls = values(node.state.views || {});\n\t            var subPath = PathUtils.subPath(path, function (n) { return n === node; });\n\t            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n\t            node.views = viewConfigs.reduce(unnestR, []);\n\t        });\n\t    };\n\t    /**\n\t     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n\t     *\n\t     * For a parameter in a node to be inherited from the from path:\n\t     * - The toPath's node must have a matching node in the fromPath (by state).\n\t     * - The parameter name must not be found in the toKeys parameter array.\n\t     *\n\t     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n\t     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n\t     * it is not inherited from the fromPath.\n\t     */\n\t    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n\t        if (toKeys === void 0) { toKeys = []; }\n\t        function nodeParamVals(path, state) {\n\t            var node = find(path, propEq('state', state));\n\t            return extend({}, node && node.paramValues);\n\t        }\n\t        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n\t            .reduce(unnestR, [])\n\t            .filter(function (param) { return !param.inherit; })\n\t            .map(prop('id'));\n\t        /**\n\t         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n\t         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n\t         */\n\t        function makeInheritedParamsNode(toNode) {\n\t            // All param values for the node (may include default key/vals, when key was not found in toParams)\n\t            var toParamVals = extend({}, toNode && toNode.paramValues);\n\t            // limited to only those keys found in toParams\n\t            var incomingParamVals = pick(toParamVals, toKeys);\n\t            toParamVals = omit(toParamVals, toKeys);\n\t            var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n\t            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\t            var ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);\n\t            return new PathNode(toNode.state).applyRawParams(ownParamVals);\n\t        }\n\t        // The param keys specified by the incoming toParams\n\t        return toPath.map(makeInheritedParamsNode);\n\t    };\n\t    /**\n\t     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n\t     */\n\t    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n\t        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n\t        var nodesMatch = function (node1, node2) {\n\t            return node1.equals(node2, PathUtils.nonDynamicParams);\n\t        };\n\t        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n\t            keep++;\n\t        }\n\t        /** Given a retained node, return a new node which uses the to node's param values */\n\t        function applyToParams(retainedNode, idx) {\n\t            var cloned = PathNode.clone(retainedNode);\n\t            cloned.paramValues = toPath[idx].paramValues;\n\t            return cloned;\n\t        }\n\t        var from, retained, exiting, entering, to;\n\t        from = fromPath;\n\t        retained = from.slice(0, keep);\n\t        exiting = from.slice(keep);\n\t        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\t        var retainedWithToParams = retained.map(applyToParams);\n\t        entering = toPath.slice(keep);\n\t        to = (retainedWithToParams).concat(entering);\n\t        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n\t    };\n\t    /**\n\t     * Returns a new path which is: the subpath of the first path which matches the second path.\n\t     *\n\t     * The new path starts from root and contains any nodes that match the nodes in the second path.\n\t     * It stops before the first non-matching node.\n\t     *\n\t     * Nodes are compared using their state property and their parameter values.\n\t     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n\t     *\n\t     * @param pathA the first path\n\t     * @param pathB the second path\n\t     * @param paramsFn a function which returns the parameters to consider when comparing\n\t     *\n\t     * @returns an array of PathNodes from the first path which match the nodes in the second path\n\t     */\n\t    PathUtils.matching = function (pathA, pathB, paramsFn) {\n\t        var done = false;\n\t        var tuples = arrayTuples(pathA, pathB);\n\t        return tuples.reduce(function (matching, _a) {\n\t            var nodeA = _a[0], nodeB = _a[1];\n\t            done = done || !nodeA.equals(nodeB, paramsFn);\n\t            return done ? matching : matching.concat(nodeA);\n\t        }, []);\n\t    };\n\t    /**\n\t     * Returns true if two paths are identical.\n\t     *\n\t     * @param pathA\n\t     * @param pathB\n\t     * @param paramsFn a function which returns the parameters to consider when comparing\n\t     * @returns true if the the states and parameter values for both paths are identical\n\t     */\n\t    PathUtils.equals = function (pathA, pathB, paramsFn) {\n\t        return pathA.length === pathB.length &&\n\t            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n\t    };\n\t    /**\n\t     * Return a subpath of a path, which stops at the first matching node\n\t     *\n\t     * Given an array of nodes, returns a subset of the array starting from the first node,\n\t     * stopping when the first node matches the predicate.\n\t     *\n\t     * @param path a path of [[PathNode]]s\n\t     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n\t     * @returns a subpath up to the matching node, or undefined if no match is found\n\t     */\n\t    PathUtils.subPath = function (path, predicate) {\n\t        var node = find(path, predicate);\n\t        var elementIdx = path.indexOf(node);\n\t        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n\t    };\n\t    PathUtils.nonDynamicParams = function (node) {\n\t        return node.state.parameters({ inherit: false })\n\t            .filter(function (param) { return !param.dynamic; });\n\t    };\n\t    /** Gets the raw parameter values from a path */\n\t    PathUtils.paramValues = function (path) {\n\t        return path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {});\n\t    };\n\t    return PathUtils;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module resolve\n\t */ /** for typedoc */\n\t// TODO: explicitly make this user configurable\n\tvar defaultResolvePolicy = {\n\t    when: \"LAZY\",\n\t    async: \"WAIT\"\n\t};\n\t/**\n\t * The basic building block for the resolve system.\n\t *\n\t * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n\t * and the unwrapped-when-complete (.data) result of the resolveFn.\n\t *\n\t * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n\t * resolveFn) and returns the resulting promise.\n\t *\n\t * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n\t * parameter to those fns.\n\t */\n\tvar Resolvable = (function () {\n\t    function Resolvable(arg1, resolveFn, deps, policy, data) {\n\t        this.resolved = false;\n\t        this.promise = undefined;\n\t        if (arg1 instanceof Resolvable) {\n\t            extend(this, arg1);\n\t        }\n\t        else if (isFunction(resolveFn)) {\n\t            if (isNullOrUndefined(arg1))\n\t                throw new Error(\"new Resolvable(): token argument is required\");\n\t            if (!isFunction(resolveFn))\n\t                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n\t            this.token = arg1;\n\t            this.policy = policy;\n\t            this.resolveFn = resolveFn;\n\t            this.deps = deps || [];\n\t            this.data = data;\n\t            this.resolved = data !== undefined;\n\t            this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n\t        }\n\t        else if (isObject(arg1) && arg1.token && isFunction(arg1.resolveFn)) {\n\t            var literal = arg1;\n\t            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n\t        }\n\t    }\n\t    Resolvable.prototype.getPolicy = function (state) {\n\t        var thisPolicy = this.policy || {};\n\t        var statePolicy = state && state.resolvePolicy || {};\n\t        return {\n\t            when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n\t            async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,\n\t        };\n\t    };\n\t    /**\n\t     * Asynchronously resolve this Resolvable's data\n\t     *\n\t     * Given a ResolveContext that this Resolvable is found in:\n\t     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n\t     * and update the Resolvable's state\n\t     */\n\t    Resolvable.prototype.resolve = function (resolveContext, trans) {\n\t        var _this = this;\n\t        var $q = services.$q;\n\t        // Gets all dependencies from ResolveContext and wait for them to be resolved\n\t        var getResolvableDependencies = function () {\n\t            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n\t                return resolvable.get(resolveContext, trans);\n\t            }));\n\t        };\n\t        // Invokes the resolve function passing the resolved dependencies as arguments\n\t        var invokeResolveFn = function (resolvedDeps) {\n\t            return _this.resolveFn.apply(null, resolvedDeps);\n\t        };\n\t        /**\n\t         * For RXWAIT policy:\n\t         *\n\t         * Given an observable returned from a resolve function:\n\t         * - enables .cache() mode (this allows multicast subscribers)\n\t         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n\t         * - Waits for the promise, then return the cached observable (not the first emitted value).\n\t         */\n\t        var waitForRx = function (observable$) {\n\t            var cached = observable$.cache(1);\n\t            return cached.take(1).toPromise().then(function () { return cached; });\n\t        };\n\t        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n\t        var node = resolveContext.findNode(this);\n\t        var state = node && node.state;\n\t        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : identity;\n\t        // After the final value has been resolved, update the state of the Resolvable\n\t        var applyResolvedValue = function (resolvedValue) {\n\t            _this.data = resolvedValue;\n\t            _this.resolved = true;\n\t            trace.traceResolvableResolved(_this, trans);\n\t            return _this.data;\n\t        };\n\t        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n\t        return this.promise = $q.when()\n\t            .then(getResolvableDependencies)\n\t            .then(invokeResolveFn)\n\t            .then(maybeWaitForRx)\n\t            .then(applyResolvedValue);\n\t    };\n\t    /**\n\t     * Gets a promise for this Resolvable's data.\n\t     *\n\t     * Fetches the data and returns a promise.\n\t     * Returns the existing promise if it has already been fetched once.\n\t     */\n\t    Resolvable.prototype.get = function (resolveContext, trans) {\n\t        return this.promise || this.resolve(resolveContext, trans);\n\t    };\n\t    Resolvable.prototype.toString = function () {\n\t        return \"Resolvable(token: \" + stringify(this.token) + \", requires: [\" + this.deps.map(stringify) + \"])\";\n\t    };\n\t    Resolvable.prototype.clone = function () {\n\t        return new Resolvable(this);\n\t    };\n\t    Resolvable.fromData = function (token, data) {\n\t        return new Resolvable(token, function () { return data; }, null, null, data);\n\t    };\n\t    return Resolvable;\n\t}());\n\t\n\t/** @internalapi */\n\tvar resolvePolicies = {\n\t    when: {\n\t        LAZY: \"LAZY\",\n\t        EAGER: \"EAGER\"\n\t    },\n\t    async: {\n\t        WAIT: \"WAIT\",\n\t        NOWAIT: \"NOWAIT\",\n\t        RXWAIT: \"RXWAIT\"\n\t    }\n\t};\n\t\n\t/** @module resolve */\n\t/** for typedoc */\n\tvar when = resolvePolicies.when;\n\tvar ALL_WHENS = [when.EAGER, when.LAZY];\n\tvar EAGER_WHENS = [when.EAGER];\n\tvar NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n\t/**\n\t * Encapsulates Dependency Injection for a path of nodes\n\t *\n\t * UI-Router states are organized as a tree.\n\t * A nested state has a path of ancestors to the root of the tree.\n\t * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n\t * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n\t *\n\t * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n\t */\n\tvar ResolveContext = (function () {\n\t    function ResolveContext(_path) {\n\t        this._path = _path;\n\t    }\n\t    /** Gets all the tokens found in the resolve context, de-duplicated */\n\t    ResolveContext.prototype.getTokens = function () {\n\t        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(uniqR, []);\n\t    };\n\t    /**\n\t     * Gets the Resolvable that matches the token\n\t     *\n\t     * Gets the last Resolvable that matches the token in this context, or undefined.\n\t     * Throws an error if it doesn't exist in the ResolveContext\n\t     */\n\t    ResolveContext.prototype.getResolvable = function (token) {\n\t        var matching = this._path.map(function (node) { return node.resolvables; })\n\t            .reduce(unnestR, [])\n\t            .filter(function (r) { return r.token === token; });\n\t        return tail(matching);\n\t    };\n\t    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n\t    ResolveContext.prototype.getPolicy = function (resolvable) {\n\t        var node = this.findNode(resolvable);\n\t        return resolvable.getPolicy(node.state);\n\t    };\n\t    /**\n\t     * Returns a ResolveContext that includes a portion of this one\n\t     *\n\t     * Given a state, this method creates a new ResolveContext from this one.\n\t     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n\t     *\n\t     * #### Why\n\t     *\n\t     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n\t     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n\t     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n\t     * This method is used to create a narrower context when injecting ancestor nodes.\n\t     *\n\t     * @example\n\t     * `let ABCD = new ResolveContext([A, B, C, D]);`\n\t     *\n\t     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n\t     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n\t     * However, `B` should only be able to access resolvables from `A`, `B`.\n\t     *\n\t     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n\t     * `let AB = ABCD.subcontext(a)`\n\t     */\n\t    ResolveContext.prototype.subContext = function (state) {\n\t        return new ResolveContext(PathUtils.subPath(this._path, function (node) { return node.state === state; }));\n\t    };\n\t    /**\n\t     * Adds Resolvables to the node that matches the state\n\t     *\n\t     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n\t     * The resolvable is added to the node matching the `state` parameter.\n\t     *\n\t     * These new resolvables are not automatically fetched.\n\t     * The calling code should either fetch them, fetch something that depends on them,\n\t     * or rely on [[resolvePath]] being called when some state is being entered.\n\t     *\n\t     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n\t     *\n\t     * @param newResolvables the new Resolvables\n\t     * @param state Used to find the node to put the resolvable on\n\t     */\n\t    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n\t        var node = find(this._path, propEq('state', state));\n\t        var keys = newResolvables.map(function (r) { return r.token; });\n\t        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n\t    };\n\t    /**\n\t     * Returns a promise for an array of resolved path Element promises\n\t     *\n\t     * @param when\n\t     * @param trans\n\t     * @returns {Promise<any>|any}\n\t     */\n\t    ResolveContext.prototype.resolvePath = function (when, trans) {\n\t        var _this = this;\n\t        if (when === void 0) { when = \"LAZY\"; }\n\t        // This option determines which 'when' policy Resolvables we are about to fetch.\n\t        var whenOption = inArray(ALL_WHENS, when) ? when : \"LAZY\";\n\t        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n\t        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n\t        var matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\t        // get the subpath to the state argument, if provided\n\t        trace.traceResolvePath(this._path, when, trans);\n\t        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n\t            return function (resolvable) {\n\t                return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n\t            };\n\t        };\n\t        // Trigger all the (matching) Resolvables in the path\n\t        // Reduce all the \"WAIT\" Resolvables into an array\n\t        var promises = this._path.reduce(function (acc, node) {\n\t            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n\t            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n\t            var wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));\n\t            // For the matching Resolvables, start their async fetch process.\n\t            var subContext = _this.subContext(node.state);\n\t            var getResult = function (r) { return r.get(subContext, trans)\n\t                .then(function (value) { return ({ token: r.token, value: value }); }); };\n\t            nowait.forEach(getResult);\n\t            return acc.concat(wait.map(getResult));\n\t        }, []);\n\t        // Wait for all the \"WAIT\" resolvables\n\t        return services.$q.all(promises);\n\t    };\n\t    ResolveContext.prototype.injector = function () {\n\t        return this._injector || (this._injector = new UIInjectorImpl(this));\n\t    };\n\t    ResolveContext.prototype.findNode = function (resolvable) {\n\t        return find(this._path, function (node) { return inArray(node.resolvables, resolvable); });\n\t    };\n\t    /**\n\t     * Gets the async dependencies of a Resolvable\n\t     *\n\t     * Given a Resolvable, returns its dependencies as a Resolvable[]\n\t     */\n\t    ResolveContext.prototype.getDependencies = function (resolvable) {\n\t        var _this = this;\n\t        var node = this.findNode(resolvable);\n\t        // Find which other resolvables are \"visible\" to the `resolvable` argument\n\t        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n\t        var subPath = PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;\n\t        var availableResolvables = subPath\n\t            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n\t            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n\t        var getDependency = function (token) {\n\t            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n\t            if (matching.length)\n\t                return tail(matching);\n\t            var fromInjector = _this.injector().getNative(token);\n\t            if (!fromInjector) {\n\t                throw new Error(\"Could not find Dependency Injection token: \" + stringify(token));\n\t            }\n\t            return new Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n\t        };\n\t        return resolvable.deps.map(getDependency);\n\t    };\n\t    return ResolveContext;\n\t}());\n\tvar UIInjectorImpl = (function () {\n\t    function UIInjectorImpl(context) {\n\t        this.context = context;\n\t        this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n\t    }\n\t    UIInjectorImpl.prototype.get = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable) {\n\t            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n\t                return resolvable.get(this.context);\n\t            }\n\t            if (!resolvable.resolved) {\n\t                throw new Error(\"Resolvable async .get() not complete:\" + stringify(resolvable.token));\n\t            }\n\t            return resolvable.data;\n\t        }\n\t        return this.native && this.native.get(token);\n\t    };\n\t    UIInjectorImpl.prototype.getAsync = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable)\n\t            return resolvable.get(this.context);\n\t        return services.$q.when(this.native.get(token));\n\t    };\n\t    UIInjectorImpl.prototype.getNative = function (token) {\n\t        return this.native && this.native.get(token);\n\t    };\n\t    return UIInjectorImpl;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */\n\t/** for typedoc */\n\t/** @hidden */\n\tvar stateSelf = prop(\"self\");\n\t/**\n\t * Represents a transition between two states.\n\t *\n\t * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n\t *\n\t * This object contains all contextual information about the to/from states, parameters, resolves.\n\t * It has information about all states being entered and exited as a result of the transition.\n\t */\n\tvar Transition = (function () {\n\t    /**\n\t     * Creates a new Transition object.\n\t     *\n\t     * If the target state is not valid, an error is thrown.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n\t     *        encapsulates the \"from state\".\n\t     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n\t     * @param router The [[UIRouter]] instance\n\t     */\n\t    function Transition(fromPath, targetState, router) {\n\t        var _this = this;\n\t        /** @hidden */\n\t        this._deferred = services.$q.defer();\n\t        /**\n\t         * This promise is resolved or rejected based on the outcome of the Transition.\n\t         *\n\t         * When the transition is successful, the promise is resolved\n\t         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n\t         */\n\t        this.promise = this._deferred.promise;\n\t        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n\t        this._registeredHooks = {};\n\t        /** @hidden */\n\t        this._hookBuilder = new HookBuilder(this);\n\t        /** Checks if this transition is currently active/running. */\n\t        this.isActive = function () {\n\t            return _this.router.globals.transition === _this;\n\t        };\n\t        this.router = router;\n\t        this._targetState = targetState;\n\t        if (!targetState.valid()) {\n\t            throw new Error(targetState.error());\n\t        }\n\t        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\t        this._options = extend({ current: val(this) }, targetState.options());\n\t        this.$id = router.transitionService._transitionCount++;\n\t        var toPath = PathUtils.buildToPath(fromPath, targetState);\n\t        this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n\t        this.createTransitionHookRegFns();\n\t        var onCreateHooks = this._hookBuilder.buildHooksForPhase(exports.TransitionHookPhase.CREATE);\n\t        TransitionHook.invokeHooks(onCreateHooks, function () { return null; });\n\t        this.applyViewConfigs(router);\n\t    }\n\t    /** @hidden */\n\t    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onError = function (criteria, callback, options) { return; };\n\t    /** @hidden\n\t     * Creates the transition-level hook registration functions\n\t     * (which can then be used to register hooks)\n\t     */\n\t    Transition.prototype.createTransitionHookRegFns = function () {\n\t        var _this = this;\n\t        this.router.transitionService._pluginapi._getEvents()\n\t            .filter(function (type) { return type.hookPhase !== exports.TransitionHookPhase.CREATE; })\n\t            .forEach(function (type) { return makeEvent(_this, _this.router.transitionService, type); });\n\t    };\n\t    /** @internalapi */\n\t    Transition.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    Transition.prototype.applyViewConfigs = function (router) {\n\t        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n\t        PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal from [State] object\n\t     */\n\t    Transition.prototype.$from = function () {\n\t        return tail(this._treeChanges.from).state;\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal to [State] object\n\t     */\n\t    Transition.prototype.$to = function () {\n\t        return tail(this._treeChanges.to).state;\n\t    };\n\t    /**\n\t     * Returns the \"from state\"\n\t     *\n\t     * Returns the state that the transition is coming *from*.\n\t     *\n\t     * @returns The state declaration object for the Transition's (\"from state\").\n\t     */\n\t    Transition.prototype.from = function () {\n\t        return this.$from().self;\n\t    };\n\t    /**\n\t     * Returns the \"to state\"\n\t     *\n\t     * Returns the state that the transition is going *to*.\n\t     *\n\t     * @returns The state declaration object for the Transition's target state (\"to state\").\n\t     */\n\t    Transition.prototype.to = function () {\n\t        return this.$to().self;\n\t    };\n\t    /**\n\t     * Gets the Target State\n\t     *\n\t     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n\t     *\n\t     * @returns the [[TargetState]] of this Transition\n\t     */\n\t    Transition.prototype.targetState = function () {\n\t        return this._targetState;\n\t    };\n\t    /**\n\t     * Determines whether two transitions are equivalent.\n\t     * @deprecated\n\t     */\n\t    Transition.prototype.is = function (compare) {\n\t        if (compare instanceof Transition) {\n\t            // TODO: Also compare parameters\n\t            return this.is({ to: compare.$to().name, from: compare.$from().name });\n\t        }\n\t        return !((compare.to && !matchState(this.$to(), compare.to)) ||\n\t            (compare.from && !matchState(this.$from(), compare.from)));\n\t    };\n\t    Transition.prototype.params = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return Object.freeze(this._treeChanges[pathname].map(prop(\"paramValues\")).reduce(mergeR, {}));\n\t    };\n\t    /**\n\t     * Creates a [[UIInjector]] Dependency Injector\n\t     *\n\t     * Returns a Dependency Injector for the Transition's target state (to state).\n\t     * The injector provides resolve values which the target state has access to.\n\t     *\n\t     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ entering: 'myState' }, trans => {\n\t     *   var myResolveValue = trans.injector().get('myResolve');\n\t     *   // Inject a global service from the global/native injector (if it exists)\n\t     *   var MyService = trans.injector().get('MyService');\n\t     * })\n\t     * ```\n\t     *\n\t     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n\t     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n\t     * #### Example:\n\t     * ```js\n\t     * .onBefore({}, trans => {\n\t     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n\t     *     return myResolveValue !== 'ABORT';\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n\t     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ to: 'foo.bar' }, trans => {\n\t     *   // returns result of `foo` state's `data` resolve\n\t     *   // even though `foo.bar` also has a `data` resolve\n\t     *   var fooData = trans.injector('foo').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n\t     * The resolve data from the `from` path will be returned.\n\t     * #### Example:\n\t     * ```js\n\t     * .onExit({ exiting: 'foo.bar' }, trans => {\n\t     *   // Gets the resolve value of `data` from the exiting state.\n\t     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n\t     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n\t     *\n\t     * @returns a [[UIInjector]]\n\t     */\n\t    Transition.prototype.injector = function (state, pathName) {\n\t        if (pathName === void 0) { pathName = \"to\"; }\n\t        var path = this._treeChanges[pathName];\n\t        if (state)\n\t            path = PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n\t        return new ResolveContext(path).injector();\n\t    };\n\t    /**\n\t     * Gets all available resolve tokens (keys)\n\t     *\n\t     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n\t     * available to the Transition.\n\t     *\n\t     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n\t     * in the Transition's [[TreeChanges.to]] path.\n\t     *\n\t     * #### Example:\n\t     * This example logs all resolve values\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n\t     * ```\n\t     *\n\t     * #### Example:\n\t     * This example creates promises for each resolve value.\n\t     * This triggers fetches of resolves (if any have not yet been fetched).\n\t     * When all promises have all settled, it logs the resolve values.\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * let promise = tokens.map(token => trans.injector().getAsync(token));\n\t     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n\t     * ```\n\t     *\n\t     * Note: Angular 1 users whould use `$q.all()`\n\t     *\n\t     * @param pathname resolve context's path name (e.g., `to` or `from`)\n\t     *\n\t     * @returns an array of resolve tokens (keys)\n\t     */\n\t    Transition.prototype.getResolveTokens = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return new ResolveContext(this._treeChanges[pathname]).getTokens();\n\t    };\n\t    /**\n\t     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * transitionService.onBefore({}, transition => {\n\t     *   transition.addResolvable({\n\t     *     token: 'myResolve',\n\t     *     deps: ['MyService'],\n\t     *     resolveFn: myService => myService.getData()\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n\t     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n\t     */\n\t    Transition.prototype.addResolvable = function (resolvable, state) {\n\t        if (state === void 0) { state = \"\"; }\n\t        resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n\t        var stateName = (typeof state === \"string\") ? state : state.name;\n\t        var topath = this._treeChanges.to;\n\t        var targetNode = find(topath, function (node) { return node.state.name === stateName; });\n\t        var resolveContext = new ResolveContext(topath);\n\t        resolveContext.addResolvables([resolvable], targetNode.state);\n\t    };\n\t    /**\n\t     * Gets the transition from which this transition was redirected.\n\t     *\n\t     * If the current transition is a redirect, this method returns the transition that was redirected.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let transitionA = $state.go('A').transition\n\t     * transitionA.onStart({}, () => $state.target('B'));\n\t     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n\t     *   trans.to().name === 'B'; // true\n\t     *   trans.redirectedFrom() === transitionA; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n\t     */\n\t    Transition.prototype.redirectedFrom = function () {\n\t        return this._options.redirectedFrom || null;\n\t    };\n\t    /**\n\t     * Gets the original transition in a redirect chain\n\t     *\n\t     * A transition might belong to a long chain of multiple redirects.\n\t     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * // states\n\t     * registry.register({ name: 'A', redirectTo: 'B' });\n\t     * registry.register({ name: 'B', redirectTo: 'C' });\n\t     * registry.register({ name: 'C', redirectTo: 'D' });\n\t     * registry.register({ name: 'D' });\n\t     *\n\t     * let transitionA = $state.go('A').transition\n\t     *\n\t     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n\t     *   trans.to().name === 'D'; // true\n\t     *   trans.redirectedFrom().to().name === 'C'; // true\n\t     *   trans.originalTransition() === transitionA; // true\n\t     *   trans.originalTransition().to().name === 'A'; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The original Transition that started a redirect chain\n\t     */\n\t    Transition.prototype.originalTransition = function () {\n\t        var rf = this.redirectedFrom();\n\t        return (rf && rf.originalTransition()) || this;\n\t    };\n\t    /**\n\t     * Get the transition options\n\t     *\n\t     * @returns the options for this Transition.\n\t     */\n\t    Transition.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /**\n\t     * Gets the states being entered.\n\t     *\n\t     * @returns an array of states that will be entered during this transition.\n\t     */\n\t    Transition.prototype.entering = function () {\n\t        return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Gets the states being exited.\n\t     *\n\t     * @returns an array of states that will be exited during this transition.\n\t     */\n\t    Transition.prototype.exiting = function () {\n\t        return map(this._treeChanges.exiting, prop('state')).map(stateSelf).reverse();\n\t    };\n\t    /**\n\t     * Gets the states being retained.\n\t     *\n\t     * @returns an array of states that are already entered from a previous Transition, that will not be\n\t     *    exited during this Transition\n\t     */\n\t    Transition.prototype.retained = function () {\n\t        return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Get the [[ViewConfig]]s associated with this Transition\n\t     *\n\t     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n\t     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n\t     *\n\t     * @param pathname the name of the path to fetch views for:\n\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n\t     *\n\t     * @returns a list of ViewConfig objects for the given path.\n\t     */\n\t    Transition.prototype.views = function (pathname, state) {\n\t        if (pathname === void 0) { pathname = \"entering\"; }\n\t        var path = this._treeChanges[pathname];\n\t        path = !state ? path : path.filter(propEq('state', state));\n\t        return path.map(prop(\"views\")).filter(identity).reduce(unnestR, []);\n\t    };\n\t    Transition.prototype.treeChanges = function (pathname) {\n\t        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n\t    };\n\t    /**\n\t     * Creates a new transition that is a redirection of the current one.\n\t     *\n\t     * This transition can be returned from a [[TransitionService]] hook to\n\t     * redirect a transition to a new state and/or set of parameters.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns Returns a new [[Transition]] instance.\n\t     */\n\t    Transition.prototype.redirect = function (targetState) {\n\t        var redirects = 1, trans = this;\n\t        while ((trans = trans.redirectedFrom()) != null) {\n\t            if (++redirects > 20)\n\t                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n\t        }\n\t        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n\t        // If the original transition was caused by URL sync, then use { location: 'replace' }\n\t        // on the new transition (unless the target state explicitly specifies location: false).\n\t        // This causes the original url to be replaced with the url for the redirect target\n\t        // so the original url disappears from the browser history.\n\t        if (this.options().source === 'url' && targetState.options().location !== false) {\n\t            redirectOpts.location = 'replace';\n\t        }\n\t        var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n\t        targetState = new TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n\t        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n\t        var originalEnteringNodes = this._treeChanges.entering;\n\t        var redirectEnteringNodes = newTransition._treeChanges.entering;\n\t        // --- Re-use resolve data from original transition ---\n\t        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n\t        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n\t        // redirected transition.\n\t        //\n\t        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n\t        // You can wait for the resolve, then redirect to a child state based on the result.\n\t        // The redirected transition does not have to re-fetch the resolve.\n\t        // ---------------------------------------------------------\n\t        var nodeIsReloading = function (reloadState) { return function (node) {\n\t            return reloadState && node.state.includes[reloadState.name];\n\t        }; };\n\t        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n\t        var matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams)\n\t            .filter(not(nodeIsReloading(targetState.options().reloadState)));\n\t        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n\t        matchingEnteringNodes.forEach(function (node, idx) {\n\t            node.resolvables = originalEnteringNodes[idx].resolvables;\n\t        });\n\t        return newTransition;\n\t    };\n\t    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\t    Transition.prototype._changedParams = function () {\n\t        var tc = this._treeChanges;\n\t        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n\t        // If user explicitly wants a reload\n\t        if (this._options.reload)\n\t            return undefined;\n\t        // If any states are exiting or entering\n\t        if (tc.exiting.length || tc.entering.length)\n\t            return undefined;\n\t        // If to/from path lengths differ\n\t        if (tc.to.length !== tc.from.length)\n\t            return undefined;\n\t        // If the to/from paths are different\n\t        var pathsDiffer = arrayTuples(tc.to, tc.from)\n\t            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n\t            .reduce(anyTrueR, false);\n\t        if (pathsDiffer)\n\t            return undefined;\n\t        // Find any parameter values that differ\n\t        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n\t        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n\t        var tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n\t        return tuples.map(function (_a) {\n\t            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n\t            return Param.changed(schema, toVals, fromVals);\n\t        }).reduce(unnestR, []);\n\t    };\n\t    /**\n\t     * Returns true if the transition is dynamic.\n\t     *\n\t     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n\t     *\n\t     * @returns true if the Transition is dynamic\n\t     */\n\t    Transition.prototype.dynamic = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(anyTrueR, false);\n\t    };\n\t    /**\n\t     * Returns true if the transition is ignored.\n\t     *\n\t     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n\t     *\n\t     * @returns true if the Transition is ignored.\n\t     */\n\t    Transition.prototype.ignored = function () {\n\t        return !!this._ignoredReason();\n\t    };\n\t    /** @hidden */\n\t    Transition.prototype._ignoredReason = function () {\n\t        var pending = this.router.globals.transition;\n\t        var reloadState = this._options.reloadState;\n\t        var same = function (pathA, pathB) {\n\t            if (pathA.length !== pathB.length)\n\t                return false;\n\t            var matching = PathUtils.matching(pathA, pathB);\n\t            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;\n\t        };\n\t        var newTC = this.treeChanges();\n\t        var pendTC = pending && pending.treeChanges();\n\t        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))\n\t            return \"SameAsPending\";\n\t        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))\n\t            return \"SameAsCurrent\";\n\t    };\n\t    /**\n\t     * Runs the transition\n\t     *\n\t     * This method is generally called from the [[StateService.transitionTo]]\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns a promise for a successful transition.\n\t     */\n\t    Transition.prototype.run = function () {\n\t        var _this = this;\n\t        var runAllHooks = TransitionHook.runAllHooks;\n\t        // Gets transition hooks array for the given phase\n\t        var getHooksFor = function (phase) {\n\t            return _this._hookBuilder.buildHooksForPhase(phase);\n\t        };\n\t        // When the chain is complete, then resolve or reject the deferred\n\t        var transitionSuccess = function () {\n\t            trace.traceSuccess(_this.$to(), _this);\n\t            _this.success = true;\n\t            _this._deferred.resolve(_this.to());\n\t            runAllHooks(getHooksFor(exports.TransitionHookPhase.SUCCESS));\n\t        };\n\t        var transitionError = function (reason) {\n\t            trace.traceError(reason, _this);\n\t            _this.success = false;\n\t            _this._deferred.reject(reason);\n\t            _this._error = reason;\n\t            runAllHooks(getHooksFor(exports.TransitionHookPhase.ERROR));\n\t        };\n\t        var runTransition = function () {\n\t            // Wait to build the RUN hook chain until the BEFORE hooks are done\n\t            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n\t            var allRunHooks = getHooksFor(exports.TransitionHookPhase.RUN);\n\t            var done = function () { return services.$q.when(undefined); };\n\t            return TransitionHook.invokeHooks(allRunHooks, done);\n\t        };\n\t        var startTransition = function () {\n\t            var globals = _this.router.globals;\n\t            globals.lastStartedTransitionId = _this.$id;\n\t            globals.transition = _this;\n\t            globals.transitionHistory.enqueue(_this);\n\t            trace.traceTransitionStart(_this);\n\t            return services.$q.when(undefined);\n\t        };\n\t        var allBeforeHooks = getHooksFor(exports.TransitionHookPhase.BEFORE);\n\t        TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n\t            .then(runTransition)\n\t            .then(transitionSuccess, transitionError);\n\t        return this.promise;\n\t    };\n\t    /**\n\t     * Checks if the Transition is valid\n\t     *\n\t     * @returns true if the Transition is valid\n\t     */\n\t    Transition.prototype.valid = function () {\n\t        return !this.error() || this.success !== undefined;\n\t    };\n\t    /**\n\t     * Aborts this transition\n\t     *\n\t     * Imperative API to abort a Transition.\n\t     * This only applies to Transitions that are not yet complete.\n\t     */\n\t    Transition.prototype.abort = function () {\n\t        // Do not set flag if the transition is already complete\n\t        if (isUndefined(this.success)) {\n\t            this._aborted = true;\n\t        }\n\t    };\n\t    /**\n\t     * The Transition error reason.\n\t     *\n\t     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n\t     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n\t     *\n\t     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n\t     */\n\t    Transition.prototype.error = function () {\n\t        var state = this.$to();\n\t        if (state.self.abstract)\n\t            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n\t        var paramDefs = state.parameters(), values$$1 = this.params();\n\t        var invalidParams = paramDefs.filter(function (param) { return !param.validates(values$$1[param.id]); });\n\t        if (invalidParams.length) {\n\t            return \"Param values not valid for state '\" + state.name + \"'. Invalid params: [ \" + invalidParams.map(function (param) { return param.id; }).join(', ') + \" ]\";\n\t        }\n\t        if (this.success === false)\n\t            return this._error;\n\t    };\n\t    /**\n\t     * A string representation of the Transition\n\t     *\n\t     * @returns A string representation of the Transition\n\t     */\n\t    Transition.prototype.toString = function () {\n\t        var fromStateOrName = this.from();\n\t        var toStateOrName = this.to();\n\t        var avoidEmptyHash = function (params) {\n\t            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : omit(params, [\"#\"]);\n\t        };\n\t        // (X) means the to state is invalid.\n\t        var id = this.$id, from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = toJson(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = toJson(avoidEmptyHash(this.params()));\n\t        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n\t    };\n\t    /** @hidden */\n\t    Transition.diToken = Transition;\n\t    return Transition;\n\t}());\n\t\n\t/**\n\t * Functions that manipulate strings\n\t *\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_strings\n\t */ /** */\n\t/**\n\t * Returns a string shortened to a maximum length\n\t *\n\t * If the string is already less than the `max` length, return the string.\n\t * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n\t *\n\t * @param max the maximum length of the string to return\n\t * @param str the input string\n\t */\n\tfunction maxLength(max, str) {\n\t    if (str.length <= max)\n\t        return str;\n\t    return str.substr(0, max - 3) + \"...\";\n\t}\n\t/**\n\t * Returns a string, with spaces added to the end, up to a desired str length\n\t *\n\t * If the string is already longer than the desired length, return the string.\n\t * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n\t *\n\t * @param length the desired length of the string to return\n\t * @param str the input string\n\t */\n\tfunction padString(length, str) {\n\t    while (str.length < length)\n\t        str += \" \";\n\t    return str;\n\t}\n\tfunction kebobString(camelCase) {\n\t    return camelCase\n\t        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n\t        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n\t}\n\tfunction functionToString(fn) {\n\t    var fnStr = fnToString(fn);\n\t    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\t    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\t    var fnName = fn['name'] || \"\";\n\t    if (fnName && toStr.match(/function \\(/)) {\n\t        return 'function ' + fnName + toStr.substr(9);\n\t    }\n\t    return toStr;\n\t}\n\tfunction fnToString(fn) {\n\t    var _fn = isArray(fn) ? fn.slice(-1)[0] : fn;\n\t    return _fn && _fn.toString() || \"undefined\";\n\t}\n\tvar stringifyPatternFn = null;\n\tvar stringifyPattern = function (value) {\n\t    var isRejection = Rejection.isRejectionPromise;\n\t    stringifyPatternFn = stringifyPatternFn || pattern([\n\t        [not(isDefined), val(\"undefined\")],\n\t        [isNull, val(\"null\")],\n\t        [isPromise, val(\"[Promise]\")],\n\t        [isRejection, function (x) { return x._transitionRejection.toString(); }],\n\t        [is(Rejection), invoke(\"toString\")],\n\t        [is(Transition), invoke(\"toString\")],\n\t        [is(Resolvable), invoke(\"toString\")],\n\t        [isInjectable, functionToString],\n\t        [val(true), identity]\n\t    ]);\n\t    return stringifyPatternFn(value);\n\t};\n\tfunction stringify(o) {\n\t    var seen = [];\n\t    function format(val$$1) {\n\t        if (isObject(val$$1)) {\n\t            if (seen.indexOf(val$$1) !== -1)\n\t                return '[circular ref]';\n\t            seen.push(val$$1);\n\t        }\n\t        return stringifyPattern(val$$1);\n\t    }\n\t    return JSON.stringify(o, function (key, val$$1) { return format(val$$1); }).replace(/\\\\\"/g, '\"');\n\t}\n\t/** Returns a function that splits a string on a character or substring */\n\tvar beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\t/**\n\t * Splits on a delimiter, but returns the delimiters in the array\n\t *\n\t * #### Example:\n\t * ```js\n\t * var splitOnSlashes = splitOnDelim('/');\n\t * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n\t * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n\t * ```\n\t */\n\tfunction splitOnDelim(delim) {\n\t    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n\t    return function (str) {\n\t        return str.split(re).filter(identity);\n\t    };\n\t}\n\t\n\t/**\n\t * Reduce fn that joins neighboring strings\n\t *\n\t * Given an array of strings, returns a new array\n\t * where all neighboring strings have been joined.\n\t *\n\t * #### Example:\n\t * ```js\n\t * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n\t * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n\t * ```\n\t */\n\tfunction joinNeighborsR(acc, x) {\n\t    if (isString(tail(acc)) && isString(x))\n\t        return acc.slice(0, -1).concat(tail(acc) + x);\n\t    return pushR(acc, x);\n\t}\n\t\n\t/** @module common */ /** for typedoc */\n\t\n\t/**\n\t * @coreapi\n\t * @module params\n\t */\n\t/** */\n\t/**\n\t * A registry for parameter types.\n\t *\n\t * This registry manages the built-in (and custom) parameter types.\n\t *\n\t * The built-in parameter types are:\n\t *\n\t * - [[string]]\n\t * - [[path]]\n\t * - [[query]]\n\t * - [[hash]]\n\t * - [[int]]\n\t * - [[bool]]\n\t * - [[date]]\n\t * - [[json]]\n\t * - [[any]]\n\t */\n\tvar ParamTypes = (function () {\n\t    /** @internalapi */\n\t    function ParamTypes() {\n\t        /** @hidden */\n\t        this.enqueue = true;\n\t        /** @hidden */\n\t        this.typeQueue = [];\n\t        /** @internalapi */\n\t        this.defaultTypes = pick(ParamTypes.prototype, [\"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\"]);\n\t        // Register default types. Store them in the prototype of this.types.\n\t        var makeType = function (definition, name) {\n\t            return new ParamType(extend({ name: name }, definition));\n\t        };\n\t        this.types = inherit(map(this.defaultTypes, makeType), {});\n\t    }\n\t    /** @internalapi */\n\t    ParamTypes.prototype.dispose = function () {\n\t        this.types = {};\n\t    };\n\t    /**\n\t     * Registers a parameter type\n\t     *\n\t     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n\t     */\n\t    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n\t        if (!isDefined(definition))\n\t            return this.types[name];\n\t        if (this.types.hasOwnProperty(name))\n\t            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t        this.types[name] = new ParamType(extend({ name: name }, definition));\n\t        if (definitionFn) {\n\t            this.typeQueue.push({ name: name, def: definitionFn });\n\t            if (!this.enqueue)\n\t                this._flushTypeQueue();\n\t        }\n\t        return this;\n\t    };\n\t    /** @internalapi */\n\t    ParamTypes.prototype._flushTypeQueue = function () {\n\t        while (this.typeQueue.length) {\n\t            var type = this.typeQueue.shift();\n\t            if (type.pattern)\n\t                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t            extend(this.types[type.name], services.$injector.invoke(type.def));\n\t        }\n\t    };\n\t    return ParamTypes;\n\t}());\n\t/** @hidden */\n\tfunction initDefaultTypes() {\n\t    var makeDefaultType = function (def) {\n\t        var valToString = function (val$$1) {\n\t            return val$$1 != null ? val$$1.toString() : val$$1;\n\t        };\n\t        var defaultTypeBase = {\n\t            encode: valToString,\n\t            decode: valToString,\n\t            is: is(String),\n\t            pattern: /.*/,\n\t            equals: function (a, b) { return a == b; },\n\t        };\n\t        return extend({}, defaultTypeBase, def);\n\t    };\n\t    // Default Parameter Type Definitions\n\t    extend(ParamTypes.prototype, {\n\t        string: makeDefaultType({}),\n\t        path: makeDefaultType({\n\t            pattern: /[^/]*/,\n\t        }),\n\t        query: makeDefaultType({}),\n\t        hash: makeDefaultType({\n\t            inherit: false,\n\t        }),\n\t        int: makeDefaultType({\n\t            decode: function (val$$1) { return parseInt(val$$1, 10); },\n\t            is: function (val$$1) {\n\t                return !isNullOrUndefined(val$$1) && this.decode(val$$1.toString()) === val$$1;\n\t            },\n\t            pattern: /-?\\d+/,\n\t        }),\n\t        bool: makeDefaultType({\n\t            encode: function (val$$1) { return val$$1 && 1 || 0; },\n\t            decode: function (val$$1) { return parseInt(val$$1, 10) !== 0; },\n\t            is: is(Boolean),\n\t            pattern: /0|1/\n\t        }),\n\t        date: makeDefaultType({\n\t            encode: function (val$$1) {\n\t                return !this.is(val$$1) ? undefined : [\n\t                    val$$1.getFullYear(),\n\t                    ('0' + (val$$1.getMonth() + 1)).slice(-2),\n\t                    ('0' + val$$1.getDate()).slice(-2)\n\t                ].join(\"-\");\n\t            },\n\t            decode: function (val$$1) {\n\t                if (this.is(val$$1))\n\t                    return val$$1;\n\t                var match = this.capture.exec(val$$1);\n\t                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t            },\n\t            is: function (val$$1) { return val$$1 instanceof Date && !isNaN(val$$1.valueOf()); },\n\t            equals: function (l, r) {\n\t                return ['getFullYear', 'getMonth', 'getDate']\n\t                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n\t            },\n\t            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t        }),\n\t        json: makeDefaultType({\n\t            encode: toJson,\n\t            decode: fromJson,\n\t            is: is(Object),\n\t            equals: equals,\n\t            pattern: /[^/]*/\n\t        }),\n\t        // does not encode/decode\n\t        any: makeDefaultType({\n\t            encode: identity,\n\t            decode: identity,\n\t            is: function () { return true; },\n\t            equals: equals,\n\t        }),\n\t    });\n\t}\n\tinitDefaultTypes();\n\t\n\t/**\n\t * @coreapi\n\t * @module params\n\t */\n\t/** */\n\t/** @internalapi */\n\tvar StateParams = (function () {\n\t    function StateParams(params) {\n\t        if (params === void 0) { params = {}; }\n\t        extend(this, params);\n\t    }\n\t    /**\n\t     * Merges a set of parameters with all parameters inherited between the common parents of the\n\t     * current state and a given destination state.\n\t     *\n\t     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t     * @param {Object} $current Internal definition of object representing the current state.\n\t     * @param {Object} $to Internal definition of object representing state to transition to.\n\t     */\n\t    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n\t        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t        for (var i in parents) {\n\t            if (!parents[i] || !parents[i].params)\n\t                continue;\n\t            parentParams = Object.keys(parents[i].params);\n\t            if (!parentParams.length)\n\t                continue;\n\t            for (var j in parentParams) {\n\t                if (inheritList.indexOf(parentParams[j]) >= 0)\n\t                    continue;\n\t                inheritList.push(parentParams[j]);\n\t                inherited[parentParams[j]] = this[parentParams[j]];\n\t            }\n\t        }\n\t        return extend({}, inherited, newParams);\n\t    };\n\t    \n\t    return StateParams;\n\t}());\n\t\n\t/** @module path */ /** for typedoc */\n\t\n\t/** @module resolve */ /** for typedoc */\n\t\n\t/** @module state */ /** for typedoc */\n\tvar parseUrl = function (url) {\n\t    if (!isString(url))\n\t        return false;\n\t    var root = url.charAt(0) === '^';\n\t    return { val: root ? url.substring(1) : url, root: root };\n\t};\n\tfunction nameBuilder(state) {\n\t    return state.name;\n\t}\n\tfunction selfBuilder(state) {\n\t    state.self.$$state = function () { return state; };\n\t    return state.self;\n\t}\n\tfunction dataBuilder(state) {\n\t    if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = inherit(state.parent.data, state.data);\n\t    }\n\t    return state.data;\n\t}\n\tvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n\t    return function urlBuilder(state) {\n\t        var stateDec = state;\n\t        // For future states, i.e., states whose name ends with `.**`,\n\t        // match anything that starts with the url prefix\n\t        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n\t            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n\t        }\n\t        var parsed = parseUrl(stateDec.url), parent = state.parent;\n\t        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n\t            params: state.params || {},\n\t            paramMap: function (paramConfig, isSearch) {\n\t                if (stateDec.reloadOnSearch === false && isSearch)\n\t                    paramConfig = extend(paramConfig || {}, { dynamic: true });\n\t                return paramConfig;\n\t            }\n\t        });\n\t        if (!url)\n\t            return null;\n\t        if (!$urlMatcherFactoryProvider.isMatcher(url))\n\t            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n\t    };\n\t};\n\tvar getNavigableBuilder = function (isRoot) {\n\t    return function navigableBuilder(state) {\n\t        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    };\n\t};\n\tvar getParamsBuilder = function (paramFactory) {\n\t    return function paramsBuilder(state) {\n\t        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n\t        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n\t        var nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));\n\t        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(applyPairs, {});\n\t    };\n\t};\n\tfunction pathBuilder(state) {\n\t    return state.parent ? state.parent.path.concat(state) : [state];\n\t}\n\tfunction includesBuilder(state) {\n\t    var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t    includes[state.name] = true;\n\t    return includes;\n\t}\n\t/**\n\t * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n\t *\n\t * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n\t * validates the `resolve` property and converts it to a [[Resolvable]] array.\n\t *\n\t * resolve: input value can be:\n\t *\n\t * {\n\t *   // analyzed but not injected\n\t *   myFooResolve: function() { return \"myFooData\"; },\n\t *\n\t *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n\t *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; \"DependencyName\" dep as string\n\t *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; DependencyType dep as token (compared using ===)\n\t *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n\t *\n\t *   // val.$inject used as deps\n\t *   // where:\n\t *   //     corgeResolve.$inject = [\"DependencyName\"];\n\t *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n\t *   // then \"DependencyName\" dep as string\n\t *   myCorgeResolve: corgeResolve,\n\t *\n\t *  // inject service by name\n\t *  // When a string is found, desugar creating a resolve that injects the named service\n\t *   myGraultResolve: \"SomeService\"\n\t * }\n\t *\n\t * or:\n\t *\n\t * [\n\t *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n\t *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n\t *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n\t * ]\n\t */\n\tfunction resolvablesBuilder(state) {\n\t    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n\t    var objects2Tuples = function (resolveObj, resolvePolicies) {\n\t        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n\t    };\n\t    /** fetch DI annotations from a function or ng1-style array */\n\t    var annotate = function (fn) {\n\t        var $injector = services.$injector;\n\t        // ng1 doesn't have an $injector until runtime.\n\t        // If the $injector doesn't exist, use \"deferred\" literal as a\n\t        // marker indicating they should be annotated when runtime starts\n\t        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n\t    };\n\t    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n\t    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n\t    /** true if the object looks like a provide literal, or a ng2 Provider */\n\t    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n\t    /** true if the object looks like a tuple from obj2Tuples */\n\t    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val))); };\n\t    /** extracts the token from a Provider or provide literal */\n\t    var token = function (p) { return p.provide || p.token; };\n\t    /** Given a literal resolve or provider object, returns a Resolvable */\n\t    var literal2Resolvable = pattern([\n\t        [prop('resolveFn'), function (p) { return new Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n\t        [prop('useFactory'), function (p) { return new Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n\t        [prop('useClass'), function (p) { return new Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n\t        [prop('useValue'), function (p) { return new Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n\t        [prop('useExisting'), function (p) { return new Resolvable(token(p), identity, [p.useExisting], p.policy); }],\n\t    ]);\n\t    var tuple2Resolvable = pattern([\n\t        [pipe(prop(\"val\"), isString), function (tuple) { return new Resolvable(tuple.token, identity, [tuple.val], tuple.policy); }],\n\t        [pipe(prop(\"val\"), isArray), function (tuple) { return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n\t        [pipe(prop(\"val\"), isFunction), function (tuple) { return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n\t    ]);\n\t    var item2Resolvable = pattern([\n\t        [is(Resolvable), function (r) { return r; }],\n\t        [isResolveLiteral, literal2Resolvable],\n\t        [isLikeNg2Provider, literal2Resolvable],\n\t        [isTupleFromObj, tuple2Resolvable],\n\t        [val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + stringify(obj)); }]\n\t    ]);\n\t    // If resolveBlock is already an array, use it as-is.\n\t    // Otherwise, assume it's an object and convert to an Array of tuples\n\t    var decl = state.resolve;\n\t    var items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n\t    return items.map(item2Resolvable);\n\t}\n\t/**\n\t * @internalapi A internal global service\n\t *\n\t * StateBuilder is a factory for the internal [[StateObject]] objects.\n\t *\n\t * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n\t * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n\t * [[StateObject]] object, which has an API and is used internally.\n\t *\n\t * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n\t * using the [[builder]] method.\n\t */\n\tvar StateBuilder = (function () {\n\t    function StateBuilder(matcher, urlMatcherFactory) {\n\t        this.matcher = matcher;\n\t        var self = this;\n\t        var root = function () { return matcher.find(\"\"); };\n\t        var isRoot = function (state) { return state.name === \"\"; };\n\t        function parentBuilder(state) {\n\t            if (isRoot(state))\n\t                return null;\n\t            return matcher.find(self.parentName(state)) || root();\n\t        }\n\t        this.builders = {\n\t            name: [nameBuilder],\n\t            self: [selfBuilder],\n\t            parent: [parentBuilder],\n\t            data: [dataBuilder],\n\t            // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t            url: [getUrlBuilder(urlMatcherFactory, root)],\n\t            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t            navigable: [getNavigableBuilder(isRoot)],\n\t            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n\t            // Each framework-specific ui-router implementation should define its own `views` builder\n\t            // e.g., src/ng1/statebuilders/views.ts\n\t            views: [],\n\t            // Keep a full path from the root down to this state as this is needed for state activation.\n\t            path: [pathBuilder],\n\t            // Speed up $state.includes() as it's used a lot\n\t            includes: [includesBuilder],\n\t            resolvables: [resolvablesBuilder]\n\t        };\n\t    }\n\t    /**\n\t     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n\t     * More than one BuilderFunction can be registered for a given property.\n\t     *\n\t     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n\t     *\n\t     * @param name The name of the State property being registered for.\n\t     * @param fn The BuilderFunction which will be used to build the State property\n\t     * @returns a function which deregisters the BuilderFunction\n\t     */\n\t    StateBuilder.prototype.builder = function (name, fn) {\n\t        var builders = this.builders;\n\t        var array = builders[name] || [];\n\t        // Backwards compat: if only one builder exists, return it, else return whole arary.\n\t        if (isString(name) && !isDefined(fn))\n\t            return array.length > 1 ? array : array[0];\n\t        if (!isString(name) || !isFunction(fn))\n\t            return;\n\t        builders[name] = array;\n\t        builders[name].push(fn);\n\t        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n\t    };\n\t    /**\n\t     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n\t     * properties and API built.\n\t     *\n\t     * @param state an uninitialized State object\n\t     * @returns the built State object\n\t     */\n\t    StateBuilder.prototype.build = function (state) {\n\t        var _a = this, matcher = _a.matcher, builders = _a.builders;\n\t        var parent = this.parentName(state);\n\t        if (parent && !matcher.find(parent, undefined, false)) {\n\t            return null;\n\t        }\n\t        for (var key in builders) {\n\t            if (!builders.hasOwnProperty(key))\n\t                continue;\n\t            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, noop);\n\t            state[key] = chain(state);\n\t        }\n\t        return state;\n\t    };\n\t    StateBuilder.prototype.parentName = function (state) {\n\t        // name = 'foo.bar.baz.**'\n\t        var name = state.name || \"\";\n\t        // segments = ['foo', 'bar', 'baz', '.**']\n\t        var segments = name.split('.');\n\t        // segments = ['foo', 'bar', 'baz']\n\t        var lastSegment = segments.pop();\n\t        // segments = ['foo', 'bar'] (ignore .** segment for future states)\n\t        if (lastSegment === '**')\n\t            segments.pop();\n\t        if (segments.length) {\n\t            if (state.parent) {\n\t                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n\t            }\n\t            // 'foo.bar'\n\t            return segments.join(\".\");\n\t        }\n\t        if (!state.parent)\n\t            return \"\";\n\t        return isString(state.parent) ? state.parent : state.parent.name;\n\t    };\n\t    StateBuilder.prototype.name = function (state) {\n\t        var name = state.name;\n\t        if (name.indexOf('.') !== -1 || !state.parent)\n\t            return name;\n\t        var parentName = isString(state.parent) ? state.parent : state.parent.name;\n\t        return parentName ? parentName + \".\" + name : name;\n\t    };\n\t    return StateBuilder;\n\t}());\n\t\n\t/** @module state */ /** for typedoc */\n\tvar StateMatcher = (function () {\n\t    function StateMatcher(_states) {\n\t        this._states = _states;\n\t    }\n\t    StateMatcher.prototype.isRelative = function (stateName) {\n\t        stateName = stateName || \"\";\n\t        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t    };\n\t    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n\t        if (matchGlob === void 0) { matchGlob = true; }\n\t        if (!stateOrName && stateOrName !== \"\")\n\t            return undefined;\n\t        var isStr = isString(stateOrName);\n\t        var name = isStr ? stateOrName : stateOrName.name;\n\t        if (this.isRelative(name))\n\t            name = this.resolvePath(name, base);\n\t        var state = this._states[name];\n\t        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t            return state;\n\t        }\n\t        else if (isStr && matchGlob) {\n\t            var _states = values(this._states);\n\t            var matches = _states.filter(function (state) {\n\t                return state.__stateObjectCache.nameGlob &&\n\t                    state.__stateObjectCache.nameGlob.matches(name);\n\t            });\n\t            if (matches.length > 1) {\n\t                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n\t            }\n\t            return matches[0];\n\t        }\n\t        return undefined;\n\t    };\n\t    StateMatcher.prototype.resolvePath = function (name, base) {\n\t        if (!base)\n\t            throw new Error(\"No reference point given for path '\" + name + \"'\");\n\t        var baseState = this.find(base);\n\t        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n\t        for (; i < pathLength; i++) {\n\t            if (splitName[i] === \"\" && i === 0) {\n\t                current = baseState;\n\t                continue;\n\t            }\n\t            if (splitName[i] === \"^\") {\n\t                if (!current.parent)\n\t                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n\t                current = current.parent;\n\t                continue;\n\t            }\n\t            break;\n\t        }\n\t        var relName = splitName.slice(i).join(\".\");\n\t        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n\t    };\n\t    return StateMatcher;\n\t}());\n\t\n\t/** @module state */ /** for typedoc */\n\t/** @internalapi */\n\tvar StateQueueManager = (function () {\n\t    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n\t        this.$registry = $registry;\n\t        this.$urlRouter = $urlRouter;\n\t        this.states = states;\n\t        this.builder = builder;\n\t        this.listeners = listeners;\n\t        this.queue = [];\n\t        this.matcher = $registry.matcher;\n\t    }\n\t    /** @internalapi */\n\t    StateQueueManager.prototype.dispose = function () {\n\t        this.queue = [];\n\t    };\n\t    StateQueueManager.prototype.register = function (stateDecl) {\n\t        var queue = this.queue;\n\t        var state = StateObject.create(stateDecl);\n\t        var name = state.name;\n\t        if (!isString(name))\n\t            throw new Error(\"State must have a valid name\");\n\t        if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))\n\t            throw new Error(\"State '\" + name + \"' is already defined\");\n\t        queue.push(state);\n\t        this.flush();\n\t        return state;\n\t    };\n\t    StateQueueManager.prototype.flush = function () {\n\t        var _this = this;\n\t        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n\t        var registered = [], // states that got registered\n\t        orphans = [], // states that don't yet have a parent registered\n\t        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\t        var getState = function (name) {\n\t            return _this.states.hasOwnProperty(name) && _this.states[name];\n\t        };\n\t        while (queue.length > 0) {\n\t            var state = queue.shift();\n\t            var name_1 = state.name;\n\t            var result = builder.build(state);\n\t            var orphanIdx = orphans.indexOf(state);\n\t            if (result) {\n\t                var existingState = getState(name_1);\n\t                if (existingState && existingState.name === name_1) {\n\t                    throw new Error(\"State '\" + name_1 + \"' is already defined\");\n\t                }\n\t                var existingFutureState = getState(name_1 + \".**\");\n\t                if (existingFutureState) {\n\t                    // Remove future state of the same name\n\t                    this.$registry.deregister(existingFutureState);\n\t                }\n\t                states[name_1] = state;\n\t                this.attachRoute(state);\n\t                if (orphanIdx >= 0)\n\t                    orphans.splice(orphanIdx, 1);\n\t                registered.push(state);\n\t                continue;\n\t            }\n\t            var prev = previousQueueLength[name_1];\n\t            previousQueueLength[name_1] = queue.length;\n\t            if (orphanIdx >= 0 && prev === queue.length) {\n\t                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n\t                // throw new Error(`Cannot register orphaned state '${name}'`);\n\t                queue.push(state);\n\t                return states;\n\t            }\n\t            else if (orphanIdx < 0) {\n\t                orphans.push(state);\n\t            }\n\t            queue.push(state);\n\t        }\n\t        if (registered.length) {\n\t            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n\t        }\n\t        return states;\n\t    };\n\t    StateQueueManager.prototype.attachRoute = function (state) {\n\t        if (state.abstract || !state.url)\n\t            return;\n\t        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n\t    };\n\t    return StateQueueManager;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\tvar StateRegistry = (function () {\n\t    /** @internalapi */\n\t    function StateRegistry(_router) {\n\t        this._router = _router;\n\t        this.states = {};\n\t        this.listeners = [];\n\t        this.matcher = new StateMatcher(this.states);\n\t        this.builder = new StateBuilder(this.matcher, _router.urlMatcherFactory);\n\t        this.stateQueue = new StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n\t        this._registerRoot();\n\t    }\n\t    /** @internalapi */\n\t    StateRegistry.prototype._registerRoot = function () {\n\t        var rootStateDef = {\n\t            name: '',\n\t            url: '^',\n\t            views: null,\n\t            params: {\n\t                '#': { value: null, type: 'hash', dynamic: true }\n\t            },\n\t            abstract: true\n\t        };\n\t        var _root = this._root = this.stateQueue.register(rootStateDef);\n\t        _root.navigable = null;\n\t    };\n\t    /** @internalapi */\n\t    StateRegistry.prototype.dispose = function () {\n\t        var _this = this;\n\t        this.stateQueue.dispose();\n\t        this.listeners = [];\n\t        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n\t    };\n\t    /**\n\t     * Listen for a State Registry events\n\t     *\n\t     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let allStates = registry.get();\n\t     *\n\t     * // Later, invoke deregisterFn() to remove the listener\n\t     * let deregisterFn = registry.onStatesChanged((event, states) => {\n\t     *   switch(event) {\n\t     *     case: 'registered':\n\t     *       states.forEach(state => allStates.push(state));\n\t     *       break;\n\t     *     case: 'deregistered':\n\t     *       states.forEach(state => {\n\t     *         let idx = allStates.indexOf(state);\n\t     *         if (idx !== -1) allStates.splice(idx, 1);\n\t     *       });\n\t     *       break;\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param listener a callback function invoked when the registered states changes.\n\t     *        The function receives two parameters, `event` and `state`.\n\t     *        See [[StateRegistryListener]]\n\t     * @return a function that deregisters the listener\n\t     */\n\t    StateRegistry.prototype.onStatesChanged = function (listener) {\n\t        this.listeners.push(listener);\n\t        return function deregisterListener() {\n\t            removeFrom(this.listeners)(listener);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Gets the implicit root state\n\t     *\n\t     * Gets the root of the state tree.\n\t     * The root state is implicitly created by UI-Router.\n\t     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n\t     *\n\t     * @return the root [[StateObject]]\n\t     */\n\t    StateRegistry.prototype.root = function () {\n\t        return this._root;\n\t    };\n\t    /**\n\t     * Adds a state to the registry\n\t     *\n\t     * Registers a [[StateDeclaration]] or queues it for registration.\n\t     *\n\t     * Note: a state will be queued if the state's parent isn't yet registered.\n\t     *\n\t     * @param stateDefinition the definition of the state to register.\n\t     * @returns the internal [[StateObject]] object.\n\t     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n\t     *          If the state was only queued, then the object is not fully built.\n\t     */\n\t    StateRegistry.prototype.register = function (stateDefinition) {\n\t        return this.stateQueue.register(stateDefinition);\n\t    };\n\t    /** @hidden */\n\t    StateRegistry.prototype._deregisterTree = function (state) {\n\t        var _this = this;\n\t        var all$$1 = this.get().map(function (s) { return s.$$state(); });\n\t        var getChildren = function (states) {\n\t            var children = all$$1.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n\t            return children.length === 0 ? children : children.concat(getChildren(children));\n\t        };\n\t        var children = getChildren([state]);\n\t        var deregistered = [state].concat(children).reverse();\n\t        deregistered.forEach(function (state) {\n\t            var $ur = _this._router.urlRouter;\n\t            // Remove URL rule\n\t            $ur.rules().filter(propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n\t            // Remove state from registry\n\t            delete _this.states[state.name];\n\t        });\n\t        return deregistered;\n\t    };\n\t    /**\n\t     * Removes a state from the registry\n\t     *\n\t     * This removes a state from the registry.\n\t     * If the state has children, they are are also removed from the registry.\n\t     *\n\t     * @param stateOrName the state's name or object representation\n\t     * @returns {StateObject[]} a list of removed states\n\t     */\n\t    StateRegistry.prototype.deregister = function (stateOrName) {\n\t        var _state = this.get(stateOrName);\n\t        if (!_state)\n\t            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n\t        var deregisteredStates = this._deregisterTree(_state.$$state());\n\t        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n\t        return deregisteredStates;\n\t    };\n\t    StateRegistry.prototype.get = function (stateOrName, base) {\n\t        var _this = this;\n\t        if (arguments.length === 0)\n\t            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n\t        var found = this.matcher.find(stateOrName, base);\n\t        return found && found.self || null;\n\t    };\n\t    StateRegistry.prototype.decorator = function (name, func) {\n\t        return this.builder.builder(name, func);\n\t    };\n\t    return StateRegistry;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module url\n\t */\n\t/** for typedoc */\n\t/** @hidden */\n\tfunction quoteRegExp(string, param) {\n\t    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!param)\n\t        return result;\n\t    switch (param.squash) {\n\t        case false:\n\t            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n\t            break;\n\t        case true:\n\t            result = result.replace(/\\/$/, '');\n\t            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t            break;\n\t        default:\n\t            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n\t            break;\n\t    }\n\t    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n\t}\n\t/** @hidden */\n\tvar memoizeTo = function (obj, prop$$1, fn) {\n\t    return obj[prop$$1] = obj[prop$$1] || fn();\n\t};\n\t/** @hidden */\n\tvar splitOnSlash = splitOnDelim('/');\n\t/**\n\t * Matches URLs against patterns.\n\t *\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL.\n\t *\n\t * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n\t * parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by [[UrlMatcher.exec]].\n\t *\n\t * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n\t * or colon placeholders (`/somePath/:param`).\n\t *\n\t * - *A parameter RegExp* may be defined for a param after a colon\n\t * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n\t * The regexp must match for the url to be matched.\n\t * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n\t *\n\t * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n\t *   See [[UrlMatcherFactory.type]] for more information.\n\t *\n\t * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n\t *   A catch-all * parameter value will contain the remainder of the URL.\n\t *\n\t * ---\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters).\n\t * A path parameter matches any number of characters other than '/'. For catch-all\n\t * placeholders the path parameter matches any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t */\n\tvar UrlMatcher = (function () {\n\t    /**\n\t     * @param pattern The pattern to compile into a matcher.\n\t     * @param paramTypes The [[ParamTypes]] registry\n\t     * @param config  A configuration object\n\t     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t     */\n\t    function UrlMatcher(pattern$$1, paramTypes, paramFactory, config) {\n\t        var _this = this;\n\t        this.config = config;\n\t        /** @hidden */\n\t        this._cache = { path: [this] };\n\t        /** @hidden */\n\t        this._children = [];\n\t        /** @hidden */\n\t        this._params = [];\n\t        /** @hidden */\n\t        this._segments = [];\n\t        /** @hidden */\n\t        this._compiled = [];\n\t        this.pattern = pattern$$1;\n\t        this.config = defaults(this.config, {\n\t            params: {},\n\t            strict: true,\n\t            caseInsensitive: false,\n\t            paramMap: identity\n\t        });\n\t        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t        //   '*' name\n\t        //   ':' name\n\t        //   '{' name '}'\n\t        //   '{' name ':' regexp '}'\n\t        // The regular expression is somewhat complicated due to the need to allow curly braces\n\t        // inside the regular expression. The placeholder regexp breaks down as follows:\n\t        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t        //    \\\\.                            - a backslash escape\n\t        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n\t        var checkParamErrors = function (id) {\n\t            if (!UrlMatcher.nameValidator.test(id))\n\t                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern$$1 + \"'\");\n\t            if (find(_this._params, propEq('id', id)))\n\t                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern$$1 + \"'\");\n\t        };\n\t        // Split into static segments separated by path parameter placeholders.\n\t        // The number of segments is always 1 more than the number of parameters.\n\t        var matchDetails = function (m, isSearch) {\n\t            // IE[78] returns '' for unmatched groups instead of null\n\t            var id = m[2] || m[3];\n\t            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\\\s\\\\S]*' : null);\n\t            var makeRegexpType = function (regexp) { return inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n\t                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n\t            }); };\n\t            return {\n\t                id: id,\n\t                regexp: regexp,\n\t                cfg: _this.config.params[id],\n\t                segment: pattern$$1.substring(last, m.index),\n\t                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n\t            };\n\t        };\n\t        var p, segment;\n\t        while ((m = placeholder.exec(pattern$$1))) {\n\t            p = matchDetails(m, false);\n\t            if (p.segment.indexOf('?') >= 0)\n\t                break; // we're into the search part\n\t            checkParamErrors(p.id);\n\t            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n\t            this._segments.push(p.segment);\n\t            patterns.push([p.segment, tail(this._params)]);\n\t            last = placeholder.lastIndex;\n\t        }\n\t        segment = pattern$$1.substring(last);\n\t        // Find any search parameter names and remove them from the last segment\n\t        var i = segment.indexOf('?');\n\t        if (i >= 0) {\n\t            var search = segment.substring(i);\n\t            segment = segment.substring(0, i);\n\t            if (search.length > 0) {\n\t                last = 0;\n\t                while ((m = searchPlaceholder.exec(search))) {\n\t                    p = matchDetails(m, true);\n\t                    checkParamErrors(p.id);\n\t                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n\t                    last = placeholder.lastIndex;\n\t                    // check if ?&\n\t                }\n\t            }\n\t        }\n\t        this._segments.push(segment);\n\t        this._compiled = patterns.map(function (pattern$$1) { return quoteRegExp.apply(null, pattern$$1); }).concat(quoteRegExp(segment));\n\t    }\n\t    /**\n\t     * Creates a new concatenated UrlMatcher\n\t     *\n\t     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n\t     *\n\t     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n\t     */\n\t    UrlMatcher.prototype.append = function (url) {\n\t        this._children.push(url);\n\t        url._cache = {\n\t            path: this._cache.path.concat(url),\n\t            parent: this,\n\t            pattern: null,\n\t        };\n\t        return url;\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.prototype.isRoot = function () {\n\t        return this._cache.path[0] === this;\n\t    };\n\t    /** Returns the input pattern string */\n\t    UrlMatcher.prototype.toString = function () {\n\t        return this.pattern;\n\t    };\n\t    /**\n\t     * Tests the specified url/path against this matcher.\n\t     *\n\t     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n\t     * parameter values.  Returns null if the path does not match.\n\t     *\n\t     * The returned object contains the values\n\t     * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t     * they are not present in `search`. This means that search parameters are always treated\n\t     * as optional.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t     *   x: '1', q: 'hello'\n\t     * });\n\t     * // returns { id: 'bob', q: 'hello', r: null }\n\t     * ```\n\t     *\n\t     * @param path    The URL path to match, e.g. `$location.path()`.\n\t     * @param search  URL search parameters, e.g. `$location.search()`.\n\t     * @param hash    URL hash e.g. `$location.hash()`.\n\t     * @param options\n\t     *\n\t     * @returns The captured parameter values.\n\t     */\n\t    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n\t        var _this = this;\n\t        if (search === void 0) { search = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var match = memoizeTo(this._cache, 'pattern', function () {\n\t            return new RegExp([\n\t                '^',\n\t                unnest(_this._cache.path.map(prop('_compiled'))).join(''),\n\t                _this.config.strict === false ? '\\/?' : '',\n\t                '$'\n\t            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n\t        }).exec(path);\n\t        if (!match)\n\t            return null;\n\t        //options = defaults(options, { isolate: false });\n\t        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values$$1 = {};\n\t        if (nPathSegments !== match.length - 1)\n\t            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\t        function decodePathArray(string) {\n\t            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n\t            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n\t            var split = reverseString(string).split(/-(?!\\\\)/);\n\t            var allReversed = map(split, reverseString);\n\t            return map(allReversed, unquoteDashes).reverse();\n\t        }\n\t        for (var i = 0; i < nPathSegments; i++) {\n\t            var param = pathParams[i];\n\t            var value = match[i + 1];\n\t            // if the param value matches a pre-replace pair, replace the value before decoding.\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (value && param.array === true)\n\t                value = decodePathArray(value);\n\t            if (isDefined(value))\n\t                value = param.type.decode(value);\n\t            values$$1[param.id] = param.value(value);\n\t        }\n\t        searchParams.forEach(function (param) {\n\t            var value = search[param.id];\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (isDefined(value))\n\t                value = param.type.decode(value);\n\t            values$$1[param.id] = param.value(value);\n\t        });\n\t        if (hash)\n\t            values$$1[\"#\"] = hash;\n\t        return values$$1;\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n\t     *\n\t     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n\t     *    pattern has no parameters, an empty array is returned.\n\t     */\n\t    UrlMatcher.prototype.parameters = function (opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        if (opts.inherit === false)\n\t            return this._params;\n\t        return unnest(this._cache.path.map(function (matcher) { return matcher._params; }));\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns a single parameter from this UrlMatcher by id\n\t     *\n\t     * @param id\n\t     * @param opts\n\t     * @returns {T|Param|any|boolean|UrlMatcher|null}\n\t     */\n\t    UrlMatcher.prototype.parameter = function (id, opts) {\n\t        var _this = this;\n\t        if (opts === void 0) { opts = {}; }\n\t        var findParam = function () {\n\t            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n\t                var param = _a[_i];\n\t                if (param.id === id)\n\t                    return param;\n\t            }\n\t        };\n\t        var parent = this._cache.parent;\n\t        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n\t    };\n\t    /**\n\t     * Validates the input parameter values against this UrlMatcher\n\t     *\n\t     * Checks an object hash of parameters to validate their correctness according to the parameter\n\t     * types of this `UrlMatcher`.\n\t     *\n\t     * @param params The object hash of parameters to validate.\n\t     * @returns Returns `true` if `params` validates, otherwise `false`.\n\t     */\n\t    UrlMatcher.prototype.validates = function (params) {\n\t        var validParamVal = function (param, val$$1) {\n\t            return !param || param.validates(val$$1);\n\t        };\n\t        params = params || {};\n\t        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n\t        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });\n\t        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(allTrueR, true);\n\t    };\n\t    /**\n\t     * Given a set of parameter values, creates a URL from this UrlMatcher.\n\t     *\n\t     * Creates a URL that matches this pattern by substituting the specified values\n\t     * for the path and search parameters.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t     * // returns '/user/bob?q=yes'\n\t     * ```\n\t     *\n\t     * @param values  the values to substitute for the parameters in this pattern.\n\t     * @returns the formatted URL (path and optionally search part).\n\t     */\n\t    UrlMatcher.prototype.format = function (values$$1) {\n\t        if (values$$1 === void 0) { values$$1 = {}; }\n\t        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\t        var urlMatchers = this._cache.path;\n\t        // Extract all the static segments and Params (processed as ParamDetails)\n\t        // into an ordered array\n\t        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n\t            .reduce(unnestR, [])\n\t            .map(function (x) { return isString(x) ? x : getDetails(x); });\n\t        // Extract the query params into a separate array\n\t        var queryParams = urlMatchers.map(UrlMatcher.queryParams)\n\t            .reduce(unnestR, [])\n\t            .map(getDetails);\n\t        var isInvalid = function (param) { return param.isValid === false; };\n\t        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n\t            return null;\n\t        }\n\t        /**\n\t         * Given a Param, applies the parameter value, then returns detailed information about it\n\t         */\n\t        function getDetails(param) {\n\t            // Normalize to typed value\n\t            var value = param.value(values$$1[param.id]);\n\t            var isValid = param.validates(value);\n\t            var isDefaultValue = param.isDefaultValue(value);\n\t            // Check if we're in squash mode for the parameter\n\t            var squash = isDefaultValue ? param.squash : false;\n\t            // Allow the Parameter's Type to encode the value\n\t            var encoded = param.type.encode(value);\n\t            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n\t        }\n\t        // Build up the path-portion from the list of static segments and parameters\n\t        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n\t            // The element is a static segment (a raw string); just append it\n\t            if (isString(x))\n\t                return acc + x;\n\t            // Otherwise, it's a ParamDetails.\n\t            var squash = x.squash, encoded = x.encoded, param = x.param;\n\t            // If squash is === true, try to remove a slash from the path\n\t            if (squash === true)\n\t                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n\t            // If squash is a string, use the string for the param value\n\t            if (isString(squash))\n\t                return acc + squash;\n\t            if (squash !== false)\n\t                return acc; // ?\n\t            if (encoded == null)\n\t                return acc;\n\t            // If this parameter value is an array, encode the value using encodeDashes\n\t            if (isArray(encoded))\n\t                return acc + map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n\t            // If the parameter type is \"raw\", then do not encodeURIComponent\n\t            if (param.raw)\n\t                return acc + encoded;\n\t            // Encode the value\n\t            return acc + encodeURIComponent(encoded);\n\t        }, \"\");\n\t        // Build the query string by applying parameter values (array or regular)\n\t        // then mapping to key=value, then flattening and joining using \"&\"\n\t        var queryString = queryParams.map(function (paramDetails) {\n\t            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;\n\t            if (encoded == null || (isDefaultValue && squash !== false))\n\t                return;\n\t            if (!isArray(encoded))\n\t                encoded = [encoded];\n\t            if (encoded.length === 0)\n\t                return;\n\t            if (!param.raw)\n\t                encoded = map(encoded, encodeURIComponent);\n\t            return encoded.map(function (val$$1) { return param.id + \"=\" + val$$1; });\n\t        }).filter(identity).reduce(unnestR, []).join(\"&\");\n\t        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\t        return pathString + (queryString ? \"?\" + queryString : \"\") + (values$$1[\"#\"] ? \"#\" + values$$1[\"#\"] : \"\");\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.encodeDashes = function (str) {\n\t        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n\t    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n\t        var staticSegments = matcher._segments;\n\t        var pathParams = matcher._params.filter(function (p) { return p.location === exports.DefType.PATH; });\n\t        return arrayTuples(staticSegments, pathParams.concat(undefined))\n\t            .reduce(unnestR, [])\n\t            .filter(function (x) { return x !== \"\" && isDefined(x); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's query params */\n\t    UrlMatcher.queryParams = function (matcher) {\n\t        return matcher._params.filter(function (p) { return p.location === exports.DefType.SEARCH; });\n\t    };\n\t    /**\n\t     * Compare two UrlMatchers\n\t     *\n\t     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n\t     * Each static path segment is a static string between a path separator (slash character).\n\t     * Each dynamic segment is a path parameter.\n\t     *\n\t     * The comparison function sorts static segments before dynamic ones.\n\t     */\n\t    UrlMatcher.compare = function (a, b) {\n\t        /**\n\t         * Turn a UrlMatcher and all its parent matchers into an array\n\t         * of slash literals '/', string literals, and Param objects\n\t         *\n\t         * This example matcher matches strings like \"/foo/:param/tail\":\n\t         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n\t         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n\t         *\n\t         * Caches the result as `matcher._cache.segments`\n\t         */\n\t        var segments = function (matcher) {\n\t            return matcher._cache.segments = matcher._cache.segments ||\n\t                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n\t                    .reduce(unnestR, [])\n\t                    .reduce(joinNeighborsR, [])\n\t                    .map(function (x) { return isString(x) ? splitOnSlash(x) : x; })\n\t                    .reduce(unnestR, []);\n\t        };\n\t        /**\n\t         * Gets the sort weight for each segment of a UrlMatcher\n\t         *\n\t         * Caches the result as `matcher._cache.weights`\n\t         */\n\t        var weights = function (matcher) {\n\t            return matcher._cache.weights = matcher._cache.weights ||\n\t                segments(matcher).map(function (segment) {\n\t                    // Sort slashes first, then static strings, the Params\n\t                    if (segment === '/')\n\t                        return 1;\n\t                    if (isString(segment))\n\t                        return 2;\n\t                    if (segment instanceof Param)\n\t                        return 3;\n\t                });\n\t        };\n\t        /**\n\t         * Pads shorter array in-place (mutates)\n\t         */\n\t        var padArrays = function (l, r, padVal) {\n\t            var len = Math.max(l.length, r.length);\n\t            while (l.length < len)\n\t                l.push(padVal);\n\t            while (r.length < len)\n\t                r.push(padVal);\n\t        };\n\t        var weightsA = weights(a), weightsB = weights(b);\n\t        padArrays(weightsA, weightsB, 0);\n\t        var cmp, i, pairs$$1 = arrayTuples(weightsA, weightsB);\n\t        for (i = 0; i < pairs$$1.length; i++) {\n\t            cmp = pairs$$1[i][0] - pairs$$1[i][1];\n\t            if (cmp !== 0)\n\t                return cmp;\n\t        }\n\t        return 0;\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\t    return UrlMatcher;\n\t}());\n\t\n\t/**\n\t * @internalapi\n\t * @module url\n\t */ /** for typedoc */\n\t/**\n\t * Factory for [[UrlMatcher]] instances.\n\t *\n\t * The factory is available to ng1 services as\n\t * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n\t */\n\tvar UrlMatcherFactory = (function () {\n\t    function UrlMatcherFactory() {\n\t        var _this = this;\n\t        /** @hidden */ this.paramTypes = new ParamTypes();\n\t        /** @hidden */ this._isCaseInsensitive = false;\n\t        /** @hidden */ this._isStrictMode = true;\n\t        /** @hidden */ this._defaultSquashPolicy = false;\n\t        /** @hidden */\n\t        this._getConfig = function (config) {\n\t            return extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n\t        };\n\t        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n\t        this.paramFactory = {\n\t            /** Creates a new [[Param]] from a CONFIG block */\n\t            fromConfig: function (id, type, config) {\n\t                return new Param(id, type, config, exports.DefType.CONFIG, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url PATH */\n\t            fromPath: function (id, type, config) {\n\t                return new Param(id, type, config, exports.DefType.PATH, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url SEARCH */\n\t            fromSearch: function (id, type, config) {\n\t                return new Param(id, type, config, exports.DefType.SEARCH, _this);\n\t            },\n\t        };\n\t        extend(this, { UrlMatcher: UrlMatcher, Param: Param });\n\t    }\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n\t        return this._isCaseInsensitive = isDefined(value) ? value : this._isCaseInsensitive;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.strictMode = function (value) {\n\t        return this._isStrictMode = isDefined(value) ? value : this._isStrictMode;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n\t        if (isDefined(value) && value !== true && value !== false && !isString(value))\n\t            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t        return this._defaultSquashPolicy = isDefined(value) ? value : this._defaultSquashPolicy;\n\t    };\n\t    /**\n\t     * Creates a [[UrlMatcher]] for the specified pattern.\n\t     *\n\t     * @param pattern  The URL pattern.\n\t     * @param config  The config object hash.\n\t     * @returns The UrlMatcher.\n\t     */\n\t    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n\t        return new UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n\t    };\n\t    /**\n\t     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n\t     *\n\t     * @param object  The object to perform the type check against.\n\t     * @returns `true` if the object matches the `UrlMatcher` interface, by\n\t     *          implementing all the same methods.\n\t     */\n\t    UrlMatcherFactory.prototype.isMatcher = function (object) {\n\t        // TODO: typeof?\n\t        if (!isObject(object))\n\t            return false;\n\t        var result = true;\n\t        forEach(UrlMatcher.prototype, function (val, name) {\n\t            if (isFunction(val))\n\t                result = result && (isDefined(object[name]) && isFunction(object[name]));\n\t        });\n\t        return result;\n\t    };\n\t    \n\t    /**\n\t     * Creates and registers a custom [[ParamType]] object\n\t     *\n\t     * A [[ParamType]] can be used to generate URLs with typed parameters.\n\t     *\n\t     * @param name  The type name.\n\t     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n\t     * @param definitionFn A function that is injected before the app runtime starts.\n\t     *        The result of this function should be a [[ParamTypeDefinition]].\n\t     *        The result is merged into the existing `definition`.\n\t     *        See [[ParamType]] for information on the values accepted.\n\t     *\n\t     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n\t     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n\t     *\n\t     * Note: Register custom types *before using them* in a state definition.\n\t     *\n\t     * See [[ParamTypeDefinition]] for examples\n\t     */\n\t    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n\t        var type = this.paramTypes.type(name, definition, definitionFn);\n\t        return !isDefined(definition) ? type : this;\n\t    };\n\t    \n\t    /** @hidden */\n\t    UrlMatcherFactory.prototype.$get = function () {\n\t        this.paramTypes.enqueue = false;\n\t        this.paramTypes._flushTypeQueue();\n\t        return this;\n\t    };\n\t    \n\t    /** @internalapi */\n\t    UrlMatcherFactory.prototype.dispose = function () {\n\t        this.paramTypes.dispose();\n\t    };\n\t    return UrlMatcherFactory;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\t/**\n\t * Creates a [[UrlRule]]\n\t *\n\t * Creates a [[UrlRule]] from a:\n\t *\n\t * - `string`\n\t * - [[UrlMatcher]]\n\t * - `RegExp`\n\t * - [[StateObject]]\n\t * @internalapi\n\t */\n\tvar UrlRuleFactory = (function () {\n\t    function UrlRuleFactory(router) {\n\t        this.router = router;\n\t    }\n\t    UrlRuleFactory.prototype.compile = function (str) {\n\t        return this.router.urlMatcherFactory.compile(str);\n\t    };\n\t    UrlRuleFactory.prototype.create = function (what, handler) {\n\t        var _this = this;\n\t        var makeRule = pattern([\n\t            [isString, function (_what) { return makeRule(_this.compile(_what)); }],\n\t            [is(UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n\t            [isState, function (_what) { return _this.fromState(_what, _this.router); }],\n\t            [is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n\t            [isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n\t        ]);\n\t        var rule = makeRule(what);\n\t        if (!rule)\n\t            throw new Error(\"invalid 'what' in when()\");\n\t        return rule;\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a UrlMatcher\n\t     *\n\t     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     *\n\t     * ## Handler as UrlMatcher\n\t     *\n\t     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n\t     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n\t     * The url is replaced with the result.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n\t        var _handler = handler;\n\t        if (isString(handler))\n\t            handler = this.router.urlMatcherFactory.compile(handler);\n\t        if (is(UrlMatcher)(handler))\n\t            _handler = function (match) { return handler.format(match); };\n\t        function match(url) {\n\t            var match = urlMatcher.exec(url.path, url.search, url.hash);\n\t            return urlMatcher.validates(match) && match;\n\t        }\n\t        // Prioritize URLs, lowest to highest:\n\t        // - Some optional URL parameters, but none matched\n\t        // - No optional parameters in URL\n\t        // - Some optional parameters, some matched\n\t        // - Some optional parameters, all matched\n\t        function matchPriority(params) {\n\t            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n\t            if (!optional.length)\n\t                return 0.000001;\n\t            var matched = optional.filter(function (param) { return params[param.id]; });\n\t            return matched.length / optional.length;\n\t        }\n\t        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n\t        return extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches a state by its url\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromState($state.get('foo'), router);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match);\n\t     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromState = function (state, router) {\n\t        /**\n\t         * Handles match by transitioning to matched state\n\t         *\n\t         * First checks if the router should start a new transition.\n\t         * A new transition is not required if the current state's URL\n\t         * and the new URL are already identical\n\t         */\n\t        var handler = function (match) {\n\t            var $state = router.stateService;\n\t            var globals = router.globals;\n\t            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n\t                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n\t            }\n\t        };\n\t        var details = { state: state, type: \"STATE\" };\n\t        return extend(this.fromUrlMatcher(state.url, handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a regular expression\n\t     *\n\t     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - regexp match array (from `regexp`)\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     *\n\t     * ## Handler as string\n\t     *\n\t     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n\t     * The string is first interpolated using `string.replace()` style pattern.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n\t        if (regexp.global || regexp.sticky)\n\t            throw new Error(\"Rule RegExp must not be global or sticky\");\n\t        /**\n\t         * If handler is a string, the url will be replaced by the string.\n\t         * If the string has any String.replace() style variables in it (like `$2`),\n\t         * they will be replaced by the captures from [[match]]\n\t         */\n\t        var redirectUrlTo = function (match) {\n\t            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n\t            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t                return match[what === '$' ? 0 : Number(what)];\n\t            });\n\t        };\n\t        var _handler = isString(handler) ? redirectUrlTo : handler;\n\t        var match = function (url) {\n\t            return regexp.exec(url.path);\n\t        };\n\t        var details = { regexp: regexp, type: \"REGEXP\" };\n\t        return extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    UrlRuleFactory.isUrlRule = function (obj) {\n\t        return obj && ['type', 'match', 'handler'].every(function (key) { return isDefined(obj[key]); });\n\t    };\n\t    return UrlRuleFactory;\n\t}());\n\t/**\n\t * A base rule which calls `match`\n\t *\n\t * The value from the `match` function is passed through to the `handler`.\n\t * @internalapi\n\t */\n\tvar BaseUrlRule = (function () {\n\t    function BaseUrlRule(match, handler) {\n\t        var _this = this;\n\t        this.match = match;\n\t        this.type = \"RAW\";\n\t        this.matchPriority = function (match) { return 0 - _this.$id; };\n\t        this.handler = handler || identity;\n\t    }\n\t    return BaseUrlRule;\n\t}());\n\t\n\t/**\n\t * @internalapi\n\t * @module url\n\t */\n\t/** for typedoc */\n\t/** @hidden */\n\tfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n\t    if (baseHref === '/')\n\t        return url;\n\t    if (isHtml5)\n\t        return baseHref.slice(0, -1) + url;\n\t    if (absolute)\n\t        return baseHref.slice(1) + url;\n\t    return url;\n\t}\n\t/** @hidden */\n\tvar prioritySort = function (a, b) {\n\t    return (b.priority || 0) - (a.priority || 0);\n\t};\n\t/** @hidden */\n\tvar typeSort = function (a, b) {\n\t    var weights = { \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 };\n\t    return (weights[a.type] || 0) - (weights[b.type] || 0);\n\t};\n\t/** @hidden */\n\tvar urlMatcherSort = function (a, b) {\n\t    return !a.urlMatcher || !b.urlMatcher ? 0 : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);\n\t};\n\t/** @hidden */\n\tvar idSort = function (a, b) {\n\t    // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL\n\t    var useMatchPriority = { STATE: true, URLMATCHER: true };\n\t    var equal = useMatchPriority[a.type] && useMatchPriority[b.type];\n\t    return equal ? 0 : (a.$id || 0) - (b.$id || 0);\n\t};\n\t/**\n\t * Default rule priority sorting function.\n\t *\n\t * Sorts rules by:\n\t *\n\t * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n\t * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n\t * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n\t * - Rule registration order (for rule types other than STATE and URLMATCHER)\n\t *   - Equally sorted State and UrlMatcher rules will each match the URL.\n\t *     Then, the *best* match is chosen based on how many parameter values were matched.\n\t *\n\t * @coreapi\n\t */\n\tvar defaultRuleSortFn;\n\tdefaultRuleSortFn = function (a, b) {\n\t    var cmp = prioritySort(a, b);\n\t    if (cmp !== 0)\n\t        return cmp;\n\t    cmp = typeSort(a, b);\n\t    if (cmp !== 0)\n\t        return cmp;\n\t    cmp = urlMatcherSort(a, b);\n\t    if (cmp !== 0)\n\t        return cmp;\n\t    return idSort(a, b);\n\t};\n\t/**\n\t * Updates URL and responds to URL changes\n\t *\n\t * ### Deprecation warning:\n\t * This class is now considered to be an internal API\n\t * Use the [[UrlService]] instead.\n\t * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n\t *\n\t * This class updates the URL when the state changes.\n\t * It also responds to changes in the URL.\n\t */\n\tvar UrlRouter = (function () {\n\t    /** @hidden */\n\t    function UrlRouter(router) {\n\t        /** @hidden */ this._sortFn = defaultRuleSortFn;\n\t        /** @hidden */ this._rules = [];\n\t        /** @hidden */ this.interceptDeferred = false;\n\t        /** @hidden */ this._id = 0;\n\t        /** @hidden */ this._sorted = false;\n\t        this._router = router;\n\t        this.urlRuleFactory = new UrlRuleFactory(router);\n\t        createProxyFunctions(val(UrlRouter.prototype), this, val(this));\n\t    }\n\t    /** @internalapi */\n\t    UrlRouter.prototype.dispose = function () {\n\t        this.listen(false);\n\t        this._rules = [];\n\t        delete this._otherwiseFn;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sort = function (compareFn) {\n\t        this._rules = this.stableSort(this._rules, this._sortFn = compareFn || this._sortFn);\n\t        this._sorted = true;\n\t    };\n\t    UrlRouter.prototype.ensureSorted = function () {\n\t        this._sorted || this.sort();\n\t    };\n\t    UrlRouter.prototype.stableSort = function (arr, compareFn) {\n\t        var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });\n\t        arrOfWrapper.sort(function (wrapperA, wrapperB) {\n\t            var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);\n\t            return cmpDiff === 0\n\t                ? wrapperA.idx - wrapperB.idx\n\t                : cmpDiff;\n\t        });\n\t        return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });\n\t    };\n\t    /**\n\t     * Given a URL, check all rules and return the best [[MatchResult]]\n\t     * @param url\n\t     * @returns {MatchResult}\n\t     */\n\t    UrlRouter.prototype.match = function (url) {\n\t        var _this = this;\n\t        this.ensureSorted();\n\t        url = extend({ path: '', search: {}, hash: '' }, url);\n\t        var rules = this.rules();\n\t        if (this._otherwiseFn)\n\t            rules.push(this._otherwiseFn);\n\t        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n\t        var checkRule = function (rule) {\n\t            var match = rule.match(url, _this._router);\n\t            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n\t        };\n\t        // The rules are pre-sorted.\n\t        // - Find the first matching rule.\n\t        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n\t        // - Choose the rule with the highest match weight.\n\t        var best;\n\t        for (var i = 0; i < rules.length; i++) {\n\t            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n\t            if (best && this._sortFn(rules[i], best.rule) !== 0)\n\t                break;\n\t            var current = checkRule(rules[i]);\n\t            // Pick the best MatchResult\n\t            best = (!best || current && current.weight > best.weight) ? current : best;\n\t        }\n\t        return best;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sync = function (evt) {\n\t        if (evt && evt.defaultPrevented)\n\t            return;\n\t        var router = this._router, $url = router.urlService, $state = router.stateService;\n\t        var url = {\n\t            path: $url.path(), search: $url.search(), hash: $url.hash(),\n\t        };\n\t        var best = this.match(url);\n\t        var applyResult = pattern([\n\t            [isString, function (newurl) { return $url.url(newurl, true); }],\n\t            [TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n\t            [is(TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n\t        ]);\n\t        applyResult(best && best.rule.handler(best.match, url, router));\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.listen = function (enabled) {\n\t        var _this = this;\n\t        if (enabled === false) {\n\t            this._stopFn && this._stopFn();\n\t            delete this._stopFn;\n\t        }\n\t        else {\n\t            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n\t        }\n\t    };\n\t    /**\n\t     * Internal API.\n\t     * @internalapi\n\t     */\n\t    UrlRouter.prototype.update = function (read) {\n\t        var $url = this._router.locationService;\n\t        if (read) {\n\t            this.location = $url.path();\n\t            return;\n\t        }\n\t        if ($url.path() === this.location)\n\t            return;\n\t        $url.url(this.location, true);\n\t    };\n\t    /**\n\t     * Internal API.\n\t     *\n\t     * Pushes a new location to the browser history.\n\t     *\n\t     * @internalapi\n\t     * @param urlMatcher\n\t     * @param params\n\t     * @param options\n\t     */\n\t    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n\t        var replace = options && !!options.replace;\n\t        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n\t    };\n\t    /**\n\t     * Builds and returns a URL with interpolated parameters\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * matcher = $umf.compile(\"/about/:person\");\n\t     * params = { person: \"bob\" };\n\t     * $bob = $urlRouter.href(matcher, params);\n\t     * // $bob == \"/about/bob\";\n\t     * ```\n\t     *\n\t     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n\t     * @param params An object of parameter values to fill the matcher's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t     */\n\t    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n\t        var url = urlMatcher.format(params);\n\t        if (url == null)\n\t            return null;\n\t        options = options || { absolute: false };\n\t        var cfg = this._router.urlService.config;\n\t        var isHtml5 = cfg.html5Mode();\n\t        if (!isHtml5 && url !== null) {\n\t            url = \"#\" + cfg.hashPrefix() + url;\n\t        }\n\t        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n\t        if (!options.absolute || !url) {\n\t            return url;\n\t        }\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n\t    };\n\t    /**\n\t     * Manually adds a URL Rule.\n\t     *\n\t     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n\t     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n\t     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n\t     *\n\t     * A rule should have a `match` function which returns truthy if the rule matched.\n\t     * It should also have a `handler` function which is invoked if the rule is the best match.\n\t     *\n\t     * @return a function that deregisters the rule\n\t     */\n\t    UrlRouter.prototype.rule = function (rule) {\n\t        var _this = this;\n\t        if (!UrlRuleFactory.isUrlRule(rule))\n\t            throw new Error(\"invalid rule\");\n\t        rule.$id = this._id++;\n\t        rule.priority = rule.priority || 0;\n\t        this._rules.push(rule);\n\t        this._sorted = false;\n\t        return function () { return _this.removeRule(rule); };\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.removeRule = function (rule) {\n\t        removeFrom(this._rules, rule);\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.rules = function () {\n\t        this.ensureSorted();\n\t        return this._rules.slice();\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.otherwise = function (handler) {\n\t        var handlerFn = getHandlerFn(handler);\n\t        this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);\n\t        this._sorted = false;\n\t    };\n\t    \n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.initial = function (handler) {\n\t        var handlerFn = getHandlerFn(handler);\n\t        var matchFn = function (urlParts, router) {\n\t            return router.globals.transitionHistory.size() === 0 && !!/^\\/?$/.exec(urlParts.path);\n\t        };\n\t        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));\n\t    };\n\t    \n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.when = function (matcher, handler, options) {\n\t        var rule = this.urlRuleFactory.create(matcher, handler);\n\t        if (isDefined(options && options.priority))\n\t            rule.priority = options.priority;\n\t        this.rule(rule);\n\t        return rule;\n\t    };\n\t    \n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.deferIntercept = function (defer) {\n\t        if (defer === undefined)\n\t            defer = true;\n\t        this.interceptDeferred = defer;\n\t    };\n\t    \n\t    return UrlRouter;\n\t}());\n\tfunction getHandlerFn(handler) {\n\t    if (!isFunction(handler) && !isString(handler) && !is(TargetState)(handler) && !TargetState.isDef(handler)) {\n\t        throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n\t    }\n\t    return isFunction(handler) ? handler : val(handler);\n\t}\n\t\n\t/**\n\t * @coreapi\n\t * @module view\n\t */ /** for typedoc */\n\t/**\n\t * The View service\n\t *\n\t * This service pairs existing `ui-view` components (which live in the DOM)\n\t * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n\t *\n\t * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n\t *   The views from exited states are deactivated via [[deactivateViewConfig]].\n\t *   (See: the [[registerActivateViews]] Transition Hook)\n\t *\n\t * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n\t *\n\t * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n\t * are configured with the matching [[ViewConfig]](s)\n\t *\n\t */\n\tvar ViewService = (function () {\n\t    function ViewService() {\n\t        var _this = this;\n\t        this._uiViews = [];\n\t        this._viewConfigs = [];\n\t        this._viewConfigFactories = {};\n\t        this._pluginapi = {\n\t            _rootViewContext: this._rootViewContext.bind(this),\n\t            _viewConfigFactory: this._viewConfigFactory.bind(this),\n\t            _registeredUIViews: function () { return _this._uiViews; },\n\t            _activeViewConfigs: function () { return _this._viewConfigs; },\n\t        };\n\t    }\n\t    ViewService.prototype._rootViewContext = function (context) {\n\t        return this._rootContext = context || this._rootContext;\n\t    };\n\t    \n\t    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n\t        this._viewConfigFactories[viewType] = factory;\n\t    };\n\t    ViewService.prototype.createViewConfig = function (path, decl) {\n\t        var cfgFactory = this._viewConfigFactories[decl.$type];\n\t        if (!cfgFactory)\n\t            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n\t        var cfgs = cfgFactory(path, decl);\n\t        return isArray(cfgs) ? cfgs : [cfgs];\n\t    };\n\t    /**\n\t     * Deactivates a ViewConfig.\n\t     *\n\t     * This function deactivates a `ViewConfig`.\n\t     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n\t     *\n\t     * @param viewConfig The ViewConfig view to deregister.\n\t     */\n\t    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n\t        trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n\t        removeFrom(this._viewConfigs, viewConfig);\n\t    };\n\t    ViewService.prototype.activateViewConfig = function (viewConfig) {\n\t        trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n\t        this._viewConfigs.push(viewConfig);\n\t    };\n\t    ViewService.prototype.sync = function () {\n\t        var _this = this;\n\t        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(applyPairs, {});\n\t        // Return a weighted depth value for a uiView.\n\t        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)\n\t        // plus the depth of the state that is populating the uiView\n\t        function uiViewDepth(uiView) {\n\t            var stateDepth = function (context) {\n\t                return context && context.parent ? stateDepth(context.parent) + 1 : 1;\n\t            };\n\t            return (uiView.fqn.split(\".\").length * 10000) + stateDepth(uiView.creationContext);\n\t        }\n\t        // Return the ViewConfig's context's depth in the context tree.\n\t        function viewConfigDepth(config) {\n\t            var context = config.viewDecl.$context, count = 0;\n\t            while (++count && context.parent)\n\t                context = context.parent;\n\t            return count;\n\t        }\n\t        // Given a depth function, returns a compare function which can return either ascending or descending order\n\t        var depthCompare = curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n\t        var matchingConfigPair = function (uiView) {\n\t            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n\t            if (matchingConfigs.length > 1) {\n\t                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n\t                // Sort by depth and return the match from the deepest child\n\t                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n\t                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n\t            }\n\t            return [uiView, matchingConfigs[0]];\n\t        };\n\t        var configureUIView = function (_a) {\n\t            var uiView = _a[0], viewConfig = _a[1];\n\t            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n\t            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n\t            if (_this._uiViews.indexOf(uiView) !== -1)\n\t                uiView.configUpdated(viewConfig);\n\t        };\n\t        // Sort views by FQN and state depth. Process uiviews nearest the root first.\n\t        var pairs$$1 = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);\n\t        trace.traceViewSync(pairs$$1);\n\t        pairs$$1.forEach(configureUIView);\n\t    };\n\t    \n\t    /**\n\t     * Registers a `ui-view` component\n\t     *\n\t     * When a `ui-view` component is created, it uses this method to register itself.\n\t     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n\t     *\n\t     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n\t     * and what the view's state context is.\n\t     *\n\t     * Note: There is no corresponding `deregisterUIView`.\n\t     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n\t     *\n\t     * @param uiView The metadata for a UIView\n\t     * @return a de-registration function used when the view is destroyed.\n\t     */\n\t    ViewService.prototype.registerUIView = function (uiView) {\n\t        trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n\t        var uiViews = this._uiViews;\n\t        var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };\n\t        if (uiViews.filter(fqnAndTypeMatches).length)\n\t            trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n\t        uiViews.push(uiView);\n\t        this.sync();\n\t        return function () {\n\t            var idx = uiViews.indexOf(uiView);\n\t            if (idx === -1) {\n\t                trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n\t                return;\n\t            }\n\t            trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n\t            removeFrom(uiViews)(uiView);\n\t        };\n\t    };\n\t    \n\t    /**\n\t     * Returns the list of views currently available on the page, by fully-qualified name.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.available = function () {\n\t        return this._uiViews.map(prop(\"fqn\"));\n\t    };\n\t    /**\n\t     * Returns the list of views on the page containing loaded content.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.active = function () {\n\t        return this._uiViews.filter(prop(\"$config\")).map(prop(\"name\"));\n\t    };\n\t    /**\n\t     * Normalizes a view's name from a state.views configuration block.\n\t     *\n\t     * This should be used by a framework implementation to calculate the values for\n\t     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n\t     *\n\t     * @param context the context object (state declaration) that the view belongs to\n\t     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n\t     *\n\t     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n\t     */\n\t    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n\t        if (rawViewName === void 0) { rawViewName = \"\"; }\n\t        // TODO: Validate incoming view name with a regexp to allow:\n\t        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n\t        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n\t        var viewAtContext = rawViewName.split(\"@\");\n\t        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\t        var uiViewContextAnchor = isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n\t        // Handle relative view-name sugar syntax.\n\t        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n\t        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n\t        if (relativeViewNameSugar) {\n\t            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n\t            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n\t            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n\t        }\n\t        if (uiViewName.charAt(0) === '!') {\n\t            uiViewName = uiViewName.substr(1);\n\t            uiViewContextAnchor = \"\"; // target absolutely from root\n\t        }\n\t        // handle parent relative targeting \"^.^.^\"\n\t        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\t        if (relativeMatch.exec(uiViewContextAnchor)) {\n\t            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n\t            uiViewContextAnchor = anchor.name;\n\t        }\n\t        else if (uiViewContextAnchor === '.') {\n\t            uiViewContextAnchor = context.name;\n\t        }\n\t        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n\t    };\n\t    /**\n\t     * Given a ui-view and a ViewConfig, determines if they \"match\".\n\t     *\n\t     * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n\t     * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n\t     *\n\t     * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n\t     * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n\t     *\n\t     * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n\t     *\n\t     * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n\t     * - the ui-view's name matches the ViewConfig's target name\n\t     * - the ui-view's context matches the ViewConfig's anchor\n\t     *\n\t     * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n\t     * - There exists a parent ui-view where:\n\t     *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n\t     *    - the parent ui-view's context matches the ViewConfig's anchor\n\t     * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n\t     *\n\t     * Example:\n\t     *\n\t     * DOM:\n\t     * <ui-view>                        <!-- created in the root context (name: \"\") -->\n\t     *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n\t     *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n\t     *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n\t     *       </ui-view>\n\t     *     </ui-view>\n\t     *   </ui-view>\n\t     * </ui-view>\n\t     *\n\t     * uiViews: [\n\t     *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n\t     *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n\t     *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n\t     *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n\t     * ]\n\t     *\n\t     * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n\t     *\n\t     * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n\t     * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n\t     * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n\t     * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n\t     *\n\t     * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n\t     * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n\t     * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n\t     *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n\t     *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n\t     * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n\t     *   the tail of the ui-view's fqn \"default.bar\"\n\t     *\n\t     * @internalapi\n\t     */\n\t    ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n\t        // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n\t        if (uiView.$type !== viewConfig.viewDecl.$type)\n\t            return false;\n\t        // Split names apart from both viewConfig and uiView into segments\n\t        var vc = viewConfig.viewDecl;\n\t        var vcSegments = vc.$uiViewName.split(\".\");\n\t        var uivSegments = uiView.fqn.split(\".\");\n\t        // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n\t        // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n\t        if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n\t            return false;\n\t        // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n\t        // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n\t        var negOffset = (1 - vcSegments.length) || undefined;\n\t        var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\t        var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n\t        return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n\t    }; };\n\t    return ViewService;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\t/**\n\t * Global router state\n\t *\n\t * This is where we hold the global mutable state such as current state, current\n\t * params, current transition, etc.\n\t */\n\tvar UIRouterGlobals = (function () {\n\t    function UIRouterGlobals() {\n\t        /**\n\t         * Current parameter values\n\t         *\n\t         * The parameter values from the latest successful transition\n\t         */\n\t        this.params = new StateParams();\n\t        /** @internalapi */\n\t        this.lastStartedTransitionId = -1;\n\t        /** @internalapi */\n\t        this.transitionHistory = new Queue([], 1);\n\t        /** @internalapi */\n\t        this.successfulTransitions = new Queue([], 1);\n\t    }\n\t    UIRouterGlobals.prototype.dispose = function () {\n\t        this.transitionHistory.clear();\n\t        this.successfulTransitions.clear();\n\t        this.transition = null;\n\t    };\n\t    return UIRouterGlobals;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\t/** @hidden */\n\tvar makeStub = function (keys) {\n\t    return keys.reduce(function (acc, key) { return (acc[key] = notImplemented(key), acc); }, { dispose: noop });\n\t};\n\t/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n\t/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n\t/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n\t/** @hidden */ var rulesFns = [\"sort\", \"when\", \"initial\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n\t/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n\t/**\n\t * API for URL management\n\t */\n\tvar UrlService = (function () {\n\t    /** @hidden */\n\t    function UrlService(router, lateBind) {\n\t        if (lateBind === void 0) { lateBind = true; }\n\t        this.router = router;\n\t        this.rules = {};\n\t        this.config = {};\n\t        // proxy function calls from UrlService to the LocationService/LocationConfig\n\t        var locationServices = function () { return router.locationService; };\n\t        createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n\t        var locationConfig = function () { return router.locationConfig; };\n\t        createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n\t        var umf = function () { return router.urlMatcherFactory; };\n\t        createProxyFunctions(umf, this.config, umf, umfFns);\n\t        var urlRouter = function () { return router.urlRouter; };\n\t        createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n\t        createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n\t    }\n\t    UrlService.prototype.url = function (newurl, replace, state) { return; };\n\t    \n\t    /** @inheritdoc */\n\t    UrlService.prototype.path = function () { return; };\n\t    \n\t    /** @inheritdoc */\n\t    UrlService.prototype.search = function () { return; };\n\t    \n\t    /** @inheritdoc */\n\t    UrlService.prototype.hash = function () { return; };\n\t    \n\t    /** @inheritdoc */\n\t    UrlService.prototype.onChange = function (callback) { return; };\n\t    \n\t    /**\n\t     * Returns the current URL parts\n\t     *\n\t     * This method returns the current URL components as a [[UrlParts]] object.\n\t     *\n\t     * @returns the current url parts\n\t     */\n\t    UrlService.prototype.parts = function () {\n\t        return { path: this.path(), search: this.search(), hash: this.hash() };\n\t    };\n\t    UrlService.prototype.dispose = function () { };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.sync = function (evt) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.listen = function (enabled) { return; };\n\t    \n\t    /** @inheritdoc */\n\t    UrlService.prototype.deferIntercept = function (defer) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.match = function (urlParts) { return; };\n\t    /** @hidden */\n\t    UrlService.locationServiceStub = makeStub(locationServicesFns);\n\t    /** @hidden */\n\t    UrlService.locationConfigStub = makeStub(locationConfigFns);\n\t    return UrlService;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\t/** @hidden */\n\tvar _routerInstance = 0;\n\t/**\n\t * The master class used to instantiate an instance of UI-Router.\n\t *\n\t * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n\t * This class instantiates and wires the UI-Router services together.\n\t *\n\t * After a new instance of the UIRouter class is created, it should be configured for your app.\n\t * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n\t *\n\t * ---\n\t *\n\t * Normally the framework code will bootstrap UI-Router.\n\t * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n\t * [[UrlService.listen]] then [[UrlService.sync]].\n\t */\n\tvar UIRouter = (function () {\n\t    /**\n\t     * Creates a new `UIRouter` object\n\t     *\n\t     * @param locationService a [[LocationServices]] implementation\n\t     * @param locationConfig a [[LocationConfig]] implementation\n\t     * @internalapi\n\t     */\n\t    function UIRouter(locationService, locationConfig) {\n\t        if (locationService === void 0) { locationService = UrlService.locationServiceStub; }\n\t        if (locationConfig === void 0) { locationConfig = UrlService.locationConfigStub; }\n\t        this.locationService = locationService;\n\t        this.locationConfig = locationConfig;\n\t        /** @hidden */ this.$id = _routerInstance++;\n\t        /** @hidden */ this._disposed = false;\n\t        /** @hidden */ this._disposables = [];\n\t        /** Provides trace information to the console */\n\t        this.trace = trace;\n\t        /** Provides services related to ui-view synchronization */\n\t        this.viewService = new ViewService();\n\t        /** Provides services related to Transitions */\n\t        this.transitionService = new TransitionService(this);\n\t        /** Global router state */\n\t        this.globals = new UIRouterGlobals();\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated Use [[urlService]] instead\n\t         */\n\t        this.urlMatcherFactory = new UrlMatcherFactory();\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated Use [[urlService]] instead\n\t         */\n\t        this.urlRouter = new UrlRouter(this);\n\t        /** Provides a registry for states, and related registration services */\n\t        this.stateRegistry = new StateRegistry(this);\n\t        /** Provides services related to states */\n\t        this.stateService = new StateService(this);\n\t        /** Provides services related to the URL */\n\t        this.urlService = new UrlService(this);\n\t        /** @hidden */\n\t        this._plugins = {};\n\t        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n\t        this.globals.$current = this.stateRegistry.root();\n\t        this.globals.current = this.globals.$current.self;\n\t        this.disposable(this.globals);\n\t        this.disposable(this.stateService);\n\t        this.disposable(this.stateRegistry);\n\t        this.disposable(this.transitionService);\n\t        this.disposable(this.urlRouter);\n\t        this.disposable(locationService);\n\t        this.disposable(locationConfig);\n\t    }\n\t    /** Registers an object to be notified when the router is disposed */\n\t    UIRouter.prototype.disposable = function (disposable) {\n\t        this._disposables.push(disposable);\n\t    };\n\t    /**\n\t     * Disposes this router instance\n\t     *\n\t     * When called, clears resources retained by the router by calling `dispose(this)` on all\n\t     * registered [[disposable]] objects.\n\t     *\n\t     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n\t     *\n\t     * @param disposable (optional) the disposable to dispose\n\t     */\n\t    UIRouter.prototype.dispose = function (disposable) {\n\t        var _this = this;\n\t        if (disposable && isFunction(disposable.dispose)) {\n\t            disposable.dispose(this);\n\t            return undefined;\n\t        }\n\t        this._disposed = true;\n\t        this._disposables.slice().forEach(function (d) {\n\t            try {\n\t                typeof d.dispose === 'function' && d.dispose(_this);\n\t                removeFrom(_this._disposables, d);\n\t            }\n\t            catch (ignored) { }\n\t        });\n\t    };\n\t    /**\n\t     * Adds a plugin to UI-Router\n\t     *\n\t     * This method adds a UI-Router Plugin.\n\t     * A plugin can enhance or change UI-Router behavior using any public API.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n\t     *\n\t     * var plugin = router.addPlugin(MyCoolPlugin);\n\t     * ```\n\t     *\n\t     * ### Plugin authoring\n\t     *\n\t     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n\t     *\n\t     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n\t     * For example, it may configure router options or add a Transition Hook.\n\t     *\n\t     * The plugin can then be published as a separate module.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * export class MyAuthPlugin implements UIRouterPlugin {\n\t     *   constructor(router: UIRouter, options: any) {\n\t     *     this.name = \"MyAuthPlugin\";\n\t     *     let $transitions = router.transitionService;\n\t     *     let $state = router.stateService;\n\t     *\n\t     *     let authCriteria = {\n\t     *       to: (state) => state.data && state.data.requiresAuth\n\t     *     };\n\t     *\n\t     *     function authHook(transition: Transition) {\n\t     *       let authService = transition.injector().get('AuthService');\n\t     *       if (!authService.isAuthenticated()) {\n\t     *         return $state.target('login');\n\t     *       }\n\t     *     }\n\t     *\n\t     *     $transitions.onStart(authCriteria, authHook);\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @param plugin one of:\n\t     *        - a plugin class which implements [[UIRouterPlugin]]\n\t     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n\t     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n\t     * @param options options to pass to the plugin class/factory\n\t     * @returns the registered plugin instance\n\t     */\n\t    UIRouter.prototype.plugin = function (plugin, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var pluginInstance = new plugin(this, options);\n\t        if (!pluginInstance.name)\n\t            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n\t        this._disposables.push(pluginInstance);\n\t        return this._plugins[pluginInstance.name] = pluginInstance;\n\t    };\n\t    UIRouter.prototype.getPlugin = function (pluginName) {\n\t        return pluginName ? this._plugins[pluginName] : values(this._plugins);\n\t    };\n\t    return UIRouter;\n\t}());\n\t\n\t/** @module hooks */ /** */\n\tfunction addCoreResolvables(trans) {\n\t    trans.addResolvable({ token: UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, \"\");\n\t    trans.addResolvable({ token: Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n\t    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n\t    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, \"\");\n\t    trans.entering().forEach(function (state) {\n\t        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);\n\t    });\n\t}\n\tvar registerAddCoreResolvables = function (transitionService) {\n\t    return transitionService.onCreate({}, addCoreResolvables);\n\t};\n\t\n\t/** @module hooks */ /** */\n\t/**\n\t * A [[TransitionHookFn]] that redirects to a different state or params\n\t *\n\t * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n\t *\n\t * See [[StateDeclaration.redirectTo]]\n\t */\n\tvar redirectToHook = function (trans) {\n\t    var redirect = trans.to().redirectTo;\n\t    if (!redirect)\n\t        return;\n\t    var $state = trans.router.stateService;\n\t    function handleResult(result) {\n\t        if (!result)\n\t            return;\n\t        if (result instanceof TargetState)\n\t            return result;\n\t        if (isString(result))\n\t            return $state.target(result, trans.params(), trans.options());\n\t        if (result['state'] || result['params'])\n\t            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n\t    }\n\t    if (isFunction(redirect)) {\n\t        return services.$q.when(redirect(trans)).then(handleResult);\n\t    }\n\t    return handleResult(redirect);\n\t};\n\tvar registerRedirectToHook = function (transitionService) {\n\t    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n\t};\n\t\n\t/**\n\t * A factory which creates an onEnter, onExit or onRetain transition hook function\n\t *\n\t * The returned function invokes the (for instance) state.onEnter hook when the\n\t * state is being entered.\n\t *\n\t * @hidden\n\t */\n\tfunction makeEnterExitRetainHook(hookName) {\n\t    return function (transition, state) {\n\t        var _state = state.$$state();\n\t        var hookFn = _state[hookName];\n\t        return hookFn(transition, state);\n\t    };\n\t}\n\t/**\n\t * The [[TransitionStateHookFn]] for onExit\n\t *\n\t * When the state is being exited, the state's .onExit function is invoked.\n\t *\n\t * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n\t *\n\t * See: [[IHookRegistry.onExit]]\n\t */\n\tvar onExitHook = makeEnterExitRetainHook('onExit');\n\tvar registerOnExitHook = function (transitionService) {\n\t    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onRetain\n\t *\n\t * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n\t *\n\t * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n\t *\n\t * See: [[IHookRegistry.onRetain]]\n\t */\n\tvar onRetainHook = makeEnterExitRetainHook('onRetain');\n\tvar registerOnRetainHook = function (transitionService) {\n\t    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onEnter\n\t *\n\t * When the state is being entered, the state's .onEnter function is invoked.\n\t *\n\t * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n\t *\n\t * See: [[IHookRegistry.onEnter]]\n\t */\n\tvar onEnterHook = makeEnterExitRetainHook('onEnter');\n\tvar registerOnEnterHook = function (transitionService) {\n\t    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n\t};\n\t\n\t/** @module hooks */\n\t/** for typedoc */\n\t/**\n\t * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n\t *\n\t * Registered using `transitionService.onStart({}, eagerResolvePath);`\n\t *\n\t * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar eagerResolvePath = function (trans) {\n\t    return new ResolveContext(trans.treeChanges().to)\n\t        .resolvePath(\"EAGER\", trans)\n\t        .then(noop);\n\t};\n\tvar registerEagerResolvePath = function (transitionService) {\n\t    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n\t *\n\t * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n\t *\n\t * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar lazyResolveState = function (trans, state) {\n\t    return new ResolveContext(trans.treeChanges().to)\n\t        .subContext(state.$$state())\n\t        .resolvePath(\"LAZY\", trans)\n\t        .then(noop);\n\t};\n\tvar registerLazyResolveState = function (transitionService) {\n\t    return transitionService.onEnter({ entering: val(true) }, lazyResolveState, { priority: 1000 });\n\t};\n\t\n\t/** @module hooks */ /** for typedoc */\n\t/**\n\t * A [[TransitionHookFn]] which waits for the views to load\n\t *\n\t * Registered using `transitionService.onStart({}, loadEnteringViews);`\n\t *\n\t * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n\t * In angular 1, this includes loading the templates.\n\t */\n\tvar loadEnteringViews = function (transition) {\n\t    var $q = services.$q;\n\t    var enteringViews = transition.views(\"entering\");\n\t    if (!enteringViews.length)\n\t        return;\n\t    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(noop);\n\t};\n\tvar registerLoadEnteringViews = function (transitionService) {\n\t    return transitionService.onFinish({}, loadEnteringViews);\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n\t *\n\t * Registered using `transitionService.onSuccess({}, activateViews);`\n\t *\n\t * After a transition is complete, this hook deactivates the old views from the previous state,\n\t * and activates the new views from the destination state.\n\t *\n\t * See [[ViewService]]\n\t */\n\tvar activateViews = function (transition) {\n\t    var enteringViews = transition.views(\"entering\");\n\t    var exitingViews = transition.views(\"exiting\");\n\t    if (!enteringViews.length && !exitingViews.length)\n\t        return;\n\t    var $view = transition.router.viewService;\n\t    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n\t    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n\t    $view.sync();\n\t};\n\tvar registerActivateViews = function (transitionService) {\n\t    return transitionService.onSuccess({}, activateViews);\n\t};\n\t\n\t/**\n\t * A [[TransitionHookFn]] which updates global UI-Router state\n\t *\n\t * Registered using `transitionService.onBefore({}, updateGlobalState);`\n\t *\n\t * Before a [[Transition]] starts, updates the global value of \"the current transition\" ([[Globals.transition]]).\n\t * After a successful [[Transition]], updates the global values of \"the current state\"\n\t * ([[Globals.current]] and [[Globals.$current]]) and \"the current param values\" ([[Globals.params]]).\n\t *\n\t * See also the deprecated properties:\n\t * [[StateService.transition]], [[StateService.current]], [[StateService.params]]\n\t */\n\tvar updateGlobalState = function (trans) {\n\t    var globals = trans.router.globals;\n\t    var transitionSuccessful = function () {\n\t        globals.successfulTransitions.enqueue(trans);\n\t        globals.$current = trans.$to();\n\t        globals.current = globals.$current.self;\n\t        copy(trans.params(), globals.params);\n\t    };\n\t    var clearCurrentTransition = function () {\n\t        // Do not clear globals.transition if a different transition has started in the meantime\n\t        if (globals.transition === trans)\n\t            globals.transition = null;\n\t    };\n\t    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n\t    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n\t};\n\tvar registerUpdateGlobalState = function (transitionService) {\n\t    return transitionService.onCreate({}, updateGlobalState);\n\t};\n\t\n\t/**\n\t * A [[TransitionHookFn]] which updates the URL after a successful transition\n\t *\n\t * Registered using `transitionService.onSuccess({}, updateUrl);`\n\t */\n\tvar updateUrl = function (transition) {\n\t    var options = transition.options();\n\t    var $state = transition.router.stateService;\n\t    var $urlRouter = transition.router.urlRouter;\n\t    // Dont update the url in these situations:\n\t    // The transition was triggered by a URL sync (options.source === 'url')\n\t    // The user doesn't want the url to update (options.location === false)\n\t    // The destination state, and all parents have no navigable url\n\t    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n\t        var urlOptions = { replace: options.location === 'replace' };\n\t        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n\t    }\n\t    $urlRouter.update(true);\n\t};\n\tvar registerUpdateUrl = function (transitionService) {\n\t    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n\t};\n\t\n\t/**\n\t * A [[TransitionHookFn]] that performs lazy loading\n\t *\n\t * When entering a state \"abc\" which has a `lazyLoad` function defined:\n\t * - Invoke the `lazyLoad` function (unless it is already in process)\n\t *   - Flag the hook function as \"in process\"\n\t *   - The function should return a promise (that resolves when lazy loading is complete)\n\t * - Wait for the promise to settle\n\t *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n\t *   - Flag the hook function as \"not in process\"\n\t * - If the hook was successful\n\t *   - Remove the `lazyLoad` function from the state declaration\n\t * - If all the hooks were successful\n\t *   - Retry the transition (by returning a TargetState)\n\t *\n\t * ```\n\t * .state('abc', {\n\t *   component: 'fooComponent',\n\t *   lazyLoad: () => System.import('./fooComponent')\n\t *   });\n\t * ```\n\t *\n\t * See [[StateDeclaration.lazyLoad]]\n\t */\n\tvar lazyLoadHook = function (transition) {\n\t    var router = transition.router;\n\t    function retryTransition() {\n\t        if (transition.originalTransition().options().source !== 'url') {\n\t            // The original transition was not triggered via url sync\n\t            // The lazy state should be loaded now, so re-try the original transition\n\t            var orig = transition.targetState();\n\t            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n\t        }\n\t        // The original transition was triggered via url sync\n\t        // Run the URL rules and find the best match\n\t        var $url = router.urlService;\n\t        var result = $url.match($url.parts());\n\t        var rule = result && result.rule;\n\t        // If the best match is a state, redirect the transition (instead\n\t        // of calling sync() which supersedes the current transition)\n\t        if (rule && rule.type === \"STATE\") {\n\t            var state = rule.state;\n\t            var params = result.match;\n\t            return router.stateService.target(state, params, transition.options());\n\t        }\n\t        // No matching state found, so let .sync() choose the best non-state match/otherwise\n\t        router.urlService.sync();\n\t    }\n\t    var promises = transition.entering()\n\t        .filter(function (state) { return !!state.$$state().lazyLoad; })\n\t        .map(function (state) { return lazyLoadState(transition, state); });\n\t    return services.$q.all(promises).then(retryTransition);\n\t};\n\tvar registerLazyLoadHook = function (transitionService) {\n\t    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n\t};\n\t/**\n\t * Invokes a state's lazy load function\n\t *\n\t * @param transition a Transition context\n\t * @param state the state to lazy load\n\t * @returns A promise for the lazy load result\n\t */\n\tfunction lazyLoadState(transition, state) {\n\t    var lazyLoadFn = state.$$state().lazyLoad;\n\t    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n\t    var promise = lazyLoadFn['_promise'];\n\t    if (!promise) {\n\t        var success = function (result) {\n\t            delete state.lazyLoad;\n\t            delete state.$$state().lazyLoad;\n\t            delete lazyLoadFn['_promise'];\n\t            return result;\n\t        };\n\t        var error = function (err) {\n\t            delete lazyLoadFn['_promise'];\n\t            return services.$q.reject(err);\n\t        };\n\t        promise = lazyLoadFn['_promise'] =\n\t            services.$q.when(lazyLoadFn(transition, state))\n\t                .then(updateStateRegistry)\n\t                .then(success, error);\n\t    }\n\t    /** Register any lazy loaded state definitions */\n\t    function updateStateRegistry(result) {\n\t        if (result && Array.isArray(result.states)) {\n\t            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n\t        }\n\t        return result;\n\t    }\n\t    return promise;\n\t}\n\t\n\t/**\n\t * This class defines a type of hook, such as `onBefore` or `onEnter`.\n\t * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n\t *\n\t * @interalapi\n\t */\n\tvar TransitionEventType = (function () {\n\t    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }\n\t        if (synchronous === void 0) { synchronous = false; }\n\t        this.name = name;\n\t        this.hookPhase = hookPhase;\n\t        this.hookOrder = hookOrder;\n\t        this.criteriaMatchPath = criteriaMatchPath;\n\t        this.reverseSort = reverseSort;\n\t        this.getResultHandler = getResultHandler;\n\t        this.getErrorHandler = getErrorHandler;\n\t        this.synchronous = synchronous;\n\t    }\n\t    return TransitionEventType;\n\t}());\n\t\n\t/** @module hooks */ /** */\n\t/**\n\t * A [[TransitionHookFn]] that skips a transition if it should be ignored\n\t *\n\t * This hook is invoked at the end of the onBefore phase.\n\t *\n\t * If the transition should be ignored (because no parameter or states changed)\n\t * then the transition is ignored and not processed.\n\t */\n\tfunction ignoredHook(trans) {\n\t    var ignoredReason = trans._ignoredReason();\n\t    if (!ignoredReason)\n\t        return;\n\t    trace.traceTransitionIgnored(trans);\n\t    var pending = trans.router.globals.transition;\n\t    // The user clicked a link going back to the *current state* ('A')\n\t    // However, there is also a pending transition in flight (to 'B')\n\t    // Abort the transition to 'B' because the user now wants to be back at 'A'.\n\t    if (ignoredReason === 'SameAsCurrent' && pending) {\n\t        pending.abort();\n\t    }\n\t    return Rejection.ignored().toPromise();\n\t}\n\tvar registerIgnoredTransitionHook = function (transitionService) {\n\t    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n\t};\n\t\n\t/** @module hooks */ /** */\n\t/**\n\t * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n\t *\n\t * This hook is invoked at the end of the onBefore phase.\n\t * If the transition is invalid (for example, param values do not validate)\n\t * then the transition is rejected.\n\t */\n\tfunction invalidTransitionHook(trans) {\n\t    if (!trans.valid()) {\n\t        throw new Error(trans.error());\n\t    }\n\t}\n\tvar registerInvalidTransitionHook = function (transitionService) {\n\t    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n\t};\n\t\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */\n\t/** for typedoc */\n\t/**\n\t * The default [[Transition]] options.\n\t *\n\t * Include this object when applying custom defaults:\n\t * let reloadOpts = { reload: true, notify: true }\n\t * let options = defaults(theirOpts, customDefaults, defaultOptions);\n\t */\n\tvar defaultTransOpts = {\n\t    location: true,\n\t    relative: null,\n\t    inherit: false,\n\t    notify: true,\n\t    reload: false,\n\t    custom: {},\n\t    current: function () { return null; },\n\t    source: \"unknown\"\n\t};\n\t/**\n\t * This class provides services related to Transitions.\n\t *\n\t * - Most importantly, it allows global Transition Hooks to be registered.\n\t * - It allows the default transition error handler to be set.\n\t * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n\t *\n\t * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n\t */\n\tvar TransitionService = (function () {\n\t    /** @hidden */\n\t    function TransitionService(_router) {\n\t        /** @hidden */\n\t        this._transitionCount = 0;\n\t        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n\t        this._eventTypes = [];\n\t        /** @hidden The registered transition hooks */\n\t        this._registeredHooks = {};\n\t        /** @hidden The  paths on a criteria object */\n\t        this._criteriaPaths = {};\n\t        this._router = _router;\n\t        this.$view = _router.viewService;\n\t        this._deregisterHookFns = {};\n\t        this._pluginapi = createProxyFunctions(val(this), {}, val(this), [\n\t            '_definePathType',\n\t            '_defineEvent',\n\t            '_getPathTypes',\n\t            '_getEvents',\n\t            'getHooks',\n\t        ]);\n\t        this._defineCorePaths();\n\t        this._defineCoreEvents();\n\t        this._registerCoreTransitionHooks();\n\t    }\n\t    /**\n\t     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n\t     *\n\t     * Registers a transition lifecycle hook, which is invoked during transition construction.\n\t     *\n\t     * This low level hook should only be used by plugins.\n\t     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n\t     * The Sticky States plugin uses this hook to modify the treechanges.\n\t     *\n\t     * ### Lifecycle\n\t     *\n\t     * `onCreate` hooks are invoked *while a transition is being constructed*.\n\t     *\n\t     * ### Return value\n\t     *\n\t     * The hook's return value is ignored\n\t     *\n\t     * @internalapi\n\t     * @param criteria defines which Transitions the Hook should be invoked for.\n\t     * @param callback the hook function which will be invoked.\n\t     * @param options the registration options\n\t     * @returns a function which deregisters the hook.\n\t     */\n\t    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n\t    /**\n\t     * dispose\n\t     * @internalapi\n\t     */\n\t    TransitionService.prototype.dispose = function (router) {\n\t        values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n\t            hook._deregistered = true;\n\t            removeFrom(hooksArray, hook);\n\t        }); });\n\t    };\n\t    /**\n\t     * Creates a new [[Transition]] object\n\t     *\n\t     * This is a factory function for creating new Transition objects.\n\t     * It is used internally by the [[StateService]] and should generally not be called by application code.\n\t     *\n\t     * @param fromPath the path to the current state (the from state)\n\t     * @param targetState the target state (destination)\n\t     * @returns a Transition\n\t     */\n\t    TransitionService.prototype.create = function (fromPath, targetState) {\n\t        return new Transition(fromPath, targetState, this._router);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineCoreEvents = function () {\n\t        var Phase = exports.TransitionHookPhase;\n\t        var TH = TransitionHook;\n\t        var paths = this._criteriaPaths;\n\t        var NORMAL_SORT = false, REVERSE_SORT = true;\n\t        var ASYNCHRONOUS = false, SYNCHRONOUS = true;\n\t        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);\n\t        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to);\n\t        this._defineEvent(\"onStart\", Phase.RUN, 0, paths.to);\n\t        this._defineEvent(\"onExit\", Phase.RUN, 100, paths.exiting, REVERSE_SORT);\n\t        this._defineEvent(\"onRetain\", Phase.RUN, 200, paths.retained);\n\t        this._defineEvent(\"onEnter\", Phase.RUN, 300, paths.entering);\n\t        this._defineEvent(\"onFinish\", Phase.RUN, 400, paths.to);\n\t        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n\t        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineCorePaths = function () {\n\t        var STATE = exports.TransitionHookScope.STATE, TRANSITION = exports.TransitionHookScope.TRANSITION;\n\t        this._definePathType(\"to\", TRANSITION);\n\t        this._definePathType(\"from\", TRANSITION);\n\t        this._definePathType(\"exiting\", STATE);\n\t        this._definePathType(\"retained\", STATE);\n\t        this._definePathType(\"entering\", STATE);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }\n\t        if (synchronous === void 0) { synchronous = false; }\n\t        var eventType = new TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);\n\t        this._eventTypes.push(eventType);\n\t        makeEvent(this, this, eventType);\n\t    };\n\t    \n\t    /** @hidden */\n\t    TransitionService.prototype._getEvents = function (phase) {\n\t        var transitionHookTypes = isDefined(phase) ?\n\t            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n\t            this._eventTypes.slice();\n\t        return transitionHookTypes.sort(function (l, r) {\n\t            var cmpByPhase = l.hookPhase - r.hookPhase;\n\t            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n\t        });\n\t    };\n\t    /**\n\t     * Adds a Path to be used as a criterion against a TreeChanges path\n\t     *\n\t     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n\t     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n\t     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * @hidden\n\t     */\n\t    TransitionService.prototype._definePathType = function (name, hookScope) {\n\t        this._criteriaPaths[name] = { name: name, scope: hookScope };\n\t    };\n\t    /** * @hidden */\n\t    TransitionService.prototype._getPathTypes = function () {\n\t        return this._criteriaPaths;\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._registerCoreTransitionHooks = function () {\n\t        var fns = this._deregisterHookFns;\n\t        fns.addCoreResolves = registerAddCoreResolvables(this);\n\t        fns.ignored = registerIgnoredTransitionHook(this);\n\t        fns.invalid = registerInvalidTransitionHook(this);\n\t        // Wire up redirectTo hook\n\t        fns.redirectTo = registerRedirectToHook(this);\n\t        // Wire up onExit/Retain/Enter state hooks\n\t        fns.onExit = registerOnExitHook(this);\n\t        fns.onRetain = registerOnRetainHook(this);\n\t        fns.onEnter = registerOnEnterHook(this);\n\t        // Wire up Resolve hooks\n\t        fns.eagerResolve = registerEagerResolvePath(this);\n\t        fns.lazyResolve = registerLazyResolveState(this);\n\t        // Wire up the View management hooks\n\t        fns.loadViews = registerLoadEnteringViews(this);\n\t        fns.activateViews = registerActivateViews(this);\n\t        // Updates global state after a transition\n\t        fns.updateGlobals = registerUpdateGlobalState(this);\n\t        // After globals.current is updated at priority: 10000\n\t        fns.updateUrl = registerUpdateUrl(this);\n\t        // Lazy load state trees\n\t        fns.lazyLoad = registerLazyLoadHook(this);\n\t    };\n\t    return TransitionService;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module state\n\t */\n\t/** */\n\t/**\n\t * Provides state related service functions\n\t *\n\t * This class provides services related to ui-router states.\n\t * An instance of this class is located on the global [[UIRouter]] object.\n\t */\n\tvar StateService = (function () {\n\t    /** @internalapi */\n\t    function StateService(router) {\n\t        this.router = router;\n\t        /** @internalapi */\n\t        this.invalidCallbacks = [];\n\t        /** @hidden */\n\t        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n\t            if ($error$ instanceof Error && $error$.stack) {\n\t                console.error($error$);\n\t                console.error($error$.stack);\n\t            }\n\t            else if ($error$ instanceof Rejection) {\n\t                console.error($error$.toString());\n\t                if ($error$.detail && $error$.detail.stack)\n\t                    console.error($error$.detail.stack);\n\t            }\n\t            else {\n\t                console.error($error$);\n\t            }\n\t        };\n\t        var getters = ['current', '$current', 'params', 'transition'];\n\t        var boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));\n\t        createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);\n\t    }\n\t    Object.defineProperty(StateService.prototype, \"transition\", {\n\t        /**\n\t         * The [[Transition]] currently in progress (or null)\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.transition]]\n\t         */\n\t        get: function () { return this.router.globals.transition; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"params\", {\n\t        /**\n\t         * The latest successful state parameters\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.params]]\n\t         */\n\t        get: function () { return this.router.globals.params; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"current\", {\n\t        /**\n\t         * The current [[StateDeclaration]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.current]]\n\t         */\n\t        get: function () { return this.router.globals.current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"$current\", {\n\t        /**\n\t         * The current [[StateObject]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.$current]]\n\t         */\n\t        get: function () { return this.router.globals.$current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /** @internalapi */\n\t    StateService.prototype.dispose = function () {\n\t        this.defaultErrorHandler(noop);\n\t        this.invalidCallbacks = [];\n\t    };\n\t    /**\n\t     * Handler for when [[transitionTo]] is called with an invalid state.\n\t     *\n\t     * Invokes the [[onInvalid]] callbacks, in natural order.\n\t     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n\t     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n\t     *\n\t     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n\t     *\n\t     * @internalapi\n\t     */\n\t    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n\t        var _this = this;\n\t        var fromState = PathUtils.makeTargetState(fromPath);\n\t        var globals = this.router.globals;\n\t        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n\t        var latest = latestThing();\n\t        var callbackQueue = new Queue(this.invalidCallbacks.slice());\n\t        var injector = new ResolveContext(fromPath).injector();\n\t        var checkForRedirect = function (result) {\n\t            if (!(result instanceof TargetState)) {\n\t                return;\n\t            }\n\t            var target = result;\n\t            // Recreate the TargetState, in case the state is now defined.\n\t            target = _this.target(target.identifier(), target.params(), target.options());\n\t            if (!target.valid()) {\n\t                return Rejection.invalid(target.error()).toPromise();\n\t            }\n\t            if (latestThing() !== latest) {\n\t                return Rejection.superseded().toPromise();\n\t            }\n\t            return _this.transitionTo(target.identifier(), target.params(), target.options());\n\t        };\n\t        function invokeNextCallback() {\n\t            var nextCallback = callbackQueue.dequeue();\n\t            if (nextCallback === undefined)\n\t                return Rejection.invalid(toState.error()).toPromise();\n\t            var callbackResult = services.$q.when(nextCallback(toState, fromState, injector));\n\t            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n\t        }\n\t        return invokeNextCallback();\n\t    };\n\t    /**\n\t     * Registers an Invalid State handler\n\t     *\n\t     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n\t     * has been called with an invalid state reference parameter\n\t     *\n\t     * Example:\n\t     * ```js\n\t     * stateService.onInvalid(function(to, from, injector) {\n\t     *   if (to.name() === 'foo') {\n\t     *     let lazyLoader = injector.get('LazyLoadService');\n\t     *     return lazyLoader.load('foo')\n\t     *         .then(() => stateService.target('foo'));\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param {function} callback invoked when the toState is invalid\n\t     *   This function receives the (invalid) toState, the fromState, and an injector.\n\t     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n\t     *   If one is returned, it is treated as a redirect.\n\t     *\n\t     * @returns a function which deregisters the callback\n\t     */\n\t    StateService.prototype.onInvalid = function (callback) {\n\t        this.invalidCallbacks.push(callback);\n\t        return function deregisterListener() {\n\t            removeFrom(this.invalidCallbacks)(callback);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Reloads the current state\n\t     *\n\t     * A method that force reloads the current state, or a partial state hierarchy.\n\t     * All resolves are re-resolved, and components reinstantiated.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * Note: `reload()` is just an alias for:\n\t     *\n\t     * ```js\n\t     * $state.transitionTo($state.current, $state.params, {\n\t     *   reload: true, inherit: false\n\t     * });\n\t     * ```\n\t     *\n\t     * @param reloadState A state name or a state object.\n\t     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n\t     * //and current state is 'contacts.detail.item'\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n\t     */\n\t    StateService.prototype.reload = function (reloadState) {\n\t        return this.transitionTo(this.current, this.params, {\n\t            reload: isDefined(reloadState) ? reloadState : true,\n\t            inherit: false,\n\t            notify: false,\n\t        });\n\t    };\n\t    \n\t    /**\n\t     * Transition to a different state and/or parameters\n\t     *\n\t     * Convenience method for transitioning to a new state.\n\t     *\n\t     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n\t     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n\t     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n\t     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n\t     * inherit from the current parameter values (because of `inherit: true`).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     * @param to Absolute state name, state object, or relative state path (relative to current state).\n\t     *\n\t     * Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to the parent state\n\t     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n\t     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n\t     *\n\t     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n\t     *\n\t     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n\t     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n\t     *\n\t     * @param options Transition options\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     */\n\t    StateService.prototype.go = function (to, params, options) {\n\t        var defautGoOpts = { relative: this.$current, inherit: true };\n\t        var transOpts = defaults(options, defautGoOpts, defaultTransOpts);\n\t        return this.transitionTo(to, params, transOpts);\n\t    };\n\t    \n\t    /**\n\t     * Creates a [[TargetState]]\n\t     *\n\t     * This is a factory method for creating a TargetState\n\t     *\n\t     * This may be returned from a Transition Hook to redirect a transition, for example.\n\t     */\n\t    StateService.prototype.target = function (identifier, params, options) {\n\t        if (options === void 0) { options = {}; }\n\t        // If we're reloading, find the state object to reload from\n\t        if (isObject(options.reload) && !options.reload.name)\n\t            throw new Error('Invalid reload state object');\n\t        var reg = this.router.stateRegistry;\n\t        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n\t        if (options.reload && !options.reloadState)\n\t            throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        var stateDefinition = reg.matcher.find(identifier, options.relative);\n\t        return new TargetState(identifier, stateDefinition, params, options);\n\t    };\n\t    \n\t    StateService.prototype.getCurrentPath = function () {\n\t        var _this = this;\n\t        var globals = this.router.globals;\n\t        var latestSuccess = globals.successfulTransitions.peekTail();\n\t        var rootPath = function () { return [new PathNode(_this.router.stateRegistry.root())]; };\n\t        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n\t    };\n\t    /**\n\t     * Low-level method for transitioning to a new state.\n\t     *\n\t     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     * @param to State name or state object.\n\t     * @param toParams A map of the parameters that will be sent to the state,\n\t     *      will populate $stateParams.\n\t     * @param options Transition options\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[go]]\n\t     */\n\t    StateService.prototype.transitionTo = function (to, toParams, options) {\n\t        var _this = this;\n\t        if (toParams === void 0) { toParams = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var router = this.router;\n\t        var globals = router.globals;\n\t        options = defaults(options, defaultTransOpts);\n\t        var getCurrent = function () {\n\t            return globals.transition;\n\t        };\n\t        options = extend(options, { current: getCurrent });\n\t        var ref = this.target(to, toParams, options);\n\t        var currentPath = this.getCurrentPath();\n\t        if (!ref.exists())\n\t            return this._handleInvalidTargetState(currentPath, ref);\n\t        if (!ref.valid())\n\t            return silentRejection(ref.error());\n\t        /**\n\t         * Special handling for Ignored, Aborted, and Redirected transitions\n\t         *\n\t         * The semantics for the transition.run() promise and the StateService.transitionTo()\n\t         * promise differ. For instance, the run() promise may be rejected because it was\n\t         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n\t         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n\t         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n\t         */\n\t        var rejectedTransitionHandler = function (transition) { return function (error) {\n\t            if (error instanceof Rejection) {\n\t                var isLatest = router.globals.lastStartedTransitionId === transition.$id;\n\t                if (error.type === exports.RejectType.IGNORED) {\n\t                    isLatest && router.urlRouter.update();\n\t                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n\t                    return services.$q.when(globals.current);\n\t                }\n\t                var detail = error.detail;\n\t                if (error.type === exports.RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {\n\t                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n\t                    // by returning the promise for the new (redirect) `Transition.run()`.\n\t                    var redirect = transition.redirect(detail);\n\t                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n\t                }\n\t                if (error.type === exports.RejectType.ABORTED) {\n\t                    isLatest && router.urlRouter.update();\n\t                    return services.$q.reject(error);\n\t                }\n\t            }\n\t            var errorHandler = _this.defaultErrorHandler();\n\t            errorHandler(error);\n\t            return services.$q.reject(error);\n\t        }; };\n\t        var transition = this.router.transitionService.create(currentPath, ref);\n\t        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n\t        silenceUncaughtInPromise(transitionToPromise); // issue #2676\n\t        // Return a promise for the transition, which also has the transition object on it.\n\t        return extend(transitionToPromise, { transition: transition });\n\t    };\n\t    \n\t    /**\n\t     * Checks if the current state *is* the provided state\n\t     *\n\t     * Similar to [[includes]] but only checks for the full state name.\n\t     * If params is supplied then it will be tested for strict equality against the current\n\t     * active params object, so all params must match with none missing and no extras.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     * ```\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * ```html\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns Returns true if it is the state.\n\t     */\n\t    StateService.prototype.is = function (stateOrName, params, options) {\n\t        options = defaults(options, { relative: this.$current });\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!isDefined(state))\n\t            return undefined;\n\t        if (this.$current !== state)\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return Param.equals(schema, Param.values(schema, params), this.params);\n\t    };\n\t    \n\t    /**\n\t     * Checks if the current state *includes* the provided state\n\t     *\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * #### Example when `$state.$current.name === 'contacts.details.item'`\n\t     * ```js\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     * ```\n\t     *\n\t     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n\t     * ```js\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * ```\n\t     *\n\t     * @param stateOrName A partial name, relative name, glob pattern,\n\t     *   or state object to be searched for within the current state name.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`,\n\t     *   that you'd like to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    StateService.prototype.includes = function (stateOrName, params, options) {\n\t        options = defaults(options, { relative: this.$current });\n\t        var glob = isString(stateOrName) && Glob.fromString(stateOrName);\n\t        if (glob) {\n\t            if (!glob.matches(this.$current.name))\n\t                return false;\n\t            stateOrName = this.$current.name;\n\t        }\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n\t        if (!isDefined(state))\n\t            return undefined;\n\t        if (!isDefined(include[state.name]))\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return Param.equals(schema, Param.values(schema, params), this.params);\n\t    };\n\t    \n\t    /**\n\t     * Generates a URL for a state and parameters\n\t     *\n\t     * Returns the url for the given state populated with the given params.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param params An object of parameter values to fill the state's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * @returns {string} compiled state url\n\t     */\n\t    StateService.prototype.href = function (stateOrName, params, options) {\n\t        var defaultHrefOpts = {\n\t            lossy: true,\n\t            inherit: true,\n\t            absolute: false,\n\t            relative: this.$current,\n\t        };\n\t        options = defaults(options, defaultHrefOpts);\n\t        params = params || {};\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!isDefined(state))\n\t            return null;\n\t        if (options.inherit)\n\t            params = this.params.$inherit(params, this.$current, state);\n\t        var nav = (state && options.lossy) ? state.navigable : state;\n\t        if (!nav || nav.url === undefined || nav.url === null) {\n\t            return null;\n\t        }\n\t        return this.router.urlRouter.href(nav.url, params, {\n\t            absolute: options.absolute,\n\t        });\n\t    };\n\t    \n\t    /**\n\t     * Sets or gets the default [[transitionTo]] error handler.\n\t     *\n\t     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n\t     * This includes errors caused by resolves and transition hooks.\n\t     *\n\t     * Note:\n\t     * This handler does not receive certain Transition rejections.\n\t     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n\t     *\n\t     * The built-in default error handler logs the error to the console.\n\t     *\n\t     * You can provide your own custom handler.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * stateService.defaultErrorHandler(function() {\n\t     *   // Do not log transitionTo errors\n\t     * });\n\t     * ```\n\t     *\n\t     * @param handler a global error handler function\n\t     * @returns the current global error handler\n\t     */\n\t    StateService.prototype.defaultErrorHandler = function (handler) {\n\t        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n\t    };\n\t    StateService.prototype.get = function (stateOrName, base) {\n\t        var reg = this.router.stateRegistry;\n\t        if (arguments.length === 0)\n\t            return reg.get();\n\t        return reg.get(stateOrName, base || this.$current);\n\t    };\n\t    /**\n\t     * Lazy loads a state\n\t     *\n\t     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n\t     *\n\t     * @param stateOrName the state that should be lazy loaded\n\t     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n\t     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n\t     * This noop transition is not actually run.\n\t     *\n\t     * @returns a promise to lazy load\n\t     */\n\t    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n\t        var state = this.get(stateOrName);\n\t        if (!state || !state.lazyLoad)\n\t            throw new Error(\"Can not lazy load \" + stateOrName);\n\t        var currentPath = this.getCurrentPath();\n\t        var target = PathUtils.makeTargetState(currentPath);\n\t        transition = transition || this.router.transitionService.create(currentPath, target);\n\t        return lazyLoadState(transition, state);\n\t    };\n\t    return StateService;\n\t}());\n\t\n\t/**\n\t * # Transition subsystem\n\t *\n\t * This module contains APIs related to a Transition.\n\t *\n\t * See:\n\t * - [[TransitionService]]\n\t * - [[Transition]]\n\t * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module transition\n\t */ /** for typedoc */\n\t\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t/**\n\t * An angular1-like promise api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This API provides native ES6 promise support wrapped as a $q-like API.\n\t * Internally, UI-Router uses this $q object to perform promise operations.\n\t * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n\t *\n\t * $q-like promise api\n\t */\n\tvar $q = {\n\t    /** Normalizes a value as a promise */\n\t    when: function (val$$1) { return new Promise(function (resolve, reject) { return resolve(val$$1); }); },\n\t    /** Normalizes a value as a promise rejection */\n\t    reject: function (val$$1) { return new Promise(function (resolve, reject) { reject(val$$1); }); },\n\t    /** @returns a deferred object, which has `resolve` and `reject` functions */\n\t    defer: function () {\n\t        var deferred = {};\n\t        deferred.promise = new Promise(function (resolve, reject) {\n\t            deferred.resolve = resolve;\n\t            deferred.reject = reject;\n\t        });\n\t        return deferred;\n\t    },\n\t    /** Like Promise.all(), but also supports object key/promise notation like $q */\n\t    all: function (promises) {\n\t        if (isArray(promises)) {\n\t            return Promise.all(promises);\n\t        }\n\t        if (isObject(promises)) {\n\t            // Convert promises map to promises array.\n\t            // When each promise resolves, map it to a tuple { key: key, val: val }\n\t            var chain = Object.keys(promises)\n\t                .map(function (key) { return promises[key].then(function (val$$1) { return ({ key: key, val: val$$1 }); }); });\n\t            // Then wait for all promises to resolve, and convert them back to an object\n\t            return $q.all(chain).then(function (values$$1) {\n\t                return values$$1.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n\t            });\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t// globally available injectables\n\tvar globals = {};\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\t/**\n\t * A basic angular1-like injector api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This object provides a naive implementation of a globally scoped dependency injection system.\n\t * It supports the following DI approaches:\n\t *\n\t * ### Function parameter names\n\t *\n\t * A function's `.toString()` is called, and the parameter names are parsed.\n\t * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n\t *\n\t * ```js\n\t * function injectedFunction(FooService, BarService) {\n\t *   // FooService and BarService are injected\n\t * }\n\t * ```\n\t *\n\t * ### Function annotation\n\t *\n\t * A function may be annotated with an array of dependency names as the `$inject` property.\n\t *\n\t * ```js\n\t * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n\t * function injectedFunction(fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }\n\t * ```\n\t *\n\t * ### Array notation\n\t *\n\t * An array provides the names of the dependencies to inject (as strings).\n\t * The function is the last element of the array.\n\t *\n\t * ```js\n\t * [ 'FooService', 'BarService', function (fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }]\n\t * ```\n\t *\n\t * @type {$InjectorLike}\n\t */\n\tvar $injector = {\n\t    /** Gets an object from DI based on a string token */\n\t    get: function (name) { return globals[name]; },\n\t    /** Returns true if an object named `name` exists in global DI */\n\t    has: function (name) { return $injector.get(name) != null; },\n\t    /**\n\t     * Injects a function\n\t     *\n\t     * @param fn the function to inject\n\t     * @param context the function's `this` binding\n\t     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n\t     */\n\t    invoke: function (fn, context, locals) {\n\t        var all$$1 = extend({}, globals, locals || {});\n\t        var params = $injector.annotate(fn);\n\t        var ensureExist = assertPredicate(function (key) { return all$$1.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n\t        var args = params.filter(ensureExist).map(function (x) { return all$$1[x]; });\n\t        if (isFunction(fn))\n\t            return fn.apply(context, args);\n\t        else\n\t            return fn.slice(-1)[0].apply(context, args);\n\t    },\n\t    /**\n\t     * Returns a function's dependencies\n\t     *\n\t     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n\t     * @return an array of `string`s\n\t     */\n\t    annotate: function (fn) {\n\t        if (!isInjectable(fn))\n\t            throw new Error(\"Not an injectable function: \" + fn);\n\t        if (fn && fn.$inject)\n\t            return fn.$inject;\n\t        if (isArray(fn))\n\t            return fn.slice(0, -1);\n\t        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n\t        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n\t        return result || [];\n\t    }\n\t};\n\t\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar beforeAfterSubstr$1 = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\tvar splitHash = beforeAfterSubstr$1(\"#\");\n\tvar splitQuery = beforeAfterSubstr$1(\"?\");\n\tvar splitEqual = beforeAfterSubstr$1(\"=\");\n\tvar trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\n\tvar keyValsToObjectR = function (accum, _a) {\n\t    var key = _a[0], val$$1 = _a[1];\n\t    if (!accum.hasOwnProperty(key)) {\n\t        accum[key] = val$$1;\n\t    }\n\t    else if (isArray(accum[key])) {\n\t        accum[key].push(val$$1);\n\t    }\n\t    else {\n\t        accum[key] = [accum[key], val$$1];\n\t    }\n\t    return accum;\n\t};\n\tvar getParams = function (queryString) {\n\t    return queryString.split(\"&\").filter(identity).map(splitEqual).reduce(keyValsToObjectR, {});\n\t};\n\tfunction parseUrl$1(url) {\n\t    var orEmptyString = function (x) { return x || \"\"; };\n\t    var _a = splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n\t    var _b = splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n\t    return { path: path, search: search, hash: hash, url: url };\n\t}\n\tvar buildUrl = function (loc) {\n\t    var path = loc.path();\n\t    var searchObject = loc.search();\n\t    var hash = loc.hash();\n\t    var search = Object.keys(searchObject).map(function (key) {\n\t        var param = searchObject[key];\n\t        var vals = isArray(param) ? param : [param];\n\t        return vals.map(function (val$$1) { return key + \"=\" + val$$1; });\n\t    }).reduce(unnestR, []).join(\"&\");\n\t    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n\t};\n\tfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n\t    return function (router) {\n\t        var service = router.locationService = new serviceClass(router);\n\t        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n\t        function dispose(router) {\n\t            router.dispose(service);\n\t            router.dispose(configuration);\n\t        }\n\t        return { name: name, service: service, configuration: configuration, dispose: dispose };\n\t    };\n\t}\n\t\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */ /** */\n\t/** A base `LocationServices` */\n\tvar BaseLocationServices = (function () {\n\t    function BaseLocationServices(router, fireAfterUpdate) {\n\t        var _this = this;\n\t        this.fireAfterUpdate = fireAfterUpdate;\n\t        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n\t        this._listeners = [];\n\t        this.hash = function () { return parseUrl$1(_this._get()).hash; };\n\t        this.path = function () { return parseUrl$1(_this._get()).path; };\n\t        this.search = function () { return getParams(parseUrl$1(_this._get()).search); };\n\t        this._location = window && window.location;\n\t        this._history = window && window.history;\n\t    }\n\t    BaseLocationServices.prototype.url = function (url, replace) {\n\t        if (replace === void 0) { replace = true; }\n\t        if (isDefined(url) && url !== this._get()) {\n\t            this._set(null, null, url, replace);\n\t            if (this.fireAfterUpdate) {\n\t                var evt_1 = extend(new Event(\"locationchange\"), { url: url });\n\t                this._listeners.forEach(function (cb) { return cb(evt_1); });\n\t            }\n\t        }\n\t        return buildUrl(this);\n\t    };\n\t    BaseLocationServices.prototype.onChange = function (cb) {\n\t        var _this = this;\n\t        this._listeners.push(cb);\n\t        return function () { return removeFrom(_this._listeners, cb); };\n\t    };\n\t    BaseLocationServices.prototype.dispose = function (router) {\n\t        deregAll(this._listeners);\n\t    };\n\t    return BaseLocationServices;\n\t}());\n\t\n\tvar __extends = (undefined && undefined.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\n\tvar HashLocationService = (function (_super) {\n\t    __extends(HashLocationService, _super);\n\t    function HashLocationService(router) {\n\t        var _this = _super.call(this, router, false) || this;\n\t        window.addEventListener('hashchange', _this._listener, false);\n\t        return _this;\n\t    }\n\t    HashLocationService.prototype._get = function () {\n\t        return trimHashVal(this._location.hash);\n\t    };\n\t    HashLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._location.hash = url;\n\t    };\n\t    HashLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener('hashchange', this._listener);\n\t    };\n\t    return HashLocationService;\n\t}(BaseLocationServices));\n\t\n\tvar __extends$1 = (undefined && undefined.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t/** A `LocationServices` that gets/sets the current location from an in-memory object */\n\tvar MemoryLocationService = (function (_super) {\n\t    __extends$1(MemoryLocationService, _super);\n\t    function MemoryLocationService(router) {\n\t        return _super.call(this, router, true) || this;\n\t    }\n\t    MemoryLocationService.prototype._get = function () {\n\t        return this._url;\n\t    };\n\t    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._url = url;\n\t    };\n\t    return MemoryLocationService;\n\t}(BaseLocationServices));\n\t\n\tvar __extends$2 = (undefined && undefined.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\t/**\n\t * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n\t *\n\t * Uses `history.pushState` and `history.replaceState`\n\t */\n\tvar PushStateLocationService = (function (_super) {\n\t    __extends$2(PushStateLocationService, _super);\n\t    function PushStateLocationService(router) {\n\t        var _this = _super.call(this, router, true) || this;\n\t        _this._config = router.urlService.config;\n\t        window.addEventListener(\"popstate\", _this._listener, false);\n\t        return _this;\n\t    }\n\t    \n\t    PushStateLocationService.prototype._get = function () {\n\t        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n\t        search = splitQuery(search)[1]; // strip ? if found\n\t        hash = splitHash(hash)[1]; // strip # if found\n\t        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n\t    };\n\t    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n\t        var _a = this, _config = _a._config, _history = _a._history;\n\t        var fullUrl = _config.baseHref() + url;\n\t        if (replace) {\n\t            _history.replaceState(state, title, fullUrl);\n\t        }\n\t        else {\n\t            _history.pushState(state, title, fullUrl);\n\t        }\n\t    };\n\t    PushStateLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener(\"popstate\", this._listener);\n\t    };\n\t    return PushStateLocationService;\n\t}(BaseLocationServices));\n\t\n\t/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\n\tvar MemoryLocationConfig = (function () {\n\t    function MemoryLocationConfig() {\n\t        var _this = this;\n\t        this._baseHref = '';\n\t        this._port = 80;\n\t        this._protocol = \"http\";\n\t        this._host = \"localhost\";\n\t        this._hashPrefix = \"\";\n\t        this.port = function () { return _this._port; };\n\t        this.protocol = function () { return _this._protocol; };\n\t        this.host = function () { return _this._host; };\n\t        this.baseHref = function () { return _this._baseHref; };\n\t        this.html5Mode = function () { return false; };\n\t        this.hashPrefix = function (newval) { return isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n\t        this.dispose = noop;\n\t    }\n\t    return MemoryLocationConfig;\n\t}());\n\t\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t/** A `LocationConfig` that delegates to the browser's `location` object */\n\tvar BrowserLocationConfig = (function () {\n\t    function BrowserLocationConfig(router, _isHtml5) {\n\t        if (_isHtml5 === void 0) { _isHtml5 = false; }\n\t        this._isHtml5 = _isHtml5;\n\t        this._baseHref = undefined;\n\t        this._hashPrefix = \"\";\n\t    }\n\t    BrowserLocationConfig.prototype.port = function () {\n\t        if (location.port) {\n\t            return Number(location.port);\n\t        }\n\t        return this.protocol() === 'https' ? 443 : 80;\n\t    };\n\t    BrowserLocationConfig.prototype.protocol = function () {\n\t        return location.protocol.replace(/:/g, '');\n\t    };\n\t    BrowserLocationConfig.prototype.host = function () {\n\t        return location.hostname;\n\t    };\n\t    BrowserLocationConfig.prototype.html5Mode = function () {\n\t        return this._isHtml5;\n\t    };\n\t    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n\t        return isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n\t    };\n\t    \n\t    BrowserLocationConfig.prototype.baseHref = function (href) {\n\t        return isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n\t    };\n\t    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n\t        var baseTags = document.getElementsByTagName(\"base\");\n\t        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n\t    };\n\t    BrowserLocationConfig.prototype.dispose = function () { };\n\t    return BrowserLocationConfig;\n\t}());\n\t\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tfunction servicesPlugin(router) {\n\t    services.$injector = $injector;\n\t    services.$q = $q;\n\t    return { name: \"vanilla.services\", $q: $q, $injector: $injector, dispose: function () { return null; } };\n\t}\n\t/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\n\tvar hashLocationPlugin = locationPluginFactory('vanilla.hashBangLocation', false, HashLocationService, BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\n\tvar pushStateLocationPlugin = locationPluginFactory(\"vanilla.pushStateLocation\", true, PushStateLocationService, BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\n\tvar memoryLocationPlugin = locationPluginFactory(\"vanilla.memoryLocation\", false, MemoryLocationService, MemoryLocationConfig);\n\t\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t\n\t/**\n\t * # Core classes and interfaces\n\t *\n\t * The classes and interfaces that are core to ui-router and do not belong\n\t * to a more specific subsystem (such as resolve).\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module core\n\t */ /** for typedoc */\n\t/** @internalapi */\n\tvar UIRouterPluginBase = (function () {\n\t    function UIRouterPluginBase() {\n\t    }\n\t    UIRouterPluginBase.prototype.dispose = function (router) { };\n\t    return UIRouterPluginBase;\n\t}());\n\t\n\t/**\n\t * @coreapi\n\t * @module common\n\t */ /** */\n\t\n\texports.fromJson = fromJson;\n\texports.toJson = toJson;\n\texports.copy = copy;\n\texports.forEach = forEach;\n\texports.extend = extend;\n\texports.equals = equals;\n\texports.identity = identity;\n\texports.noop = noop;\n\texports.createProxyFunctions = createProxyFunctions;\n\texports.inherit = inherit;\n\texports.inArray = inArray;\n\texports._inArray = _inArray;\n\texports.removeFrom = removeFrom;\n\texports._removeFrom = _removeFrom;\n\texports.pushTo = pushTo;\n\texports._pushTo = _pushTo;\n\texports.deregAll = deregAll;\n\texports.defaults = defaults;\n\texports.mergeR = mergeR;\n\texports.ancestors = ancestors;\n\texports.pick = pick;\n\texports.omit = omit;\n\texports.pluck = pluck;\n\texports.filter = filter;\n\texports.find = find;\n\texports.mapObj = mapObj;\n\texports.map = map;\n\texports.values = values;\n\texports.allTrueR = allTrueR;\n\texports.anyTrueR = anyTrueR;\n\texports.unnestR = unnestR;\n\texports.flattenR = flattenR;\n\texports.pushR = pushR;\n\texports.uniqR = uniqR;\n\texports.unnest = unnest;\n\texports.flatten = flatten;\n\texports.assertPredicate = assertPredicate;\n\texports.assertMap = assertMap;\n\texports.assertFn = assertFn;\n\texports.pairs = pairs;\n\texports.arrayTuples = arrayTuples;\n\texports.applyPairs = applyPairs;\n\texports.tail = tail;\n\texports._extend = _extend;\n\texports.silenceUncaughtInPromise = silenceUncaughtInPromise;\n\texports.silentRejection = silentRejection;\n\texports.notImplemented = notImplemented;\n\texports.services = services;\n\texports.Glob = Glob;\n\texports.curry = curry;\n\texports.compose = compose;\n\texports.pipe = pipe;\n\texports.prop = prop;\n\texports.propEq = propEq;\n\texports.parse = parse;\n\texports.not = not;\n\texports.and = and;\n\texports.or = or;\n\texports.all = all;\n\texports.any = any;\n\texports.is = is;\n\texports.eq = eq;\n\texports.val = val;\n\texports.invoke = invoke;\n\texports.pattern = pattern;\n\texports.isUndefined = isUndefined;\n\texports.isDefined = isDefined;\n\texports.isNull = isNull;\n\texports.isNullOrUndefined = isNullOrUndefined;\n\texports.isFunction = isFunction;\n\texports.isNumber = isNumber;\n\texports.isString = isString;\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isDate = isDate;\n\texports.isRegExp = isRegExp;\n\texports.isState = isState;\n\texports.isInjectable = isInjectable;\n\texports.isPromise = isPromise;\n\texports.Queue = Queue;\n\texports.maxLength = maxLength;\n\texports.padString = padString;\n\texports.kebobString = kebobString;\n\texports.functionToString = functionToString;\n\texports.fnToString = fnToString;\n\texports.stringify = stringify;\n\texports.beforeAfterSubstr = beforeAfterSubstr;\n\texports.splitOnDelim = splitOnDelim;\n\texports.joinNeighborsR = joinNeighborsR;\n\texports.Trace = Trace;\n\texports.trace = trace;\n\texports.Param = Param;\n\texports.ParamTypes = ParamTypes;\n\texports.StateParams = StateParams;\n\texports.ParamType = ParamType;\n\texports.PathNode = PathNode;\n\texports.PathUtils = PathUtils;\n\texports.resolvePolicies = resolvePolicies;\n\texports.defaultResolvePolicy = defaultResolvePolicy;\n\texports.Resolvable = Resolvable;\n\texports.NATIVE_INJECTOR_TOKEN = NATIVE_INJECTOR_TOKEN;\n\texports.ResolveContext = ResolveContext;\n\texports.resolvablesBuilder = resolvablesBuilder;\n\texports.StateBuilder = StateBuilder;\n\texports.StateObject = StateObject;\n\texports.StateMatcher = StateMatcher;\n\texports.StateQueueManager = StateQueueManager;\n\texports.StateRegistry = StateRegistry;\n\texports.StateService = StateService;\n\texports.TargetState = TargetState;\n\texports.HookBuilder = HookBuilder;\n\texports.matchState = matchState;\n\texports.RegisteredHook = RegisteredHook;\n\texports.makeEvent = makeEvent;\n\texports.Rejection = Rejection;\n\texports.Transition = Transition;\n\texports.TransitionHook = TransitionHook;\n\texports.TransitionEventType = TransitionEventType;\n\texports.defaultTransOpts = defaultTransOpts;\n\texports.TransitionService = TransitionService;\n\texports.UrlMatcher = UrlMatcher;\n\texports.UrlMatcherFactory = UrlMatcherFactory;\n\texports.UrlRouter = UrlRouter;\n\texports.UrlRuleFactory = UrlRuleFactory;\n\texports.BaseUrlRule = BaseUrlRule;\n\texports.UrlService = UrlService;\n\texports.ViewService = ViewService;\n\texports.UIRouterGlobals = UIRouterGlobals;\n\texports.UIRouter = UIRouter;\n\texports.$q = $q;\n\texports.$injector = $injector;\n\texports.BaseLocationServices = BaseLocationServices;\n\texports.HashLocationService = HashLocationService;\n\texports.MemoryLocationService = MemoryLocationService;\n\texports.PushStateLocationService = PushStateLocationService;\n\texports.MemoryLocationConfig = MemoryLocationConfig;\n\texports.BrowserLocationConfig = BrowserLocationConfig;\n\texports.splitHash = splitHash;\n\texports.splitQuery = splitQuery;\n\texports.splitEqual = splitEqual;\n\texports.trimHashVal = trimHashVal;\n\texports.keyValsToObjectR = keyValsToObjectR;\n\texports.getParams = getParams;\n\texports.parseUrl = parseUrl$1;\n\texports.buildUrl = buildUrl;\n\texports.locationPluginFactory = locationPluginFactory;\n\texports.servicesPlugin = servicesPlugin;\n\texports.hashLocationPlugin = hashLocationPlugin;\n\texports.pushStateLocationPlugin = pushStateLocationPlugin;\n\texports.memoryLocationPlugin = memoryLocationPlugin;\n\texports.UIRouterPluginBase = UIRouterPluginBase;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t//# sourceMappingURL=ui-router-core.js.map\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  'use strict';\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (root.hasOwnProperty('angular')) {\n\t    // Browser globals (root is window), we don't register it.\n\t    factory(root.angular);\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory(require('angular'));\n\t  }\n\t}(this , function (angular) {\n\t    'use strict';\n\t\n\t    // In cases where Angular does not get passed or angular is a truthy value\n\t    // but misses .module we can fall back to using window.\n\t    angular = (angular && angular.module ) ? angular : window.angular;\n\t\n\t\n\t    function isStorageSupported($window, storageType) {\n\t\n\t      // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n\t      // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n\t      // that error and allow execution to continue.\n\t\n\t      // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n\t      // when \"Block cookies\": \"Always block\" is turned on\n\t      var supported;\n\t      try {\n\t        supported = $window[storageType];\n\t      }\n\t      catch(err) {\n\t        supported = false;\n\t      }\n\t\n\t      // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage and sessionStorage\n\t      // is available, but trying to call .setItem throws an exception below:\n\t      // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n\t      if(supported) {\n\t        var key = '__' + Math.round(Math.random() * 1e7);\n\t        try {\n\t          $window[storageType].setItem(key, key);\n\t          $window[storageType].removeItem(key, key);\n\t        }\n\t        catch(err) {\n\t          supported = false;\n\t        }\n\t      }\n\t\n\t      return supported;\n\t    }\n\t\n\t    /**\n\t     * @ngdoc overview\n\t     * @name ngStorage\n\t     */\n\t\n\t    return angular.module('ngStorage', [])\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$localStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$localStorage', _storageProvider('localStorage'))\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$sessionStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\t\n\t    function _storageProvider(storageType) {\n\t        var providerWebStorage = isStorageSupported(window, storageType);\n\t\n\t        return function () {\n\t          var storageKeyPrefix = 'ngStorage-';\n\t\n\t          this.setKeyPrefix = function (prefix) {\n\t            if (typeof prefix !== 'string') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n\t            }\n\t            storageKeyPrefix = prefix;\n\t          };\n\t\n\t          var serializer = angular.toJson;\n\t          var deserializer = angular.fromJson;\n\t\n\t          this.setSerializer = function (s) {\n\t            if (typeof s !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n\t            }\n\t\n\t            serializer = s;\n\t          };\n\t\n\t          this.setDeserializer = function (d) {\n\t            if (typeof d !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n\t            }\n\t\n\t            deserializer = d;\n\t          };\n\t\n\t          this.supported = function() {\n\t            return !!providerWebStorage;\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.get = function (key) {\n\t            return providerWebStorage && deserializer(providerWebStorage.getItem(storageKeyPrefix + key));\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.set = function (key, value) {\n\t            return providerWebStorage && providerWebStorage.setItem(storageKeyPrefix + key, serializer(value));\n\t          };\n\t\n\t          this.remove = function (key) {\n\t            providerWebStorage && providerWebStorage.removeItem(storageKeyPrefix + key);\n\t          }\n\t\n\t          this.$get = [\n\t              '$rootScope',\n\t              '$window',\n\t              '$log',\n\t              '$timeout',\n\t              '$document',\n\t\n\t              function(\n\t                  $rootScope,\n\t                  $window,\n\t                  $log,\n\t                  $timeout,\n\t                  $document\n\t              ){\n\t\n\t                // The magic number 10 is used which only works for some keyPrefixes...\n\t                // See https://github.com/gsklee/ngStorage/issues/137\n\t                var prefixLength = storageKeyPrefix.length;\n\t\n\t                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n\t                // Note: recheck mainly for testing (so we can use $window[storageType] rather than window[storageType])\n\t                var isSupported = isStorageSupported($window, storageType),\n\t                    webStorage = isSupported || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n\t                    $storage = {\n\t                        $default: function(items) {\n\t                            for (var k in items) {\n\t                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n\t                            }\n\t\n\t                            $storage.$sync();\n\t                            return $storage;\n\t                        },\n\t                        $reset: function(items) {\n\t                            for (var k in $storage) {\n\t                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n\t                            }\n\t\n\t                            return $storage.$default(items);\n\t                        },\n\t                        $sync: function () {\n\t                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n\t                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n\t                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n\t                            }\n\t                        },\n\t                        $apply: function() {\n\t                            var temp$storage;\n\t\n\t                            _debounce = null;\n\t\n\t                            if (!angular.equals($storage, _last$storage)) {\n\t                                temp$storage = angular.copy(_last$storage);\n\t                                angular.forEach($storage, function(v, k) {\n\t                                    if (angular.isDefined(v) && '$' !== k[0]) {\n\t                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n\t                                        delete temp$storage[k];\n\t                                    }\n\t                                });\n\t\n\t                                for (var k in temp$storage) {\n\t                                    webStorage.removeItem(storageKeyPrefix + k);\n\t                                }\n\t\n\t                                _last$storage = angular.copy($storage);\n\t                            }\n\t                        },\n\t                        $supported: function() {\n\t                            return !!isSupported;\n\t                        }\n\t                    },\n\t                    _last$storage,\n\t                    _debounce;\n\t\n\t                $storage.$sync();\n\t\n\t                _last$storage = angular.copy($storage);\n\t\n\t                $rootScope.$watch(function() {\n\t                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n\t                });\n\t\n\t                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n\t                $window.addEventListener && $window.addEventListener('storage', function(event) {\n\t                    if (!event.key) {\n\t                      return;\n\t                    }\n\t\n\t                    // Reference doc.\n\t                    var doc = $document[0];\n\t\n\t                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n\t                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\t\n\t                        _last$storage = angular.copy($storage);\n\t\n\t                        $rootScope.$apply();\n\t                    }\n\t                });\n\t\n\t                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n\t                    $storage.$apply();\n\t                });\n\t\n\t                return $storage;\n\t              }\n\t          ];\n\t      };\n\t    }\n\t\n\t}));\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.default = routing;\n\trouting.$inject = ['$urlRouterProvider', '$locationProvider'];\n\t\n\tfunction routing($urlRouterProvider, $locationProvider) {\n\t\t$locationProvider.hashPrefix('');\n\t\t$locationProvider.html5Mode(true);\n\t\t$urlRouterProvider.otherwise('/');\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.default = run;\n\trun.$inject = ['$rootScope', '$http', '$location', '$localStorage'];\n\t\n\tfunction run($rootScope, $http, $location, $localStorage) {\n\t\tif ($localStorage.currentUser) {\n\t\t\t$http.defaults.headers.common.Authorization = 'Bearer ' + $localStorage.currentUser.token;\n\t\t}\n\t\n\t\t$rootScope.$on('$locationChangeStart', function (event, next, current) {\n\t\t\t//eslint-disable-line no-unused-vars\n\t\t\tvar publicPages = ['/', '/features', '/pricing', '/about', '/login'];\n\t\t\tvar restrictedPage = publicPages.indexOf($location.path()) === -1;\n\t\n\t\t\tif (restrictedPage && !$localStorage.currentUser) {\n\t\t\t\t$location.path('/login');\n\t\t\t}\n\t\t});\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(11);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _navbar = __webpack_require__(12);\n\t\n\tvar _navbar2 = _interopRequireDefault(_navbar);\n\t\n\tvar _navbar3 = __webpack_require__(13);\n\t\n\tvar _navbar4 = _interopRequireDefault(_navbar3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.navbar', [_navbar4.default]).controller('NavbarController', _navbar2.default).name;\n\n/***/ },\n/* 11 */\n1,\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NavbarController = function () {\n\t\tfunction NavbarController($location) {\n\t\t\t_classCallCheck(this, NavbarController);\n\t\n\t\t\tthis.location = $location;\n\t\t\tthis.$ = window.$;\n\t\t\tthis.LoginStatus = 'Login';\n\t\t\tthis.loggedIn = false;\n\t\t}\n\t\n\t\t_createClass(NavbarController, [{\n\t\t\tkey: 'gotoAnchor',\n\t\t\tvalue: function gotoAnchor(id) {\n\t\t\t\tthis.$('html, body').animate({\n\t\t\t\t\tscrollTop: this.$('#' + id).offset().top\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'login',\n\t\t\tvalue: function login() {\n\t\t\t\tif (this.loggedIn) {\n\t\t\t\t\tthis.location.path('/');\n\t\t\t\t\tthis.LoginStatus = 'Login';\n\t\t\t\t} else {\n\t\t\t\t\tthis.location.hash('');\n\t\t\t\t\tthis.location.path('/login');\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn NavbarController;\n\t}();\n\t\n\texports.default = NavbarController;\n\t\n\t\n\tNavbarController.$inject = ['$location'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _navbar = __webpack_require__(14);\n\t\n\tvar _navbar2 = _interopRequireDefault(_navbar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction navbar() {\n\t  return {\n\t    restrict: 'E',\n\t    template: _navbar2.default,\n\t    controller: 'NavbarController',\n\t    controllerAs: 'navbar'\n\t  };\n\t}\n\t\n\texports.default = _angular2.default.module('directives.navbar', []).directive('navbar', navbar).name;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<nav class=\\\"navbar navbar-expand-md navbar-dark bg-dark fixed-top\\\"> <a class=navbar-brand href=/ ng-click=\\\"navbar.gotoAnchor('home')\\\"> <img src=/images/logo-transparent.png width=30 height=30 class=\\\"d-inline-block align-top\\\" alt=\\\"\\\"> ArrowFinds </a> <button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarsExampleDefault aria-controls=navbarsExampleDefault aria-expanded=false aria-label=\\\"Toggle navigation\\\"> <span class=navbar-toggler-icon></span> </button> <div class=\\\"collapse navbar-collapse\\\" id=navbarsExampleDefault> <ul class=\\\"navbar-nav mr-auto\\\"> <li class=\\\"nav-item active\\\"> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('home')\\\">Home<span class=sr-only>(current)</span></a> </li> <li class=nav-item> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('features')\\\">Features</a> </li> <li class=nav-item> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('pricing')\\\">Pricing</a> </li> <li class=nav-item> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('about')\\\">About</a> </li> <li class=nav-item> <a class=nav-link href=/login ng-click=navbar.login()>{{navbar.LoginStatus}}</a> </li> <li class=nav-item> <a class=nav-link href=/affiliate>Affiliate</a> </li> </ul> <form class=\\\"form-inline my-2 my-lg-0\\\"> <input class=\\\"form-control mr-sm-2\\\" type=text placeholder=Search aria-label=Search> <button class=\\\"btn btn-outline-info my-2 my-sm-0\\\" type=submit>Search</button> </form> </div> </nav> \";\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\t__webpack_require__(16);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularjs = __webpack_require__(5);\n\t\n\tvar _angularjs2 = _interopRequireDefault(_angularjs);\n\t\n\tvar _landing = __webpack_require__(17);\n\t\n\tvar _landing2 = _interopRequireDefault(_landing);\n\t\n\tvar _home = __webpack_require__(19);\n\t\n\tvar _home2 = _interopRequireDefault(_home);\n\t\n\tvar _features = __webpack_require__(23);\n\t\n\tvar _features2 = _interopRequireDefault(_features);\n\t\n\tvar _pricing = __webpack_require__(31);\n\t\n\tvar _pricing2 = _interopRequireDefault(_pricing);\n\t\n\tvar _about = __webpack_require__(39);\n\t\n\tvar _about2 = _interopRequireDefault(_about);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.landing', [_angularjs2.default, _home2.default, _features2.default, _pricing2.default, _about2.default]).config(_landing2.default).name;\n\n/***/ },\n/* 16 */\n1,\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = routes;\n\t\n\tvar _landing = __webpack_require__(18);\n\t\n\tvar _landing2 = _interopRequireDefault(_landing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\troutes.$inject = ['$stateProvider'];\n\t\n\tfunction routes($stateProvider) {\n\t  $stateProvider.state('/', {\n\t    url: '/',\n\t    template: _landing2.default\n\t  });\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div id=sections> <home></home> <features></features> <pricing></pricing> <about></about> </div> \";\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(20);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _home = __webpack_require__(21);\n\t\n\tvar _home2 = _interopRequireDefault(_home);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.home', [_home2.default]).name;\n\n/***/ },\n/* 20 */\n1,\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _home = __webpack_require__(22);\n\t\n\tvar _home2 = _interopRequireDefault(_home);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction home() {\n\t  return {\n\t    restrict: 'E',\n\t    template: _home2.default\n\t  };\n\t}\n\t\n\texports.default = _angular2.default.module('directives.home', []).directive('home', home).name;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<header id=home> <div class=\\\"col-lg-12 intro-text text-center\\\"> <img src=/images/logo-transparent.png /> <p class=name>ArrowFinds</p> <p class=description>DropShipping Products Finder</p> </div> </header> \";\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(24);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _features = __webpack_require__(25);\n\t\n\tvar _features2 = _interopRequireDefault(_features);\n\t\n\tvar _feature = __webpack_require__(27);\n\t\n\tvar _feature2 = _interopRequireDefault(_feature);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.features', [_features2.default, _feature2.default]).name;\n\n/***/ },\n/* 24 */\n1,\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _features = __webpack_require__(26);\n\t\n\tvar _features2 = _interopRequireDefault(_features);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction features() {\n\t  return {\n\t    restrict: 'E',\n\t    template: _features2.default\n\t  };\n\t}\n\t\n\texports.default = _angular2.default.module('directives.features', []).directive('features', features).name;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<section id=features> <div class=container> <div class=row> <div class=\\\"col-12 text-truncate features-title\\\"> <p class=\\\"text-center font-weight-bold\\\">Our Features</p> </div> </div> <div class=row> <div class=\\\"card-deck features-card-fix\\\"> <feature image=magnifier.png text=\\\"Find the best DropShipping products for ebay\\\"></feature> <feature image=ecommerce.jpg text=\\\"Find droppers from the largest platforms\\\"></feature> <feature image=affiliate-marketing.jpg text=\\\"Earn money from affiliate program\\\"></feature> <feature image=monitor.jpg text=\\\"Upload your products to your favorite monitor\\\"></feature> </div> </div> </div> </section> \";\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(28);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _feature = __webpack_require__(29);\n\t\n\tvar _feature2 = _interopRequireDefault(_feature);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.features.feature', [_feature2.default]).name;\n\n/***/ },\n/* 28 */\n1,\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _feature = __webpack_require__(30);\n\t\n\tvar _feature2 = _interopRequireDefault(_feature);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction feature() {\n\t  return {\n\t    restrict: 'E',\n\t    template: _feature2.default,\n\t    replace: true,\n\t    scope: {\n\t      image: '@',\n\t      text: '@'\n\t    }\n\t  };\n\t}\n\t\n\texports.default = _angular2.default.module('directives.features.feature', []).directive('feature', feature).name;\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"card feature border-info mb-3\\\"> <img class=\\\"card-img-top border border-top-0 border-right-0 border-left-0 border-bottom border-info\\\" src=/images/{{image}} alt={{image}}> <div class=card-body> <p class=card-text>{{text}}</p> </div> </div> \";\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(32);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _pricing = __webpack_require__(33);\n\t\n\tvar _pricing2 = _interopRequireDefault(_pricing);\n\t\n\tvar _price = __webpack_require__(35);\n\t\n\tvar _price2 = _interopRequireDefault(_price);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.pricing', [_pricing2.default, _price2.default]).name;\n\n/***/ },\n/* 32 */\n1,\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _pricing = __webpack_require__(34);\n\t\n\tvar _pricing2 = _interopRequireDefault(_pricing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction pricing() {\n\t  return {\n\t    restrict: 'E',\n\t    template: _pricing2.default\n\t  };\n\t}\n\t\n\texports.default = _angular2.default.module('directives.pricing', []).directive('pricing', pricing).name;\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<section id=pricing> <div class=\\\"container pricing-footer-margin\\\"> <div class=row> <div class=\\\"col-12 text-truncate pricing-title\\\"> <p class=\\\"text-center font-weight-bold\\\">Pricing</p> </div> </div> <div class=row> <price title=basic cost=9.99 months=1 products=1000></price> <div class=col></div> <price title=premium cost=29.90 months=2 products=5000></price> </div> </div> </section> \";\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(36);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _price = __webpack_require__(37);\n\t\n\tvar _price2 = _interopRequireDefault(_price);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.pricing.price', [_price2.default]).name;\n\n/***/ },\n/* 36 */\n1,\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\tvalue: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _price = __webpack_require__(38);\n\t\n\tvar _price2 = _interopRequireDefault(_price);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction price() {\n\t\t\treturn {\n\t\t\t\t\trestrict: 'E',\n\t\t\t\t\ttemplate: _price2.default,\n\t\t\t\t\treplace: true,\n\t\t\t\t\tscope: {\n\t\t\t\t\t\t\ttitle: '@',\n\t\t\t\t\t\t\tcost: '=',\n\t\t\t\t\t\t\tmonths: '=',\n\t\t\t\t\t\t\tproducts: '='\n\t\t\t\t\t}\n\t\t\t};\n\t}\n\t\n\texports.default = _angular2.default.module('directives.pricing.price', []).directive('price', price).name;\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"card card-pricing col-md-5 col-sm-8 text-center\\\"> <div class=\\\"card-header card-pricing-header\\\"> <h3 class=\\\"card-title white\\\">{{title}}</h3> </div> <div class=\\\"card-body card-pricing-body\\\"> <h4>{{cost | currency}}</h4> <ul class=list-group> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;{{months}} month use</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;{{products}} products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;hottest products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;products and sellers finding</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;24/7 support</i></li> </ul> </div> <div class=\\\"card-footer card-pricing-footer\\\"> <a href=/#!/premium class=\\\"btn btn-lg btn-block card-pricing-button white\\\">Buy now</a> </div> </div> \";\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(40);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _about = __webpack_require__(41);\n\t\n\tvar _about2 = _interopRequireDefault(_about);\n\t\n\tvar _card = __webpack_require__(43);\n\t\n\tvar _card2 = _interopRequireDefault(_card);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.about', [_about2.default, _card2.default]).name;\n\n/***/ },\n/* 40 */\n1,\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _about = __webpack_require__(42);\n\t\n\tvar _about2 = _interopRequireDefault(_about);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction about() {\n\t  return {\n\t    restrict: 'E',\n\t    template: _about2.default\n\t  };\n\t}\n\t\n\texports.default = _angular2.default.module('directives.about', []).directive('about', about).name;\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<section id=about> <div class=container> <div class=\\\"col-12 text-truncate about-title\\\"> <p class=\\\"text-center font-weight-bold\\\">About Us</p> </div> <div class=row> <card name=\\\"Ido Bleicher\\\" role=Co-Founder sentence=\\\"Crazy for money\\\" motto=\\\"To be or not to be..\\\" followers=1335 following=114 projects=58 facebook=https://www.facebook.com/ido.bleicher linkedin=https://www.linkedin.com/in/ido-bleicher-223818137/ github=https://github.com/iuyt9003></card> <card name=\\\"Yonatan Kreiner\\\" role=Co-Founder sentence=\\\"Crazy for motorcycles\\\" motto=\\\"It's not about timing the market it's about time in the market\\\" followers=500 following=110 projects=39 facebook=https://www.facebook.com/yonatankreiner linkedin=https://www.linkedin.com/in/yonatan-kreiner/ github=https://github.com/yonatanKreiner></card> </div> </div> </section> \";\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(44);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _card = __webpack_require__(45);\n\t\n\tvar _card2 = _interopRequireDefault(_card);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.about.card', [_card2.default]).name;\n\n/***/ },\n/* 44 */\n1,\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\tvalue: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _card = __webpack_require__(46);\n\t\n\tvar _card2 = _interopRequireDefault(_card);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction card() {\n\t\t\treturn {\n\t\t\t\t\trestrict: 'E',\n\t\t\t\t\ttemplate: _card2.default,\n\t\t\t\t\treplace: true,\n\t\t\t\t\tscope: {\n\t\t\t\t\t\t\tname: '@',\n\t\t\t\t\t\t\trole: '@',\n\t\t\t\t\t\t\tsentence: '@',\n\t\t\t\t\t\t\tmotto: '@',\n\t\t\t\t\t\t\tfollowers: '@',\n\t\t\t\t\t\t\tfollowing: '@',\n\t\t\t\t\t\t\tprojects: '@',\n\t\t\t\t\t\t\tfacebook: '@',\n\t\t\t\t\t\t\tlinkedin: '@',\n\t\t\t\t\t\t\tgithub: '@'\n\t\t\t\t\t}\n\t\t\t};\n\t}\n\t\n\texports.default = _angular2.default.module('directives.about.card', []).directive('card', card).name;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"col-md-6 col-sm-6\\\"> <div class=card-container> <div class=card> <div class=front> <div class=cover> <img src=/images/beach-beverage-caribbean-cocktail.jpg /> </div> <div class=user> <img class=img-circle src=/images/{{name}}.png /> </div> <div class=content> <div class=main> <h3 class=name>{{name}}</h3> <p class=profession>{{role}}</p> <p class=text-center>\\\"{{sentence}}\\\"</p> </div> </div> <div class=footer> <i class=\\\"fa fa-male\\\" aria-hidden=true></i>&nbsp;&nbsp;ArrowFinds team </div> </div> <div class=back> <div class=header> <h5 class=motto>{{name}}</h5> </div> <div class=content> <div class=main> <h4 class=text-center>{{role}}</h4> <p class=text-center>\\\"{{motto}}\\\"</p> <div class=stats-container> <div class=stats> <h4>{{followers}}</h4> <p>Followers</p> </div> <div class=stats> <h4>{{following}}</h4> <p>Following</p> </div> <div class=stats> <h4>{{projects}}</h4> <p>Projects</p> </div> </div> </div> </div> <div class=footer> <div class=\\\"social-links text-center\\\"> <a href={{facebook}} class=facebook> <i class=\\\"fa fa-facebook fa-fw\\\"></i> </a> <a href={{linkedin}} class=linkedin> <i class=\\\"fa fa-linkedin\\\" aria-hidden=true></i> </a> <a href={{github}} class=github> <i class=\\\"fa fa-github\\\" aria-hidden=true></i> </a> </div> </div> </div> </div> </div> </div> \";\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(48);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularjs = __webpack_require__(5);\n\t\n\tvar _angularjs2 = _interopRequireDefault(_angularjs);\n\t\n\tvar _login = __webpack_require__(49);\n\t\n\tvar _login2 = _interopRequireDefault(_login);\n\t\n\tvar _login3 = __webpack_require__(51);\n\t\n\tvar _login4 = _interopRequireDefault(_login3);\n\t\n\tvar _authentication = __webpack_require__(52);\n\t\n\tvar _authentication2 = _interopRequireDefault(_authentication);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.login', [_angularjs2.default, _authentication2.default]).config(_login2.default).controller('LoginController', _login4.default).name;\n\n/***/ },\n/* 48 */\n1,\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = routes;\n\t\n\tvar _login = __webpack_require__(50);\n\t\n\tvar _login2 = _interopRequireDefault(_login);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\troutes.$inject = ['$stateProvider'];\n\t\n\tfunction routes($stateProvider) {\n\t  $stateProvider.state('login', {\n\t    url: '/login',\n\t    template: _login2.default,\n\t    controller: 'LoginController',\n\t    controllerAs: 'login'\n\t  });\n\t}\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<section id=login-section> <div class=container> <div class=row> <div class=col-2></div> <div class=col-8> <div class=box> <div class=box-icon> <div class=\\\"fa fa-4x fa-user\\\"></div> </div> <h4 class=\\\"title text-center\\\">Register / Login User</h4> <form name=sign novalidate> <div class=\\\"input-group form-row input\\\"> <div class=input-group-addon> <i class=\\\"fa fa-envelope\\\"></i> </div> <input type=email name=email class=\\\"form-control email validate valid\\\" ng-model=login.email placeholder=Email required> <div class=invalid-feedback ng-show=sign.email.$invalid> Email is not valid </div> </div> <div class=\\\"input-group form-row input\\\"> <div class=\\\"input-group-addon lock\\\"> <i class=\\\"fa fa-lock\\\"></i> </div> <input type=password name=password class=\\\"form-control password validate valid\\\" ng-model=login.password placeholder=Password ng-minlength=6 required> <div class=invalid-feedback ng-show=\\\"sign.password.$error.minlength || sign.password.$invalid\\\"> Password must be at least 6 digits </div> </div> <div class=text-center ng-show=login.error> <h3 class=error-show><i class=\\\"fa fa-exclamation-triangle\\\"></i>{{login.error}}</h3> </div> <br/> <div class=\\\"form-group form-row\\\"> <div class=col-4>\\t</div> <div class=col-2> <button type=submit class=\\\"btn btn-success\\\" ng-click=\\\"login.signIn(login.email, login.password)\\\" ng-disabled=\\\"sign.password.$error.minlength || sign.password.$invalid || sign.email.$invalid\\\">Login <i class=\\\"fa fa-sign-in\\\"></i> </button> </div> <div class=col-2> <button type=submit class=\\\"btn btn-success\\\" ng-click=\\\"login.signUp(login.email, login.password)\\\" ng-disabled=\\\"sign.password.$error.minlength || sign.password.$invalid || sign.email.$invalid\\\">Register <i class=\\\"fa fa-user-plus\\\"></i> </button> </div> </div> </form> </div> </div> <div class=col-2></div> </div> </div> </section> \";\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar LoginController = function () {\n\t\tfunction LoginController($location, authentication) {\n\t\t\t_classCallCheck(this, LoginController);\n\t\n\t\t\tthis.location = $location;\n\t\t\tthis.authentication = authentication;\n\t\t\tthis.error = '';\n\t\t}\n\t\n\t\t_createClass(LoginController, [{\n\t\t\tkey: 'signUp',\n\t\t\tvalue: function signUp(email, password) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tthis.authentication.register(email, password).then(function (result) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\t_this.window.ga('send', 'event', 'Users', 'register');\n\t\t\t\t\t\t_this.error = 'An email was sent to your address';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this.error = 'Could not create user. Please try again';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'signIn',\n\t\t\tvalue: function signIn(email, password) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tthis.authentication.login(email, password).then(function (result) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\t_this2.location.path('/monitor');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this2.error = 'Email or password is incorrect';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn LoginController;\n\t}();\n\t\n\texports.default = LoginController;\n\t\n\t\n\tLoginController.$inject = ['$location', 'authentication'];\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Authentication = function () {\n\t\tfunction Authentication($http, $window, $localStorage) {\n\t\t\t_classCallCheck(this, Authentication);\n\t\n\t\t\tthis.http = $http;\n\t\t\tthis.window = $window;\n\t\t\tthis.localStorage = $localStorage;\n\t\t\tthis.api = 'http://127.0.0.1:5000/';\n\t\t}\n\t\n\t\t_createClass(Authentication, [{\n\t\t\tkey: 'register',\n\t\t\tvalue: function register(email, password) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\treturn this.http.post(this.api + 'users', { email: email, password: password }).then(function (response) {\n\t\t\t\t\t//eslint-disable-line no-unused-vars\n\t\t\t\t\treturn true;\n\t\t\t\t}, function (err) {\n\t\t\t\t\tif (_this.window.analytics) {\n\t\t\t\t\t\t_this.window.analytics('event', 'exception', {\n\t\t\t\t\t\t\tdescription: err.status + ': ' + err.message,\n\t\t\t\t\t\t\tfatal: false\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'login',\n\t\t\tvalue: function login(email, password) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\treturn this.http.post(this.api + 'auth', { email: email, password: password }).then(function (response) {\n\t\t\t\t\tif (response.data) {\n\t\t\t\t\t\t_this2.localStorage.currentUser = { email: email, token: response.data };\n\t\t\t\t\t\t_this2.http.defaults.headers.common.Authorization = 'Bearer ' + response.data;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}, function (err) {\n\t\t\t\t\tif (_this2.window.analytics) {\n\t\t\t\t\t\t_this2.window.analytics('event', 'exception', {\n\t\t\t\t\t\t\tdescription: err.status + ': ' + err.data,\n\t\t\t\t\t\t\tfatal: false\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'logout',\n\t\t\tvalue: function logout() {\n\t\t\t\tdelete this.localStorage.currentUser;\n\t\t\t\tthis.http.defaults.headers.common.Authorization = '';\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTokenData',\n\t\t\tvalue: function getTokenData(key) {\n\t\t\t\tvar encodedToken = this.localStorage.currentUser.token;\n\t\t\t\tvar decodedToken = atob(encodedToken.split('.')[1]);\n\t\t\t\tvar data = JSON.parse(decodedToken);\n\t\n\t\t\t\treturn data[key];\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Authentication;\n\t}();\n\t\n\texports.default = _angular2.default.module('services.authentication', []).service('authentication', Authentication).name;\n\t\n\t\n\tAuthentication.$inject = ['$http', '$window', '$localStorage'];\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\t__webpack_require__(54);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularjs = __webpack_require__(5);\n\t\n\tvar _angularjs2 = _interopRequireDefault(_angularjs);\n\t\n\tvar _monitor = __webpack_require__(55);\n\t\n\tvar _monitor2 = _interopRequireDefault(_monitor);\n\t\n\tvar _monitor3 = __webpack_require__(57);\n\t\n\tvar _monitor4 = _interopRequireDefault(_monitor3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.monitor', [_angularjs2.default]).config(_monitor2.default).controller('MonitorController', _monitor4.default).name;\n\n/***/ },\n/* 54 */\n1,\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.default = routes;\n\t\n\tvar _monitor = __webpack_require__(56);\n\t\n\tvar _monitor2 = _interopRequireDefault(_monitor);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\troutes.$inject = ['$stateProvider'];\n\t\n\tfunction routes($stateProvider) {\n\t\t$stateProvider.state('monitor', {\n\t\t\turl: '/monitor',\n\t\t\ttemplate: _monitor2.default,\n\t\t\tcontroller: 'MonitorController',\n\t\t\tcontrollerAs: 'monitor'\n\t\t});\n\t}\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"{{monitor.user}} \";\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar MonitorController = function () {\n\t\tfunction MonitorController($location, userdata) {\n\t\t\t_classCallCheck(this, MonitorController);\n\t\n\t\t\tthis.location = $location;\n\t\t\tthis.error = '';\n\t\t\tthis.userdata = userdata;\n\t\t}\n\t\n\t\t_createClass(MonitorController, [{\n\t\t\tkey: 'GetUserData',\n\t\t\tvalue: function GetUserData() {\n\t\t\t\tthis.user = this.userdata.GetUserData();\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn MonitorController;\n\t}();\n\t\n\texports.default = MonitorController;\n\t\n\t\n\tMonitorController.$inject = ['$location', 'userdata'];\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(59);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularjs = __webpack_require__(5);\n\t\n\tvar _angularjs2 = _interopRequireDefault(_angularjs);\n\t\n\tvar _affiliate = __webpack_require__(60);\n\t\n\tvar _affiliate2 = _interopRequireDefault(_affiliate);\n\t\n\tvar _affiliate3 = __webpack_require__(62);\n\t\n\tvar _affiliate4 = _interopRequireDefault(_affiliate3);\n\t\n\tvar _authentication = __webpack_require__(52);\n\t\n\tvar _authentication2 = _interopRequireDefault(_authentication);\n\t\n\tvar _userdata = __webpack_require__(63);\n\t\n\tvar _userdata2 = _interopRequireDefault(_userdata);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.affiliate', [_angularjs2.default, _authentication2.default, _userdata2.default]).config(_affiliate2.default).controller('AffiliateController', _affiliate4.default).name;\n\n/***/ },\n/* 59 */\n1,\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = routes;\n\t\n\tvar _affiliate = __webpack_require__(61);\n\t\n\tvar _affiliate2 = _interopRequireDefault(_affiliate);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\troutes.$inject = ['$stateProvider'];\n\t\n\tfunction routes($stateProvider) {\n\t  $stateProvider.state('affiliate', {\n\t    url: '/affiliate',\n\t    template: _affiliate2.default,\n\t    controller: 'AffiliateController',\n\t    controllerAs: 'affiliate'\n\t  });\n\t}\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<section id=affliate> <div class=container> <div class=row> <div class=\\\"col-md-12 col-sm-12\\\"> <h1>Welcome to the affiliate page: {{affiliate.email}} </h1> <div> <h2>Here is your ref code: </h2> <div> <code><h4>https://arrowfinds.com/aff?ref={{affiliate.userCode}}</h4></code> </div> <br/> <h5>You Have: <span style=color:green>{{affiliate.needpay | currency:'USD$':2}}</span> </h5> <button class=\\\"btn btn-primary\\\"> <i class=\\\"fa fa-credit-card-alt\\\"></i> Checkout</button> <h5> <span style=color:red>Only when 10$+</span> </h5> </div> <div> <h4>Precentage: {{(affiliate.profit / affiliate.stage ) * 100 | currency:'%':2}} </h4> <div style=display:flex> <h5 style=margin-top:10%>{{affiliate.reward}}</h5> </div> </div> </div> </div> <div class=row> <div id=skillgraph class=\\\"panel panel-default row\\\"> <div class=\\\"panel-title text-Left\\\"></div> <div class=\\\"row skill-row\\\"> <span class=skillLabel>To Next level: </span> <code>More - {{(affiliate.stage - affiliate.profit) | currency:'USD$':2}} To go!</code> <br/> <span class=skillData-Wrapper> <span class=\\\"skillData bg\\\" style=background-color:green data-percent=100> {{affiliate.level}} - {{(affiliate.profit / affiliate.userStage) * 100 | currency:'%':2}}</span> </span> </div> <div class=\\\"row skill-row\\\"> <span class=skillLabel>Total Sold:</span> <code>Your Profit - {{affiliate.needpay | currency:'USD$':2}}</code> <br/> <span class=skillData-Wrapper> <span class=\\\"skillData bg-rust\\\" data-percent=100>{{affiliate.profit | currency:'USD$':2}}</span> </span> </div> <div class=\\\"row skill-row\\\"> <span class=skillLabel>Ref Joined Count:</span> <span class=skillData-Wrapper> <span class=\\\"skillData bg-blue\\\" data-percent=100>RefCounts - {{affiliate.usersReferred}}</span> </span> </div> </div> </div> </div> </section> \";\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar AffiliateController = function () {\n\t\tfunction AffiliateController(authentication, userdata) {\n\t\t\t_classCallCheck(this, AffiliateController);\n\t\n\t\t\tthis.authentication = authentication;\n\t\t\tthis.userdata = userdata;\n\t\t\tthis.api = 'http://127.0.0.1:5000/';\n\t\t\tthis.userCode = this.getUserCode();\n\t\t}\n\t\n\t\t_createClass(AffiliateController, [{\n\t\t\tkey: 'getUserCode',\n\t\t\tvalue: function getUserCode() {\n\t\t\t\treturn this.authentication.getTokenData('sub');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getAffiliateData',\n\t\t\tvalue: function getAffiliateData() {\n\t\t\t\tvar affiliateData = this.userdata.getAffiliateData();\n\t\t\t\tthis.paypal = affiliateData.paypal;\n\t\t\t\tthis.usersReferred = affiliateData.users_referred;\n\t\t\t\tthis.profit = affiliateData.profit;\n\t\t\t\tthis.checkout = affiliateData.checkout;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn AffiliateController;\n\t}();\n\t\n\texports.default = AffiliateController;\n\t\n\t\n\tAffiliateController.$inject = ['authentication', 'userdata'];\n\t\n\t// Maybe needs this if not remove\n\t// this.textRank = \"\";\n\t// this.reward = \"\";\n\t// this.userStage = 500;\n\t// this.level = \"level1\";\n\t\n\t// var USER_FIRST_PRICE = 500\n\t// var USER_SECOND_PRICE = 1500\n\t// var USER_THIRD_PRICE = 3000\n\t// var USER_FOURTH_PRICE = 6000\n\t// var USER_FIFTH_PRICE = 10000\n\t\n\t// var Userprofit = this.$rootScope.profit;\n\t\n\t// // Calculate User stage - i know about switch case, next version i will add it. (i know you reading it ;) )\n\t// if (Userprofit < USER_FIFTH_PRICE)\n\t// {\n\t// \tif (Userprofit < USER_FOURTH_PRICE)\n\t// \t{\n\t// \t\tif (Userprofit < USER_THIRD_PRICE)\n\t// \t\t{\n\t// \t\t\tif(Userprofit < USER_SECOND_PRICE)\n\t// \t\t\t{\n\t// \t\t\t\tif(Userprofit < USER_FIRST_PRICE)\n\t// \t\t\t\t{\n\t// \t\t\t\t\tthis.userStage = USER_FIRST_PRICE\n\t// \t\t\t\t\tthis.textRank = \"Level 1 - warrior you can rank better! Profit 10%\"\n\t// \t\t\t\t\tthis.level = \"Level1\"\n\t// \t\t\t\t}\n\t// \t\t\t\telse\n\t// \t\t\t\t{\n\t// \t\t\t\t\tthis.userStage = USER_SECOND_PRICE\n\t// \t\t\t\t\tthis.textRank = \"Level 2 - amazing! you are on the right way! Profit 15%\"\n\t// \t\t\t\t\tthis.level = \"Level2\"\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t\telse\n\t// \t\t\t{\n\t// \t\t\t\tthis.userStage = USER_THIRD_PRICE\n\t// \t\t\t\tthis.textRank = \"Level 3 - Achivement Unlocked! Professonial! Profit 20%\"\n\t// \t\t\t\tthis.level = \"Level3\"\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\telse\n\t// \t\t{\n\t// \t\t\tthis.userStage = USER_FOURTH_PRICE\n\t// \t\t\tthis.textRank = \"Level 4 - Unbeliveable! Wow ... You are PRO! Profit 25%\"\n\t// \t\t\tthis.level = \"Level4\"\n\t// \t\t}\n\t// \t}\n\t// \telse\n\t// \t{\n\t// \t\tthis.userStage = USER_FIFTH_PRICE\n\t// \t\tthis.textRank = \"Level 5 - You are the master! tell me how you did that. Profit 30%\"\n\t// \t\tthis.level = \"Level5\"\n\t// \t}\n\t// }\n\t// this.reward = \"When passing this limit \"+ this.userStage + \" Get \" + this.userStage*0.05 + \"$USD as Reword!\"\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar UserData = function () {\n\t\tfunction UserData($http, $window, $localStorage) {\n\t\t\t_classCallCheck(this, UserData);\n\t\n\t\t\tthis.http = $http;\n\t\t\tthis.window = $window;\n\t\t\tthis.localStorage = $localStorage;\n\t\t\tthis.api = 'http://127.0.0.1:5000/';\n\t\t}\n\t\n\t\t_createClass(UserData, [{\n\t\t\tkey: 'getUserData',\n\t\t\tvalue: function getUserData() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tif (this.localStorage.userdata != null) {\n\t\t\t\t\treturn this.localStorage.userdata;\n\t\t\t\t} else {\n\t\t\t\t\tthis.http.get('http://127.0.0.1:5000/api/GetUserData').success(function (response) {\n\t\t\t\t\t\t_this.localStorage.userdata = response.data;\n\t\t\t\t\t\treturn _this.localStorage.userdata;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getAffiliateData',\n\t\t\tvalue: function getAffiliateData() {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\treturn this.http.get(this.api + 'affiliates').then(function (response) {\n\t\t\t\t\treturn response.data;\n\t\t\t\t}, function (err) {\n\t\t\t\t\tif (_this2.window.analytics) {\n\t\t\t\t\t\t_this2.window.analytics('event', 'exception', {\n\t\t\t\t\t\t\tdescription: err.status + ': ' + err.message,\n\t\t\t\t\t\t\tfatal: false\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn UserData;\n\t}();\n\t\n\texports.default = _angular2.default.module('services.userdata', []).service('userdata', UserData).name;\n\t\n\t\n\tUserData.$inject = ['$http', '$window', '$localStorage'];\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(65);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularjs = __webpack_require__(5);\n\t\n\tvar _angularjs2 = _interopRequireDefault(_angularjs);\n\t\n\tvar _deals = __webpack_require__(66);\n\t\n\tvar _deals2 = _interopRequireDefault(_deals);\n\t\n\tvar _deals3 = __webpack_require__(68);\n\t\n\tvar _deals4 = _interopRequireDefault(_deals3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('arrowfinds.deals', [_angularjs2.default]).config(_deals2.default).controller('DealsController', _deals4.default).name;\n\n/***/ },\n/* 65 */\n1,\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = routes;\n\t\n\tvar _deals = __webpack_require__(67);\n\t\n\tvar _deals2 = _interopRequireDefault(_deals);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\troutes.$inject = ['$stateProvider'];\n\t\n\tfunction routes($stateProvider) {\n\t  $stateProvider.state('deals', {\n\t    url: '/deals',\n\t    template: _deals2.default,\n\t    controller: 'DealsController',\n\t    controllerAs: 'deals'\n\t  });\n\t}\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <section id=deals-section> <div class=\\\"container pricing-footer-margin\\\"> <div class=row> <div class=\\\"col-12 text-truncate pricing-title\\\"> <p class=\\\"text-center font-weight-bold\\\">Pricing</p> </div> </div> <div class=row> <div class=\\\"card card-pricing col-md-5 col-sm-8 text-center\\\"> <div class=\\\"card-header card-pricing-header\\\"> <h3 class=\\\"card-title white\\\">Basic</h3> </div> <div class=\\\"card-body card-pricing-body\\\"> <h4>$9.90</h4> <ul class=list-group> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;one month use</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;hottest products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;products and sellers finding</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;24/7 support</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;up to 12,000 products for month!</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;free week use</i></li> </ul> </div> <div class=\\\"card-footer card-pricing-footer\\\"> <button id=paypal-button></button> </div> </div> <div class=col></div> <div class=\\\"card card-pricing col-md-5 col-sm-8 text-center\\\"> <div class=\\\"card-header card-pricing-header\\\"> <h3 class=\\\"card-title white\\\">Premium</h3> </div> <div class=\\\"card-body card-pricing-body\\\"> <h4>$29.90</h4> <ul class=list-group> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;3 monthes use</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;hottest products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;products and sellers finding</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;24/7 support</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;up to 16,000 products for month!</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;free week use</i></li> </ul> </div> <div class=\\\"card-footer card-pricing-footer\\\"> <button id=paypal-button1></button> </div> </div> </div> </div> </section> \";\n\n/***/ },\n/* 68 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\tvalue: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DealsController = function DealsController(http, window) {\n\t\t\t_classCallCheck(this, DealsController);\n\t\n\t\t\tthis.urlTest = 'http://127.0.0.1:5000';\n\t\t\tthis.$http = http;\n\t\t\tthis.$window = window;\n\t\n\t\t\tthis.$http.get('/api/checkifuserlogged', {\n\t\t\t\t\theaders: {}\n\t\t\t}).then(function (response) {\n\t\t\t\t\tif (response.data == \"false\") {\n\t\t\t\t\t\t\tthis.$window.location.href = \"/Login\";\n\t\t\t\t\t}\n\t\t\t}, function (x) {\n\t\t\t\t\talert(x);\n\t\t\t});\n\t};\n\t\n\texports.default = DealsController;\n\t\n\t\n\tDealsController.$inject = ['$http', '$window'];\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** main.628e1f0bb7939d35db16.js\n **/","import './index.css';\r\n\r\nimport angular from 'angular';\r\nimport uirouter from '@uirouter/angularjs';\r\nimport ngstorage from 'ngstorage';\r\n\r\nimport routing from './index.config';\r\nimport run from './index.run';\r\n\r\nimport navbar from './components/navbar';\r\nimport landing from './components/landing';\r\nimport login from './components/login';\r\nimport monitor from './components/monitor';\r\nimport affiliate from './components/affiliate';\r\nimport deals from './components/deals';\r\n\r\n\r\nangular.module('arrowfinds', [uirouter, ngstorage.name, navbar, landing, login, monitor, affiliate, deals])\r\n\t.config(routing)\r\n\t.run(run);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * State-based routing for AngularJS 1.x\n * This bundle requires the ui-router-core.js bundle from the @uirouter/core package.\n * @version v1.0.6\n * @link https://ui-router.github.io\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('angular'), require('@uirouter/core')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'angular', '@uirouter/core'], factory) :\n    (factory((global['@uirouter/angularjs'] = global['@uirouter/angularjs'] || {}),global.angular,global['@uirouter/core']));\n}(this, (function (exports,ng_from_import,_uirouter_core) { 'use strict';\n\nvar ng_from_global = angular;\nvar ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n\nfunction getNg1ViewConfigFactory() {\n    var templateFactory = null;\n    return function (path, view) {\n        templateFactory = templateFactory || _uirouter_core.services.$injector.get(\"$templateFactory\");\n        return [new Ng1ViewConfig(path, view, templateFactory)];\n    };\n}\nvar hasAnyKey = function (keys, obj) {\n    return keys.reduce(function (acc, key) { return acc || _uirouter_core.isDefined(obj[key]); }, false);\n};\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n */\nfunction ng1ViewsBuilder(state) {\n    // Do not process root state\n    if (!state.parent)\n        return {};\n    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n    // Do not allow a state to have both state-level props and also a `views: {}` property.\n    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n    if (_uirouter_core.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n            \"Move the following properties into a view (in the 'views' object): \" +\n            (\" \" + allViewKeys.filter(function (key) { return _uirouter_core.isDefined(state[key]); }).join(\", \")));\n    }\n    var views = {}, viewsObject = state.views || { \"$default\": _uirouter_core.pick(state, allViewKeys) };\n    _uirouter_core.forEach(viewsObject, function (config, name) {\n        // Account for views: { \"\": { template... } }\n        name = name || \"$default\";\n        // Account for views: { header: \"headerComponent\" }\n        if (_uirouter_core.isString(config))\n            config = { component: config };\n        // Make a shallow copy of the config object\n        config = _uirouter_core.extend({}, config);\n        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n            throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n        }\n        config.resolveAs = config.resolveAs || '$resolve';\n        config.$type = \"ng1\";\n        config.$context = state;\n        config.$name = name;\n        var normalized = _uirouter_core.ViewService.normalizeUIViewTarget(config.$context, config.$name);\n        config.$uiViewName = normalized.uiViewName;\n        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n        views[name] = config;\n    });\n    return views;\n}\nvar id = 0;\nvar Ng1ViewConfig = (function () {\n    function Ng1ViewConfig(path, viewDecl, factory) {\n        var _this = this;\n        this.path = path;\n        this.viewDecl = viewDecl;\n        this.factory = factory;\n        this.$id = id++;\n        this.loaded = false;\n        this.getTemplate = function (uiView, context) {\n            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;\n        };\n    }\n    Ng1ViewConfig.prototype.load = function () {\n        var _this = this;\n        var $q = _uirouter_core.services.$q;\n        var context = new _uirouter_core.ResolveContext(this.path);\n        var params = this.path.reduce(function (acc, node) { return _uirouter_core.extend(acc, node.paramValues); }, {});\n        var promises = {\n            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n            controller: $q.when(this.getController(context))\n        };\n        return $q.all(promises).then(function (results) {\n            _uirouter_core.trace.traceViewServiceEvent(\"Loaded\", _this);\n            _this.controller = results.controller;\n            _uirouter_core.extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n            return _this;\n        });\n    };\n    /**\n     * Gets the controller for a view configuration.\n     *\n     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n     */\n    Ng1ViewConfig.prototype.getController = function (context) {\n        var provider = this.viewDecl.controllerProvider;\n        if (!_uirouter_core.isInjectable(provider))\n            return this.viewDecl.controller;\n        var deps = _uirouter_core.services.$injector.annotate(provider);\n        var providerFn = _uirouter_core.isArray(provider) ? _uirouter_core.tail(provider) : provider;\n        var resolvable = new _uirouter_core.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    return Ng1ViewConfig;\n}());\n\n/** @module view */\n/** for typedoc */\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nvar TemplateFactory = (function () {\n    function TemplateFactory() {\n        var _this = this;\n        /** @hidden */ this._useHttp = ng.version.minor < 3;\n        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n                _this.$http = $http;\n                _this.$templateCache = $templateCache;\n                return _this;\n            }];\n    }\n    /** @hidden */\n    TemplateFactory.prototype.useHttpService = function (value) {\n        this._useHttp = value;\n    };\n    \n    /**\n     * Creates a template from a configuration object.\n     *\n     * @param config Configuration object for which to load a template.\n     * The following properties are search in the specified order, and the first one\n     * that is defined is used to create the template:\n     *\n     * @param params  Parameters to pass to the template function.\n     * @param context The resolve context associated with the template's view\n     *\n     * @return {string|object}  The template html as a string, or a promise for\n     * that string,or `null` if no template is configured.\n     */\n    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n        var defaultTemplate = \"<ui-view></ui-view>\";\n        var asTemplate = function (result) { return _uirouter_core.services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n        var asComponent = function (result) { return _uirouter_core.services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n        return (_uirouter_core.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :\n            _uirouter_core.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n                _uirouter_core.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n                    _uirouter_core.isDefined(config.component) ? asComponent(config.component) :\n                        _uirouter_core.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n                            asTemplate(defaultTemplate));\n    };\n    \n    /**\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param template html template as a string or function that returns an html template as a string.\n     * @param params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that\n     * string.\n     */\n    TemplateFactory.prototype.fromString = function (template, params) {\n        return _uirouter_core.isFunction(template) ? template(params) : template;\n    };\n    \n    /**\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function\n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromUrl = function (url, params) {\n        if (_uirouter_core.isFunction(url))\n            url = url(params);\n        if (url == null)\n            return null;\n        if (this._useHttp) {\n            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n                .then(function (response) {\n                return response.data;\n            });\n        }\n        return this.$templateRequest(url);\n    };\n    \n    /**\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n        var deps = _uirouter_core.services.$injector.annotate(provider);\n        var providerFn = _uirouter_core.isArray(provider) ? _uirouter_core.tail(provider) : provider;\n        var resolvable = new _uirouter_core.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    \n    /**\n     * Creates a component's template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n        var deps = _uirouter_core.services.$injector.annotate(provider);\n        var providerFn = _uirouter_core.isArray(provider) ? _uirouter_core.tail(provider) : provider;\n        var resolvable = new _uirouter_core.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    \n    /**\n     * Creates a template from a component's name\n     *\n     * This implements route-to-component.\n     * It works by retrieving the component (directive) metadata from the injector.\n     * It analyses the component's bindings, then constructs a template that instantiates the component.\n     * The template wires input and output bindings to resolves or from the parent component.\n     *\n     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n     * @param component {string} Component's name in camel case.\n     * @param bindings An object defining the component's bindings: {foo: '<'}\n     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n        bindings = bindings || {};\n        // Bind once prefix\n        var prefix = ng.version.minor >= 3 ? \"::\" : \"\";\n        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n        var kebob = function (camelCase) {\n            var kebobed = _uirouter_core.kebobString(camelCase);\n            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n        };\n        var attributeTpl = function (input) {\n            var name = input.name, type = input.type;\n            var attrName = kebob(name);\n            // If the ui-view has an attribute which matches a binding on the routed component\n            // then pass that attribute through to the routed component template.\n            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n            if (uiView.attr(attrName) && !bindings[name])\n                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n            var resolveName = bindings[name] || name;\n            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n            if (type === '@')\n                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n            // Wire \"&\" callbacks to resolves that return a callback function\n            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n            if (type === '&') {\n                var res = context.getResolvable(resolveName);\n                var fn = res && res.data;\n                var args = fn && _uirouter_core.services.$injector.annotate(fn) || [];\n                // account for array style injection, i.e., ['foo', function(foo) {}]\n                var arrayIdxStr = _uirouter_core.isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(\",\") + \")'\";\n            }\n            // some-attr=\"::$resolve.someResolveName\"\n            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n        };\n        var attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n        var kebobName = kebob(component);\n        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n    };\n    \n    return TemplateFactory;\n}());\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name) {\n    var cmpDefs = _uirouter_core.services.$injector.get(name + \"Directive\"); // could be multiple\n    if (!cmpDefs || !cmpDefs.length)\n        throw new Error(\"Unable to find component named '\" + name + \"'\");\n    return cmpDefs.map(getBindings).reduce(_uirouter_core.unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nvar getBindings = function (def) {\n    if (_uirouter_core.isObject(def.bindToController))\n        return scopeBindings(def.bindToController);\n    return scopeBindings(def.scope);\n};\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n    .filter(function (tuple) { return _uirouter_core.isDefined(tuple) && _uirouter_core.isArray(tuple[1]); })\n    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };\n\n/** @module ng1 */ /** for typedoc */\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nvar StateProvider = (function () {\n    function StateProvider(stateRegistry, stateService) {\n        this.stateRegistry = stateRegistry;\n        this.stateService = stateService;\n        _uirouter_core.createProxyFunctions(_uirouter_core.val(StateProvider.prototype), this, _uirouter_core.val(this));\n    }\n    /**\n     * Decorates states when they are registered\n     *\n     * Allows you to extend (carefully) or override (at your own peril) the\n     * `stateBuilder` object used internally by [[StateRegistry]].\n     * This can be used to add custom functionality to ui-router,\n     * for example inferring templateUrl based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new\n     * properties within the state's internal definition. There is currently no clear\n     * use-case for this beyond accessing internal states (i.e. $state.$current),\n     * however, expect this to become increasingly relevant as we introduce additional\n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of\n     * execution of the builder functions in non-deterministic. Builder functions\n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to\n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view\n     *   name (i.e. \"viewName@stateName\") and each value is the config object\n     *   (template, controller) for the view. Even when you don't use the views object\n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template\n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state.\n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that\n     *   would pass a `$state.includes()` test.\n     *\n     * #### Example:\n     * Override the internal 'views' builder with a function that takes the state\n     * definition, and a reference to the internal function being overridden:\n     * ```js\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   let result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     let autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     * ```\n     *\n     *\n     * ```js\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * $state.go('home');\n     * ```\n     *\n     * @param {string} name The name of the builder function to decorate.\n     * @param {object} func A function that is responsible for decorating the original\n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    StateProvider.prototype.decorator = function (name, func) {\n        return this.stateRegistry.decorator(name, func) || this;\n    };\n    StateProvider.prototype.state = function (name, definition) {\n        if (_uirouter_core.isObject(name)) {\n            definition = name;\n        }\n        else {\n            definition.name = name;\n        }\n        this.stateRegistry.register(definition);\n        return this;\n    };\n    /**\n     * Registers an invalid state handler\n     *\n     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n     */\n    StateProvider.prototype.onInvalid = function (callback) {\n        return this.stateService.onInvalid(callback);\n    };\n    return StateProvider;\n}());\n\n/** @module ng1 */ /** */\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n */\nvar getStateHookBuilder = function (hookName) {\n    return function stateHookBuilder(state, parentFn) {\n        var hook = state[hookName];\n        var pathname = hookName === 'onExit' ? 'from' : 'to';\n        function decoratedNg1Hook(trans, state) {\n            var resolveContext = new _uirouter_core.ResolveContext(trans.treeChanges(pathname));\n            var locals = _uirouter_core.extend(getLocals(resolveContext), { $state$: state, $transition$: trans });\n            return _uirouter_core.services.$injector.invoke(hook, this, locals);\n        }\n        return hook ? decoratedNg1Hook : undefined;\n    };\n};\n\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n */\nvar Ng1LocationServices = (function () {\n    function Ng1LocationServices($locationProvider) {\n        // .onChange() registry\n        this._urlListeners = [];\n        this.$locationProvider = $locationProvider;\n        var _lp = _uirouter_core.val($locationProvider);\n        _uirouter_core.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n    }\n    Ng1LocationServices.prototype.dispose = function () { };\n    Ng1LocationServices.prototype.onChange = function (callback) {\n        var _this = this;\n        this._urlListeners.push(callback);\n        return function () { return _uirouter_core.removeFrom(_this._urlListeners)(callback); };\n    };\n    Ng1LocationServices.prototype.html5Mode = function () {\n        var html5Mode = this.$locationProvider.html5Mode();\n        html5Mode = _uirouter_core.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n        return html5Mode && this.$sniffer.history;\n    };\n    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n        if (replace === void 0) { replace = false; }\n        if (newUrl)\n            this.$location.url(newUrl);\n        if (replace)\n            this.$location.replace();\n        if (state)\n            this.$location.state(state);\n        return this.$location.url();\n    };\n    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {\n        var _this = this;\n        this.$location = $location;\n        this.$sniffer = $sniffer;\n        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n        var _loc = _uirouter_core.val($location);\n        var _browser = _uirouter_core.val($browser);\n        // Bind these LocationService functions to $location\n        _uirouter_core.createProxyFunctions(_loc, this, _loc, [\"replace\", \"path\", \"search\", \"hash\"]);\n        // Bind these LocationConfig functions to $location\n        _uirouter_core.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n        // Bind these LocationConfig functions to $browser\n        _uirouter_core.createProxyFunctions(_browser, this, _browser, ['baseHref']);\n    };\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     * @param router\n     */\n    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n        var pathType = router.urlMatcherFactory.type('path');\n        pathType.encode = function (val$$1) {\n            return val$$1 != null ? val$$1.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : val$$1;\n        };\n        pathType.decode = function (val$$1) {\n            return val$$1 != null ? val$$1.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : val$$1;\n        };\n    };\n    return Ng1LocationServices;\n}());\n\n/** @module url */ /** */\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @deprecated\n */\nvar UrlRouterProvider = (function () {\n    /** @hidden */\n    function UrlRouterProvider(router) {\n        this._router = router;\n        this._urlRouter = router.urlRouter;\n    }\n    /** @hidden */\n    UrlRouterProvider.prototype.$get = function () {\n        var urlRouter = this._urlRouter;\n        urlRouter.update(true);\n        if (!urlRouter.interceptDeferred)\n            urlRouter.listen();\n        return urlRouter;\n    };\n    /**\n     * Registers a url handler function.\n     *\n     * Registers a low level url handler (a `rule`).\n     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n     *\n     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param ruleFn\n     * Handler function that takes `$injector` and `$location` services as arguments.\n     * You can use them to detect a url and return a different url as a string.\n     *\n     * @return [[UrlRouterProvider]] (`this`)\n     */\n    UrlRouterProvider.prototype.rule = function (ruleFn) {\n        var _this = this;\n        if (!_uirouter_core.isFunction(ruleFn))\n            throw new Error(\"'rule' must be a function\");\n        var match = function () {\n            return ruleFn(_uirouter_core.services.$injector, _this._router.locationService);\n        };\n        var rule = new _uirouter_core.BaseUrlRule(match, _uirouter_core.identity);\n        this._urlRouter.rule(rule);\n        return this;\n    };\n    \n    /**\n     * Defines the path or behavior to use when no url can be matched.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * ```\n     *\n     * @param rule\n     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    UrlRouterProvider.prototype.otherwise = function (rule) {\n        var _this = this;\n        var urlRouter = this._urlRouter;\n        if (_uirouter_core.isString(rule)) {\n            urlRouter.otherwise(rule);\n        }\n        else if (_uirouter_core.isFunction(rule)) {\n            urlRouter.otherwise(function () { return rule(_uirouter_core.services.$injector, _this._router.locationService); });\n        }\n        else {\n            throw new Error(\"'rule' must be a string or function\");\n        }\n        return this;\n    };\n    \n    /**\n     * Registers a handler for a given url matching.\n     *\n     * If the handler is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable.\n     * It gets invoked if `$location` matches.\n     * You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n     *\n     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n     */\n    UrlRouterProvider.prototype.when = function (what, handler) {\n        if (_uirouter_core.isArray(handler) || _uirouter_core.isFunction(handler)) {\n            handler = UrlRouterProvider.injectableHandler(this._router, handler);\n        }\n        this._urlRouter.when(what, handler);\n        return this;\n    };\n    \n    UrlRouterProvider.injectableHandler = function (router, handler) {\n        return function (match) {\n            return _uirouter_core.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n        };\n    };\n    /**\n     * Disables monitoring of the URL.\n     *\n     * Call this method before UI-Router has bootstrapped.\n     * It will stop UI-Router from performing the initial url sync.\n     *\n     * This can be useful to perform some asynchronous initialization before the router starts.\n     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   $urlRouterProvider.deferIntercept();\n     * })\n     *\n     * app.run(function (MyService, $urlRouter, $http) {\n     *   $http.get(\"/stuff\").then(function(resp) {\n     *     MyService.doStuff(resp.data);\n     *     $urlRouter.listen();\n     *     $urlRouter.sync();\n     *   });\n     * });\n     * ```\n     *\n     * @param defer Indicates whether to defer location change interception.\n     *        Passing no parameter is equivalent to `true`.\n     */\n    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n        this._urlRouter.deferIntercept(defer);\n    };\n    \n    return UrlRouterProvider;\n}());\n\n/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @module ng1\n * @preferred\n */\n/** for typedoc */\nng.module(\"ui.router.angular1\", []);\nvar mod_init = ng.module('ui.router.init', []);\nvar mod_util = ng.module('ui.router.util', ['ng', 'ui.router.init']);\nvar mod_rtr = ng.module('ui.router.router', ['ui.router.util']);\nvar mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nvar mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nvar mod_cmpt = ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line\nvar router = null;\n$uiRouter.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouter($locationProvider) {\n    // Create a new instance of the Router when the $uiRouterProvider is initialized\n    router = this.router = new _uirouter_core.UIRouter();\n    router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);\n    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n    router.stateRegistry.decorator(\"views\", ng1ViewsBuilder);\n    router.stateRegistry.decorator(\"onExit\", getStateHookBuilder(\"onExit\"));\n    router.stateRegistry.decorator(\"onRetain\", getStateHookBuilder(\"onRetain\"));\n    router.stateRegistry.decorator(\"onEnter\", getStateHookBuilder(\"onEnter\"));\n    router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());\n    var ng1LocationService = router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider);\n    Ng1LocationServices.monkeyPatchPathParameterType(router);\n    // backwards compat: also expose router instance as $uiRouterProvider.router\n    router['router'] = router;\n    router['$get'] = $get;\n    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n        delete router['router'];\n        delete router['$get'];\n        return router;\n    }\n    return router;\n}\nvar getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {\n        var service = $urp.router[serviceName];\n        service[\"$get\"] = function () { return service; };\n        return service;\n    }]; };\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector, $q, $uiRouter) {\n    _uirouter_core.services.$injector = $injector;\n    _uirouter_core.services.$q = $q;\n    // The $injector is now available.\n    // Find any resolvables that had dependency annotation deferred\n    $uiRouter.stateRegistry.get()\n        .map(function (x) { return x.$$state().resolvables; })\n        .reduce(_uirouter_core.unnestR, [])\n        .filter(function (x) { return x.deps === \"deferred\"; })\n        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi); });\n}\n// $urlRouter service and $urlRouterProvider\nvar getUrlRouterProvider = function (uiRouter) {\n    return uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter);\n};\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nvar getStateProvider = function () {\n    return _uirouter_core.extend(router.stateProvider, { $get: function () { return router.stateService; } });\n};\nwatchDigests.$inject = ['$rootScope'];\nfunction watchDigests($rootScope) {\n    $rootScope.$watch(function () { _uirouter_core.trace.approximateDigests++; });\n}\nmod_init.provider(\"$uiRouter\", $uiRouter);\nmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util.provider('$urlService', getProviderFor('urlService'));\nmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\nmod_util.provider('$templateFactory', function () { return new TemplateFactory(); });\nmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\nmod_state.provider('$transitions', getProviderFor('transitionService'));\nmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\nmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\nmod_main.factory('$view', function () { return router.viewService; });\nmod_main.service(\"$trace\", function () { return _uirouter_core.trace; });\nmod_main.run(watchDigests);\nmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\nmod_state.run(['$state', function ($state) { }]);\nmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\nmod_init.run(runBlock);\n/** @hidden TODO: find a place to move this */\nvar getLocals = function (ctx) {\n    var tokens = ctx.getTokens().filter(_uirouter_core.isString);\n    var tuples = tokens.map(function (key) {\n        var resolvable = ctx.getResolvable(key);\n        var waitPolicy = ctx.getPolicy(resolvable).async;\n        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n    });\n    return tuples.reduce(_uirouter_core.applyPairs, {});\n};\n\n/**\n * # Angular 1 injectable services\n *\n * This is a list of the objects which can be injected using angular's injector.\n *\n * There are three different kind of injectable objects:\n *\n * ## **Provider** objects\n * #### injectable into a `.config()` block during configtime\n *\n * - [[$uiRouterProvider]]: The UI-Router instance\n * - [[$stateProvider]]: State registration\n * - [[$transitionsProvider]]: Transition hooks\n * - [[$urlServiceProvider]]: All URL related public APIs\n *\n * - [[$uiViewScrollProvider]]: Disable ui-router view scrolling\n * - [[$urlRouterProvider]]: (deprecated) Url matching rules\n * - [[$urlMatcherFactoryProvider]]: (deprecated) Url parsing config\n *\n * ## **Service** objects\n * #### injectable globally during runtime\n *\n * - [[$uiRouter]]: The UI-Router instance\n * - [[$trace]]: Enable transition trace/debug\n * - [[$transitions]]: Transition hooks\n * - [[$state]]: Imperative state related APIs\n * - [[$stateRegistry]]: State registration\n * - [[$urlService]]: All URL related public APIs\n * - [[$uiRouterGlobals]]: Global variables\n * - [[$uiViewScroll]]: Scroll an element into view\n *\n * - [[$stateParams]]: (deprecated) Global state param values\n * - [[$urlRouter]]: (deprecated) URL synchronization\n * - [[$urlMatcherFactory]]: (deprecated) URL parsing config\n *\n * ## **Per-Transition** objects\n *\n * - These kind of objects are injectable into:\n *   - Resolves ([[Ng1StateDeclaration.resolve]]),\n *   - Transition Hooks ([[TransitionService.onStart]], etc),\n *   - Routed Controllers ([[Ng1ViewDeclaration.controller]])\n *\n * #### Different instances are injected based on the [[Transition]]\n *\n * - [[$transition$]]: The current Transition object\n * - [[$stateParams]]: State param values for pending Transition (deprecated)\n * - Any resolve data defined using [[Ng1StateDeclaration.resolve]]\n *\n * @ng1api\n * @preferred\n * @module injectables\n */ /** */\n/**\n * The current (or pending) State Parameters\n *\n * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.\n *\n * The values are not updated until *after* a `Transition` successfully completes.\n *\n * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.\n *\n * ### Deprecation warning:\n *\n * The value injected for `$stateParams` is different depending on where it is injected.\n *\n * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.\n * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.\n *\n * Because of these confusing details, this service is deprecated.\n *\n * ### Instead of using the global `$stateParams` service object,\n * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]\n *\n * ```js\n * MyService.$inject = ['$uiRouterGlobals'];\n * function MyService($uiRouterGlobals) {\n *   return {\n *     paramValues: function () {\n *       return $uiRouterGlobals.params;\n *     }\n *   }\n * }\n * ```\n *\n * ### Instead of using the per-transition `$stateParams` object,\n * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]\n *\n * ```js\n * MyController.$inject = ['$transition$'];\n * function MyController($transition$) {\n *   var username = $transition$.params().username;\n *   // .. do something with username\n * }\n * ```\n *\n * ---\n *\n * This object can be injected into other services.\n *\n * #### Deprecated Example:\n * ```js\n * SomeService.$inject = ['$http', '$stateParams'];\n * function SomeService($http, $stateParams) {\n *   return {\n *     getUser: function() {\n *       return $http.get('/api/users/' + $stateParams.username);\n *     }\n *   }\n * };\n * angular.service('SomeService', SomeService);\n * ```\n * @deprecated\n */\n\n/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @ng1api\n * @preferred\n * @module directives\n */ /** for typedoc */\n/** @hidden */\nfunction parseStateRef(ref) {\n    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n    if (paramsOnly)\n        ref = '(' + paramsOnly[1] + ')';\n    parsed = ref.replace(/\\n/g, \" \").match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n    if (!parsed || parsed.length !== 4)\n        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n/** @hidden */\nfunction stateContext(el) {\n    var $uiView = el.parent().inheritedData('$uiView');\n    var path = _uirouter_core.parse('$cfg.path')($uiView);\n    return path ? _uirouter_core.tail(path).state.name : undefined;\n}\n/** @hidden */\nfunction processedDef($state, $element, def) {\n    var uiState = def.uiState || $state.current.name;\n    var uiStateOpts = _uirouter_core.extend(defaultOpts($element, $state), def.uiStateOpts || {});\n    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n}\n/** @hidden */\nfunction getTypeInfo(el) {\n    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n    var isForm = el[0].nodeName === \"FORM\";\n    return {\n        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n        clickable: !isForm\n    };\n}\n/** @hidden */\nfunction clickHook(el, $state, $timeout, type, getDef) {\n    return function (e) {\n        var button = e.which || e.button, target = getDef();\n        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition = $timeout(function () {\n                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n            });\n            e.preventDefault();\n            // if the state has no URL, ignore one preventDefault from the <a> directive.\n            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n            e.preventDefault = function () {\n                if (ignorePreventDefaultCount-- <= 0)\n                    $timeout.cancel(transition);\n            };\n        }\n    };\n}\n/** @hidden */\nfunction defaultOpts(el, $state) {\n    return {\n        relative: stateContext(el) || $state.$current,\n        inherit: true,\n        source: \"sref\"\n    };\n}\n/** @hidden */\nfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n    var events;\n    if (uiStateOpts) {\n        events = uiStateOpts.events;\n    }\n    if (!_uirouter_core.isArray(events)) {\n        events = ['click'];\n    }\n    var on = element.on ? 'on' : 'bind';\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n        var event_1 = events_1[_i];\n        element[on](event_1, hookFn);\n    }\n    scope.$on('$destroy', function () {\n        var off = element.off ? 'off' : 'unbind';\n        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n            var event_2 = events_2[_i];\n            element[off](event_2, hookFn);\n        }\n    });\n}\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nvar uiSref;\nuiSref = ['$uiRouter', '$timeout',\n    function $StateRefDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var ref = parseStateRef(attrs.uiSref);\n                rawDef.uiState = ref.state;\n                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                if (ref.paramExpr) {\n                    scope.$watch(ref.paramExpr, function (val$$1) {\n                        rawDef.uiStateParams = _uirouter_core.extend({}, val$$1);\n                        update();\n                    }, true);\n                    rawDef.uiStateParams = _uirouter_core.extend({}, scope.$eval(ref.paramExpr));\n                }\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nvar uiState;\nuiState = ['$uiRouter', '$timeout',\n    function $StateRefDynamicDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = _uirouter_core.noop, acc); }, {});\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                inputAttrs.forEach(function (field) {\n                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n                    attrs.$observe(field, function (expr) {\n                        watchDeregFns[field]();\n                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n                            rawDef[field] = newval;\n                            update();\n                        }, true);\n                    });\n                });\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the <div> and <a> elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nvar uiSrefActive;\nuiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n        return {\n            restrict: \"A\",\n            controller: ['$scope', '$element', '$attrs',\n                function ($scope, $element, $attrs) {\n                    var states = [], activeEqClass, uiSrefActive;\n                    // There probably isn't much point in $observing this\n                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n                    // slight difference in logic routing\n                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n                    try {\n                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n                    }\n                    catch (e) {\n                        // Do nothing. uiSrefActive is not a valid expression.\n                        // Fall back to using $interpolate below\n                    }\n                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n                    if (_uirouter_core.isObject(uiSrefActive)) {\n                        _uirouter_core.forEach(uiSrefActive, function (stateOrName, activeClass) {\n                            if (_uirouter_core.isString(stateOrName)) {\n                                var ref = parseStateRef(stateOrName);\n                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n                            }\n                        });\n                    }\n                    // Allow uiSref to communicate with uiSrefActive[Equals]\n                    this.$$addStateInfo = function (newState, newParams) {\n                        // we already got an explicit state provided by ui-sref-active, so we\n                        // shadow the one that comes from ui-sref\n                        if (_uirouter_core.isObject(uiSrefActive) && states.length > 0) {\n                            return;\n                        }\n                        var deregister = addState(newState, newParams, uiSrefActive);\n                        update();\n                        return deregister;\n                    };\n                    function updateAfterTransition(trans) {\n                        trans.promise.then(update, _uirouter_core.noop);\n                    }\n                    $scope.$on('$stateChangeSuccess', update);\n                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));\n                    if ($uiRouter.globals.transition) {\n                        updateAfterTransition($uiRouter.globals.transition);\n                    }\n                    function addState(stateName, stateParams, activeClass) {\n                        var state = $state.get(stateName, stateContext($element));\n                        var stateInfo = {\n                            state: state || { name: stateName },\n                            params: stateParams,\n                            activeClass: activeClass\n                        };\n                        states.push(stateInfo);\n                        return function removeState() {\n                            _uirouter_core.removeFrom(states)(stateInfo);\n                        };\n                    }\n                    // Update route state\n                    function update() {\n                        var splitClasses = function (str) {\n                            return str.split(/\\s/).filter(_uirouter_core.identity);\n                        };\n                        var getClasses = function (stateList) {\n                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(_uirouter_core.unnestR, []);\n                        };\n                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(_uirouter_core.uniqR, []);\n                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(_uirouter_core.uniqR, []);\n                        var removeClasses = allClasses.filter(function (cls) { return !_uirouter_core.inArray(addClasses, cls); });\n                        $scope.$evalAsync(function () {\n                            addClasses.forEach(function (className) { return $element.addClass(className); });\n                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n                        });\n                    }\n                    update();\n                }]\n        };\n    }];\nng.module('ui.router.state')\n    .directive('uiSref', uiSref)\n    .directive('uiSrefActive', uiSrefActive)\n    .directive('uiSrefActiveEq', uiSrefActive)\n    .directive('uiState', uiState);\n\n/** @module ng1 */ /** for typedoc */\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n    var isFilter = function (state, params, options) {\n        return $state.is(state, params, options);\n    };\n    isFilter.$stateful = true;\n    return isFilter;\n}\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n    var includesFilter = function (state, params, options) {\n        return $state.includes(state, params, options);\n    };\n    includesFilter.$stateful = true;\n    return includesFilter;\n}\nng.module('ui.router.state')\n    .filter('isState', $IsStateFilter)\n    .filter('includedByState', $IncludedByStateFilter);\n\n/**\n * @ng1api\n * @module directives\n */ /** for typedoc */\n/**\n * `ui-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n *   Uses [[$uiViewScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n *\n * <!-- Named (different style) -->\n * <ui-view name=\"viewName\"></ui-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ui-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\nvar uiView;\nuiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n        function getRenderer(attrs, scope) {\n            return {\n                enter: function (element, target, cb) {\n                    if (ng.version.minor > 2) {\n                        $animate.enter(element, null, target).then(cb);\n                    }\n                    else {\n                        $animate.enter(element, null, target, cb);\n                    }\n                },\n                leave: function (element, cb) {\n                    if (ng.version.minor > 2) {\n                        $animate.leave(element).then(cb);\n                    }\n                    else {\n                        $animate.leave(element, cb);\n                    }\n                }\n            };\n        }\n        function configsEqual(config1, config2) {\n            return config1 === config2;\n        }\n        var rootData = {\n            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n            $uiView: {}\n        };\n        var directive = {\n            count: 0,\n            restrict: 'ECA',\n            terminal: true,\n            priority: 400,\n            transclude: 'element',\n            compile: function (tElement, tAttrs, $transclude) {\n                return function (scope, $element, attrs) {\n                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n                    var activeUIView = {\n                        $type: 'ng1',\n                        id: directive.count++,\n                        name: name,\n                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n                        config: null,\n                        configUpdated: configUpdatedCallback,\n                        get creationContext() {\n                            var fromParentTagConfig = _uirouter_core.parse('$cfg.viewDecl.$context')(inherited);\n                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n                            // See https://github.com/angular-ui/ui-router/issues/3355\n                            var fromParentTag = _uirouter_core.parse('$uiView.creationContext')(inherited);\n                            return fromParentTagConfig || fromParentTag;\n                        }\n                    };\n                    _uirouter_core.trace.traceUIViewEvent(\"Linking\", activeUIView);\n                    function configUpdatedCallback(config) {\n                        if (config && !(config instanceof Ng1ViewConfig))\n                            return;\n                        if (configsEqual(viewConfig, config))\n                            return;\n                        _uirouter_core.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n                        viewConfig = config;\n                        updateView(config);\n                    }\n                    $element.data('$uiView', { $uiView: activeUIView });\n                    updateView();\n                    unregister = $view.registerUIView(activeUIView);\n                    scope.$on(\"$destroy\", function () {\n                        _uirouter_core.trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n                        unregister();\n                    });\n                    function cleanupLastView() {\n                        if (previousEl) {\n                            _uirouter_core.trace.traceUIViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n                            previousEl.remove();\n                            previousEl = null;\n                        }\n                        if (currentScope) {\n                            _uirouter_core.trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n                            currentScope.$destroy();\n                            currentScope = null;\n                        }\n                        if (currentEl) {\n                            var _viewData_1 = currentEl.data('$uiViewAnim');\n                            _uirouter_core.trace.traceUIViewEvent(\"Animate out\", _viewData_1);\n                            renderer.leave(currentEl, function () {\n                                _viewData_1.$$animLeave.resolve();\n                                previousEl = null;\n                            });\n                            previousEl = currentEl;\n                            currentEl = null;\n                        }\n                    }\n                    function updateView(config) {\n                        var newScope = scope.$new();\n                        var animEnter = $q.defer(), animLeave = $q.defer();\n                        var $uiViewData = {\n                            $cfg: config,\n                            $uiView: activeUIView,\n                        };\n                        var $uiViewAnim = {\n                            $animEnter: animEnter.promise,\n                            $animLeave: animLeave.promise,\n                            $$animLeave: animLeave\n                        };\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description\n                         *\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         * @param {string} viewName Name of the view.\n                         */\n                        newScope.$emit('$viewContentLoading', name);\n                        var cloned = $transclude(newScope, function (clone) {\n                            clone.data('$uiViewAnim', $uiViewAnim);\n                            clone.data('$uiView', $uiViewData);\n                            renderer.enter(clone, $element, function onUIViewEnter() {\n                                animEnter.resolve();\n                                if (currentScope)\n                                    currentScope.$emit('$viewContentAnimationEnded');\n                                if (_uirouter_core.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                                    $uiViewScroll(clone);\n                                }\n                            });\n                            cleanupLastView();\n                        });\n                        currentEl = cloned;\n                        currentScope = newScope;\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description           *\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         */\n                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n                        currentScope.$eval(onloadExp);\n                    }\n                };\n            }\n        };\n        return directive;\n    }];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n    var getControllerAs = _uirouter_core.parse('viewDecl.controllerAs');\n    var getResolveAs = _uirouter_core.parse('viewDecl.resolveAs');\n    return {\n        restrict: 'ECA',\n        priority: -400,\n        compile: function (tElement) {\n            var initial = tElement.html();\n            tElement.empty();\n            return function (scope, $element) {\n                var data = $element.data('$uiView');\n                if (!data) {\n                    $element.html(initial);\n                    $compile($element.contents())(scope);\n                    return;\n                }\n                var cfg = data.$cfg || { viewDecl: {}, getTemplate: ng_from_import.noop };\n                var resolveCtx = cfg.path && new _uirouter_core.ResolveContext(cfg.path);\n                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n                _uirouter_core.trace.traceUIViewFill(data.$uiView, $element.html());\n                var link = $compile($element.contents());\n                var controller = cfg.controller;\n                var controllerAs = getControllerAs(cfg);\n                var resolveAs = getResolveAs(cfg);\n                var locals = resolveCtx && getLocals(resolveCtx);\n                scope[resolveAs] = locals;\n                if (controller) {\n                    var controllerInstance = $controller(controller, _uirouter_core.extend({}, locals, { $scope: scope, $element: $element }));\n                    if (controllerAs) {\n                        scope[controllerAs] = controllerInstance;\n                        scope[controllerAs][resolveAs] = locals;\n                    }\n                    // TODO: Use $view service as a central point for registering component-level hooks\n                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n                    $element.data('$ngControllerController', controllerInstance);\n                    $element.children().data('$ngControllerController', controllerInstance);\n                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n                }\n                // Wait for the component to appear in the DOM\n                if (_uirouter_core.isString(cfg.viewDecl.component)) {\n                    var cmp_1 = cfg.viewDecl.component;\n                    var kebobName = _uirouter_core.kebobString(cmp_1);\n                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", \"i\");\n                    var getComponentController = function () {\n                        var directiveEl = [].slice.call($element[0].children)\n                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n                        return directiveEl && ng.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n                    };\n                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n                        if (!ctrlInstance)\n                            return;\n                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n                        deregisterWatch_1();\n                    });\n                }\n                link(scope);\n            };\n        }\n    };\n}\n/** @hidden */\nvar hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n    // Call $onInit() ASAP\n    if (_uirouter_core.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n        controllerInstance.$onInit();\n    }\n    var viewState = _uirouter_core.tail(cfg.path).state.self;\n    var hookOptions = { bind: controllerInstance };\n    // Add component-level hook for onParamsChange\n    if (_uirouter_core.isFunction(controllerInstance.uiOnParamsChanged)) {\n        var resolveContext = new _uirouter_core.ResolveContext(cfg.path);\n        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n        // Fire callback on any successful transition\n        var paramsUpdated = function ($transition$) {\n            // Exit early if the $transition$ is the same as the view was created within.\n            // Exit early if the $transition$ will exit the state the view is for.\n            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n                return;\n            var toParams = $transition$.params(\"to\");\n            var fromParams = $transition$.params(\"from\");\n            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(_uirouter_core.unnestR, []);\n            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(_uirouter_core.unnestR, []);\n            // Find the to params that have different values than the from params\n            var changedToParams = toSchema.filter(function (param) {\n                var idx = fromSchema.indexOf(param);\n                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n            });\n            // Only trigger callback if a to param has changed or is new\n            if (changedToParams.length) {\n                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n                var newValues = _uirouter_core.filter(toParams, function (val$$1, key) { return changedKeys_1.indexOf(key) !== -1; });\n                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n            }\n        };\n        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n    }\n    // Add component-level hook for uiCanExit\n    if (_uirouter_core.isFunction(controllerInstance.uiCanExit)) {\n        var id_1 = _uiCanExitId++;\n        var cacheProp_1 = '_uiCanExitIds';\n        // Returns true if a redirect transition already answered truthy\n        var prevTruthyAnswer_1 = function (trans) {\n            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n        };\n        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n        var wrappedHook = function (trans) {\n            var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n            if (!prevTruthyAnswer_1(trans)) {\n                promise = $q.when(controllerInstance.uiCanExit(trans));\n                promise.then(function (val$$1) { return ids[id_1] = (val$$1 !== false); });\n            }\n            return promise;\n        };\n        var criteria = { exiting: viewState.name };\n        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n    }\n}\nng.module('ui.router.state').directive('uiView', uiView);\nng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\n/** @module ng1 */ /** */\n/** @hidden */\nfunction $ViewScrollProvider() {\n    var useAnchorScroll = false;\n    this.useAnchorScroll = function () {\n        useAnchorScroll = true;\n    };\n    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n            if (useAnchorScroll) {\n                return $anchorScroll;\n            }\n            return function ($element) {\n                return $timeout(function () {\n                    $element[0].scrollIntoView();\n                }, 0, false);\n            };\n        }];\n}\nng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * Main entry point for angular 1.x build\n * @module ng1\n */ /** */\nvar index = \"ui.router\";\n\nexports['default'] = index;\nexports.core = _uirouter_core;\nexports.watchDigests = watchDigests;\nexports.getLocals = getLocals;\nexports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;\nexports.ng1ViewsBuilder = ng1ViewsBuilder;\nexports.Ng1ViewConfig = Ng1ViewConfig;\nexports.StateProvider = StateProvider;\nexports.UrlRouterProvider = UrlRouterProvider;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=ui-router-angularjs.js.map\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@uirouter/angularjs/release/ui-router-angularjs.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * UI-Router Core: Framework agnostic, State-based routing for JavaScript Single Page Apps\n * @version v5.0.6\n * @link https://ui-router.github.io\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global['@uirouter/core'] = global['@uirouter/core'] || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nvar prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nvar propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nvar parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nvar not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nvar all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nvar any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nvar is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nvar eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nvar val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\n\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** Returns true if the string has glob-like characters in it */\n    Glob.is = function (text) {\n        return !!/[!,*]+/.exec(text);\n    };\n    /** Returns a glob from the string, or null if the string isn't Glob-like */\n    Glob.fromString = function (text) {\n        return Glob.is(text) ? new Glob(text) : null;\n    };\n    return Glob;\n}());\n\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar StateObject = (function () {\n    /** @deprecated use State.create() */\n    function StateObject(config) {\n        return StateObject.create(config || {});\n    }\n    /**\n     * Create a state object to put the private/internal implementation details onto.\n     * The object's prototype chain looks like:\n     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)\n     *\n     * @param stateDecl the user-supplied State Declaration\n     * @returns {StateObject} an internal State object\n     */\n    StateObject.create = function (stateDecl) {\n        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;\n        var state = inherit(inherit(stateDecl, StateObject.prototype));\n        stateDecl.$$state = function () { return state; };\n        state.self = stateDecl;\n        state.__stateObjectCache = {\n            nameGlob: Glob.fromString(state.name) // might return null\n        };\n        return state;\n    };\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    StateObject.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    StateObject.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    StateObject.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param` objects\n     *\n     * Gets the list of [[Param]] objects owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    StateObject.prototype.parameters = function (opts) {\n        opts = defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    StateObject.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            find(values(this.params), propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    StateObject.prototype.toString = function () {\n        return this.fqn();\n    };\n    /** Predicate which returns true if the object is an class with @State() decorator */\n    StateObject.isStateClass = function (stateDecl) {\n        return isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;\n    };\n    /** Predicate which returns true if the object is an internal [[StateObject]] object */\n    StateObject.isState = function (obj) {\n        return isObject(obj['__stateObjectCache']);\n    };\n    return StateObject;\n}());\n\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */\n/** */\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nvar isUndefined = tis('undefined');\nvar isDefined = not(isUndefined);\nvar isNull = function (o) { return o === null; };\nvar isNullOrUndefined = or(isNull, isUndefined);\nvar isFunction = tis('function');\nvar isNumber = tis('number');\nvar isString = tis('string');\nvar isObject = function (x) { return x !== null && typeof x === 'object'; };\nvar isArray = Array.isArray;\nvar isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nvar isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\nvar isState = StateObject.isState;\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val$$1) {\n    if (isArray(val$$1) && val$$1.length) {\n        var head = val$$1.slice(0, -1), tail = val$$1.slice(-1);\n        return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);\n    }\n    return isFunction(val$$1);\n}\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nvar isPromise = and(isObject, pipe(prop('then'), isFunction));\n\nvar notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\n\n/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */\n/** for typedoc */\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nvar fromJson = angular.fromJson || JSON.parse.bind(JSON);\nvar toJson = angular.toJson || JSON.stringify.bind(JSON);\nvar copy = angular.copy || _copy;\nvar forEach = angular.forEach || _forEach;\nvar extend = Object.assign || _extend;\nvar equals = angular.equals || _equals;\nfunction identity(x) { return x; }\nfunction noop() { }\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nvar inherit = function (parent, extra) {\n    return extend(Object.create(parent), extra);\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nvar inArray = curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nvar removeFrom = curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\n/** pushes a values to an array and returns the value */\nvar pushTo = curry(_pushTo);\nfunction _pushTo(arr, val$$1) {\n    return (arr.push(val$$1), val$$1);\n}\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nvar deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var _defaultsList = defaultsList.concat({}).reverse();\n    var defaultVals = extend.apply(null, _defaultsList);\n    return extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n}\n/** Reduce function that merges each element of the list into a single object, using extend */\nvar mergeR = function (memo, item) { return extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\n/**\n * Return a copy of the object only containing the whitelisted properties.\n *\n * #### Example:\n * ```\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the whitelisted property names\n */\nfunction pick(obj, propNames) {\n    var objCopy = {};\n    for (var prop_1 in obj) {\n        if (propNames.indexOf(prop_1) !== -1) {\n            objCopy[prop_1] = obj[prop_1];\n        }\n    }\n    return objCopy;\n}\n/**\n * Return a copy of the object omitting the blacklisted properties.\n *\n * @example\n * ```\n *\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = omit(foo, ['a', 'b']); // { c: 3 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the blacklisted property names\n */\nfunction omit(obj, propNames) {\n    return Object.keys(obj)\n        .filter(not(inArray(propNames)))\n        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});\n}\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, prop(propName));\n}\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nvar mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = isArray(collection) ? [] : {};\n    forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nvar values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nvar allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nvar anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nvar unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nvar flattenR = function (memo, elem) {\n    return isArray(elem) ? memo.concat(elem.reduce(flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\n/** Reduce function that filters out duplicates */\nvar uniqR = function (acc, token) {\n    return inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nvar unnest = function (arr) { return arr.reduce(unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nvar flatten = function (arr) { return arr.reduce(flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nvar assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nvar assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nvar pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 0)\n        return [];\n    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n    var i, result = [];\n    for (i = 0; i < maxArrayLen; i++) {\n        // This is a hot function\n        // Unroll when there are 1-4 arguments\n        switch (args.length) {\n            case 1:\n                result.push([args[0][i]]);\n                break;\n            case 2:\n                result.push([args[0][i], args[1][i]]);\n                break;\n            case 3:\n                result.push([args[0][i], args[1][i], args[2][i]]);\n                break;\n            case 4:\n                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n                break;\n            default:\n                result.push(args.map(function (array) { return array[i]; }));\n                break;\n        }\n    }\n    return result;\n}\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _extend(toObj) {\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        if (!obj)\n            continue;\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; j++) {\n            toObj[keys[j]] = obj[keys[j]];\n        }\n    }\n    return toObj;\n}\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (all(isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (all(isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (all(isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (all(isFunction)(tup))\n        return true; // meh\n    var predicates = [isFunction, isArray, isDate, isRegExp];\n    if (predicates.map(any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n// issue #2676\nvar silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nvar silentRejection = function (error) {\n    return silenceUncaughtInPromise(services.$q.reject(error));\n};\n\n/**\n * @module common\n */ /** for typedoc */\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\n\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(exports.RejectType || (exports.RejectType = {}));\n/** @hidden */ var id = 0;\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.$id = id++;\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : stringify(d);\n        };\n        var detail = detailString(this.detail);\n        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;\n        return \"Transition Rejection($id: \" + $id + \" type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return extend(silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && is(Rejection)(obj._transitionRejection);\n    };\n    /** Returns a Rejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(exports.RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a Rejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a Rejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(exports.RejectType.INVALID, message, detail);\n    };\n    /** Returns a Rejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(exports.RejectType.IGNORED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        var message = \"The transition has been aborted\";\n        return new Rejection(exports.RejectType.ABORTED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        var message = \"The transition errored\";\n        return new Rejection(exports.RejectType.ERROR, message, detail);\n    };\n    /**\n     * Returns a Rejection\n     *\n     * Normalizes a value as a Rejection.\n     * If the value is already a Rejection, returns it.\n     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n     *\n     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n     */\n    Rejection.normalize = function (detail) {\n        return is(Rejection)(detail) ? detail : Rejection.errored(detail);\n    };\n    return Rejection;\n}());\n\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\n/** @hidden */\nfunction uiViewString(uiview) {\n    if (!uiview)\n        return 'ui-view (defunct)';\n    var state = uiview.creationContext ? uiview.creationContext.name || '(root)' : '(none)';\n    return \"[ui-view#\" + uiview.id + \" \" + uiview.$type + \":\" + uiview.fqn + \" (\" + uiview.name + \"@\" + state + \")]\";\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    var view = viewConfig.viewDecl;\n    var state = view.$context.name || '(root)';\n    return \"[View#\" + viewConfig.$id + \" from '\" + state + \"' state]: target ui-view: '\" + view.$uiViewName + \"@\" + view.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return isNumber(input) ? exports.Category[input] : exports.Category[exports.Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\n\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(exports.Category || (exports.Category = {}));\n/** @hidden */ var _tid = parse(\"$id\");\n/** @hidden */ var _rid = parse(\"router.$id\");\n/** @hidden */ var transLbl = function (trans) { return \"Transition #\" + _tid(trans) + \"-\" + _rid(trans); };\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(exports.Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return exports.Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(exports.Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Started  -> \" + stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(exports.Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Ignored  <> \" + stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(exports.Category.HOOK))\n            return;\n        var event = parse(\"traceData.hookType\")(options) || \"internal\", context = parse(\"traceData.context.state.name\")(options) || parse(\"traceData.context\")(options) || \"unknown\", name = functionToString(step.registeredHook.callback);\n        console.log(transLbl(trans) + \":   Hook -> \" + event + \" context: \" + context + \", \" + maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(exports.Category.HOOK))\n            return;\n        console.log(transLbl(trans) + \":   <- Hook returned: \" + maxLength(200, stringify(hookResult)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(exports.Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":         Resolving \" + path + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(exports.Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":               <- Resolved  \" + resolvable + \" to: \" + maxLength(200, stringify(resolvable.data)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(exports.Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Rejected \" + stringify(trans) + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(exports.Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Success  \" + stringify(trans) + \", final state: \" + finalState.name);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(exports.Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(exports.Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(exports.Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewSync = function (pairs) {\n        if (!this.enabled(exports.Category.VIEWCONFIG))\n            return;\n        var mapping = pairs.map(function (_a) {\n            var uiViewData = _a[0], config = _a[1];\n            var uiView = uiViewData.$type + \":\" + uiViewData.fqn;\n            var view = config && config.viewDecl.$context.name + \": \" + config.viewDecl.$name + \" (\" + config.viewDecl.$type + \")\";\n            return { 'ui-view fqn': uiView, 'state: view name': view };\n        }).sort(function (a, b) { return a['ui-view fqn'].localeCompare(b['ui-view fqn']); });\n        console.table(mapping);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(exports.Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(exports.Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\n\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"RUN\"] = 2] = \"RUN\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\n\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + toJson(this.params());\n    };\n    /** Returns true if the object has a state property that might be a state or state name */\n    TargetState.isDef = function (obj) {\n        return obj && obj.state && (isString(obj.state) || isString(obj.state.name));\n    };\n    return TargetState;\n}());\n\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar defaultOptions = {\n    current: noop,\n    transition: null,\n    traceData: {},\n    bind: null,\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.isSuperseded = function () {\n            return _this.type.hookPhase === exports.TransitionHookPhase.RUN && !_this.options.transition.isActive();\n        };\n        this.options = defaults(options, defaultOptions);\n        this.type = registeredHook.eventType;\n    }\n    TransitionHook.prototype.logError = function (err) {\n        this.transition.router.stateService.defaultErrorHandler()(err);\n    };\n    TransitionHook.prototype.invokeHook = function () {\n        var _this = this;\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        var options = this.options;\n        trace.traceHookInvocation(this, this.transition, options);\n        var invokeCallback = function () {\n            return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n        };\n        var normalizeErr = function (err) {\n            return Rejection.normalize(err).toPromise();\n        };\n        var handleError = function (err) {\n            return hook.eventType.getErrorHandler(_this)(err);\n        };\n        var handleResult = function (result) {\n            return hook.eventType.getResultHandler(_this)(result);\n        };\n        try {\n            var result = invokeCallback();\n            if (!this.type.synchronous && isPromise(result)) {\n                return result.catch(normalizeErr)\n                    .then(handleResult, handleError);\n            }\n            else {\n                return handleResult(result);\n            }\n        }\n        catch (err) {\n            // If callback throws (synchronously)\n            return handleError(Rejection.normalize(err));\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        var _this = this;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        // Hook returned a promise\n        if (isPromise(result)) {\n            // Wait for the promise, then reprocess with the resulting value\n            return result.then(function (val$$1) { return _this.handleHookResult(val$$1); });\n        }\n        trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = is(TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and redirect (a new Transition) to the TargetState.\n            return Rejection.redirected(result).toPromise();\n        }\n    };\n    /**\n     * Return a Rejection promise if the transition is no longer current due\n     * to a stopped router (disposed), or a new transition has started and superseded this one.\n     */\n    TransitionHook.prototype.getNotCurrentRejection = function () {\n        var router = this.transition.router;\n        // The router is stopped\n        if (router._disposed) {\n            return Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n        }\n        if (this.transition._aborted) {\n            return Rejection.aborted().toPromise();\n        }\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.isSuperseded()) {\n            // Abort this transition\n            return Rejection.superseded(this.options.current()).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = parse(\"traceData.hookType\")(options) || \"internal\", context = parse(\"traceData.context.state.name\")(options) || parse(\"traceData.context\")(options) || \"unknown\", name = fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + maxLength(200, name);\n    };\n    /**\n     * Chains together an array of TransitionHooks.\n     *\n     * Given a list of [[TransitionHook]] objects, chains them together.\n     * Each hook is invoked after the previous one completes.\n     *\n     * #### Example:\n     * ```js\n     * var hooks: TransitionHook[] = getHooks();\n     * let promise: Promise<any> = TransitionHook.chain(hooks);\n     *\n     * promise.then(handleSuccess, handleError);\n     * ```\n     *\n     * @param hooks the list of hooks to chain together\n     * @param waitFor if provided, the chain is `.then()`'ed off this promise\n     * @returns a `Promise` for sequentially invoking the hooks (in order)\n     */\n    TransitionHook.chain = function (hooks, waitFor) {\n        // Chain the next hook off the previous\n        var createHookChainR = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n    };\n    /**\n     * Invokes all the provided TransitionHooks, in order.\n     * Each hook's return value is checked.\n     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n     * If no hook returns a promise, then all hooks are processed synchronously.\n     *\n     * @param hooks the list of TransitionHooks to invoke\n     * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n     *\n     * @returns a promise for the async result, or the result of the callback\n     */\n    TransitionHook.invokeHooks = function (hooks, doneCallback) {\n        for (var idx = 0; idx < hooks.length; idx++) {\n            var hookResult = hooks[idx].invokeHook();\n            if (isPromise(hookResult)) {\n                var remainingHooks = hooks.slice(idx + 1);\n                return TransitionHook.chain(remainingHooks, hookResult)\n                    .then(doneCallback);\n            }\n        }\n        return doneCallback();\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    /**\n     * These GetResultHandler(s) are used by [[invokeHook]] below\n     * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n     */\n    TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {\n        return hook.handleHookResult(result);\n    }; };\n    /**\n     * If the result is a promise rejection, log it.\n     * Otherwise, ignore the result.\n     */\n    TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {\n        isPromise(result) && result.catch(function (err) {\n            return hook.logError(Rejection.normalize(err));\n        });\n        return undefined;\n    }; };\n    /**\n     * These GetErrorHandler(s) are used by [[invokeHook]] below\n     * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n     */\n    TransitionHook.LOG_ERROR = function (hook) { return function (error) {\n        return hook.logError(error);\n    }; };\n    TransitionHook.REJECT_ERROR = function (hook) { return function (error) {\n        return silentRejection(error);\n    }; };\n    TransitionHook.THROW_ERROR = function (hook) { return function (error) {\n        throw error;\n    }; };\n    return TransitionHook;\n}());\n\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === exports.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = values(matches).every(identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\n\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        var $transitions = this.transition.router.transitionService;\n        return $transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(unnestR, [])\n            .filter(identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var transition = this.transition;\n        var treeChanges = transition.treeChanges();\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n        if (!matchingHooks)\n            return [];\n        var baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === exports.TransitionHookScope.STATE ? node.state.self : null;\n                var transitionHook = new TransitionHook(transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === exports.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var $transitions = this.transition.router.transitionService;\n        var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(assertPredicate(isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n\n/**\n * @coreapi\n * @module params\n */\n/** */\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return isArray(val) ? val : (isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = map(arr, callback);\n            return (allTruthyMode === true) ? filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\n/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */ var isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n/** @internalapi */\n\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(exports.DefType || (exports.DefType = {}));\n/** @hidden */\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    getStaticDefaultValue['__cacheable'] = true;\n    function getStaticDefaultValue() {\n        return cfg.value;\n    }\n    return extend(cfg, {\n        $$fn: isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n    });\n}\n/** @hidden */\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === exports.DefType.CONFIG ? \"any\" :\n            location === exports.DefType.PATH ? \"path\" :\n                location === exports.DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\n/** @internalapi */\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") },\n    ];\n    replace = isArray(config.replace) ? config.replace : [];\n    if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = map(replace, prop(\"from\"));\n    return filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\n/** @internalapi */\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === exports.DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === exports.DefType.SEARCH;\n        var dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit$$1 = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === exports.DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit$$1, array: arrayMode, config: config });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var getDefaultValue = function () {\n            if (_this._defaultValueCache)\n                return _this._defaultValueCache.defaultValue;\n            if (!services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            if (_this.config.$$fn['__cacheable']) {\n                _this._defaultValueCache = { defaultValue: defaultValue };\n            }\n            return defaultValue;\n        };\n        var replaceSpecialValues = function (val$$1) {\n            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n                var tuple = _a[_i];\n                if (tuple.from === val$$1)\n                    return tuple.to;\n            }\n            return val$$1;\n        };\n        value = replaceSpecialValues(value);\n        return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === exports.DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((isUndefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values$$1) {\n        if (values$$1 === void 0) { values$$1 = {}; }\n        var paramValues = {};\n        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n            var param = params_1[_i];\n            paramValues[param.id] = param.value(values$$1[param.id]);\n        }\n        return paramValues;\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values$$1) {\n        if (values$$1 === void 0) { values$$1 = {}; }\n        return params.map(function (param) { return param.validates(values$$1[param.id]); }).reduce(allTrueR, true);\n    };\n    return Param;\n}());\n\n/** @module path */ /** for typedoc */\n/**\n * @internalapi\n *\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrNode) {\n        if (stateOrNode instanceof PathNode) {\n            var node = stateOrNode;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrNode;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return find(this.paramSchema, propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, paramsFn) {\n        var diff = this.diff(node, paramsFn);\n        return diff && diff.length === 0;\n    };\n    /**\n     * Finds Params with different parameter values on another PathNode.\n     *\n     * Given another node (of the same state), finds the parameter values which differ.\n     * Returns the [[Param]] (schema objects) whose parameter values differ.\n     *\n     * Given another node for a different state, returns `false`\n     *\n     * @param node The node to compare to\n     * @param paramsFn A function that returns which parameters should be compared.\n     * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n     */\n    PathNode.prototype.diff = function (node, paramsFn) {\n        if (this.state !== node.state)\n            return false;\n        var params = paramsFn ? paramsFn(this) : this.paramSchema;\n        return Param.changed(params, this.paramValues, node.paramValues);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    return PathNode;\n}());\n\n/** @module path */ /** for typedoc */\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathUtils = (function () {\n    function PathUtils() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathUtils.makeTargetState = function (path) {\n        var state = tail(path).state;\n        return new TargetState(state, state, path.map(prop(\"paramValues\")).reduce(mergeR, {}));\n    };\n    PathUtils.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathUtils.buildToPath = function (fromPath, targetState) {\n        var toPath = PathUtils.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathUtils.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = values(node.state.views || {});\n            var subPath = PathUtils.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = find(path, propEq('state', state));\n            return extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = pick(toParamVals, toKeys);\n            toParamVals = omit(toParamVals, toKeys);\n            var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);\n            return new PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, PathUtils.nonDynamicParams);\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Returns a new path which is: the subpath of the first path which matches the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * It stops before the first non-matching node.\n     *\n     * Nodes are compared using their state property and their parameter values.\n     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     *\n     * @returns an array of PathNodes from the first path which match the nodes in the second path\n     */\n    PathUtils.matching = function (pathA, pathB, paramsFn) {\n        var done = false;\n        var tuples = arrayTuples(pathA, pathB);\n        return tuples.reduce(function (matching, _a) {\n            var nodeA = _a[0], nodeB = _a[1];\n            done = done || !nodeA.equals(nodeB, paramsFn);\n            return done ? matching : matching.concat(nodeA);\n        }, []);\n    };\n    /**\n     * Returns true if two paths are identical.\n     *\n     * @param pathA\n     * @param pathB\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     * @returns true if the the states and parameter values for both paths are identical\n     */\n    PathUtils.equals = function (pathA, pathB, paramsFn) {\n        return pathA.length === pathB.length &&\n            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathUtils.subPath = function (path, predicate) {\n        var node = find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    PathUtils.nonDynamicParams = function (node) {\n        return node.state.parameters({ inherit: false })\n            .filter(function (param) { return !param.dynamic; });\n    };\n    /** Gets the raw parameter values from a path */\n    PathUtils.paramValues = function (path) {\n        return path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {});\n    };\n    return PathUtils;\n}());\n\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\n// TODO: explicitly make this user configurable\nvar defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            extend(this, arg1);\n        }\n        else if (isFunction(resolveFn)) {\n            if (isNullOrUndefined(arg1))\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n        }\n        else if (isObject(arg1) && arg1.token && isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n                return resolvable.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + stringify(this.token) + \", requires: [\" + this.deps.map(stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    Resolvable.fromData = function (token, data) {\n        return new Resolvable(token, function () { return data; }, null, null, data);\n    };\n    return Resolvable;\n}());\n\n/** @internalapi */\nvar resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n\n/** @module resolve */\n/** for typedoc */\nvar when = resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nvar NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(PathUtils.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = find(this._path, propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return find(this._path, function (node) { return inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + stringify(token));\n            }\n            return new Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\n/** @hidden */\nvar stateSelf = prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /** @hidden */\n        this._hookBuilder = new HookBuilder(this);\n        /** Checks if this transition is currently active/running. */\n        this.isActive = function () {\n            return _this.router.globals.transition === _this;\n        };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = extend({ current: val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = PathUtils.buildToPath(fromPath, targetState);\n        this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this._hookBuilder.buildHooksForPhase(exports.TransitionHookPhase.CREATE);\n        TransitionHook.invokeHooks(onCreateHooks, function () { return null; });\n        this.applyViewConfigs(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== exports.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     * @deprecated\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !matchState(this.$to(), compare.to)) ||\n            (compare.from && !matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(prop(\"paramValues\")).reduce(mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return map(this._treeChanges.exiting, prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(propEq('state', state));\n        return path.map(prop(\"views\")).filter(identity).reduce(unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless the target state explicitly specifies location: false).\n        // This causes the original url to be replaced with the url for the redirect target\n        // so the original url disappears from the browser history.\n        if (this.options().source === 'url' && targetState.options().location !== false) {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams)\n            .filter(not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return Param.changed(schema, toVals, fromVals);\n        }).reduce(unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        return !!this._ignoredReason();\n    };\n    /** @hidden */\n    Transition.prototype._ignoredReason = function () {\n        var pending = this.router.globals.transition;\n        var reloadState = this._options.reloadState;\n        var same = function (pathA, pathB) {\n            if (pathA.length !== pathB.length)\n                return false;\n            var matching = PathUtils.matching(pathA, pathB);\n            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;\n        };\n        var newTC = this.treeChanges();\n        var pendTC = pending && pending.treeChanges();\n        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))\n            return \"SameAsPending\";\n        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))\n            return \"SameAsCurrent\";\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = TransitionHook.runAllHooks;\n        // Gets transition hooks array for the given phase\n        var getHooksFor = function (phase) {\n            return _this._hookBuilder.buildHooksForPhase(phase);\n        };\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            runAllHooks(getHooksFor(exports.TransitionHookPhase.SUCCESS));\n        };\n        var transitionError = function (reason) {\n            trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            runAllHooks(getHooksFor(exports.TransitionHookPhase.ERROR));\n        };\n        var runTransition = function () {\n            // Wait to build the RUN hook chain until the BEFORE hooks are done\n            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n            var allRunHooks = getHooksFor(exports.TransitionHookPhase.RUN);\n            var done = function () { return services.$q.when(undefined); };\n            return TransitionHook.invokeHooks(allRunHooks, done);\n        };\n        var startTransition = function () {\n            var globals = _this.router.globals;\n            globals.lastStartedTransitionId = _this.$id;\n            globals.transition = _this;\n            globals.transitionHistory.enqueue(_this);\n            trace.traceTransitionStart(_this);\n            return services.$q.when(undefined);\n        };\n        var allBeforeHooks = getHooksFor(exports.TransitionHookPhase.BEFORE);\n        TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n            .then(runTransition)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * Aborts this transition\n     *\n     * Imperative API to abort a Transition.\n     * This only applies to Transitions that are not yet complete.\n     */\n    Transition.prototype.abort = function () {\n        // Do not set flag if the transition is already complete\n        if (isUndefined(this.success)) {\n            this._aborted = true;\n        }\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        var paramDefs = state.parameters(), values$$1 = this.params();\n        var invalidParams = paramDefs.filter(function (param) { return !param.validates(values$$1[param.id]); });\n        if (invalidParams.length) {\n            return \"Param values not valid for state '\" + state.name + \"'. Invalid params: [ \" + invalidParams.map(function (param) { return param.id; }).join(', ') + \" ]\";\n        }\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : omit(params, [\"#\"]);\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = toJson(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    /** @hidden */\n    Transition.diToken = Transition;\n    return Transition;\n}());\n\n/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nfunction fnToString(fn) {\n    var _fn = isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isRejection = Rejection.isRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || pattern([\n        [not(isDefined), val(\"undefined\")],\n        [isNull, val(\"null\")],\n        [isPromise, val(\"[Promise]\")],\n        [isRejection, function (x) { return x._transitionRejection.toString(); }],\n        [is(Rejection), invoke(\"toString\")],\n        [is(Transition), invoke(\"toString\")],\n        [is(Resolvable), invoke(\"toString\")],\n        [isInjectable, functionToString],\n        [val(true), identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val$$1) {\n        if (isObject(val$$1)) {\n            if (seen.indexOf(val$$1) !== -1)\n                return '[circular ref]';\n            seen.push(val$$1);\n        }\n        return stringifyPattern(val$$1);\n    }\n    return JSON.stringify(o, function (key, val$$1) { return format(val$$1); }).replace(/\\\\\"/g, '\"');\n}\n/** Returns a function that splits a string on a character or substring */\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(identity);\n    };\n}\n\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (isString(tail(acc)) && isString(x))\n        return acc.slice(0, -1).concat(tail(acc) + x);\n    return pushR(acc, x);\n}\n\n/** @module common */ /** for typedoc */\n\n/**\n * @coreapi\n * @module params\n */\n/** */\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = pick(ParamTypes.prototype, [\"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\"]);\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new ParamType(extend({ name: name }, definition));\n        };\n        this.types = inherit(map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new ParamType(extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            extend(this.types[type.name], services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val$$1) {\n            return val$$1 != null ? val$$1.toString() : val$$1;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val$$1) { return parseInt(val$$1, 10); },\n            is: function (val$$1) {\n                return !isNullOrUndefined(val$$1) && this.decode(val$$1.toString()) === val$$1;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val$$1) { return val$$1 && 1 || 0; },\n            decode: function (val$$1) { return parseInt(val$$1, 10) !== 0; },\n            is: is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val$$1) {\n                return !this.is(val$$1) ? undefined : [\n                    val$$1.getFullYear(),\n                    ('0' + (val$$1.getMonth() + 1)).slice(-2),\n                    ('0' + val$$1.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val$$1) {\n                if (this.is(val$$1))\n                    return val$$1;\n                var match = this.capture.exec(val$$1);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val$$1) { return val$$1 instanceof Date && !isNaN(val$$1.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: toJson,\n            decode: fromJson,\n            is: is(Object),\n            equals: equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: identity,\n            decode: identity,\n            is: function () { return true; },\n            equals: equals,\n        }),\n    });\n}\ninitDefaultTypes();\n\n/**\n * @coreapi\n * @module params\n */\n/** */\n/** @internalapi */\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return extend({}, inherited, newParams);\n    };\n    \n    return StateParams;\n}());\n\n/** @module path */ /** for typedoc */\n\n/** @module resolve */ /** for typedoc */\n\n/** @module state */ /** for typedoc */\nvar parseUrl = function (url) {\n    if (!isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = pattern([\n        [prop('resolveFn'), function (p) { return new Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [prop('useFactory'), function (p) { return new Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [prop('useClass'), function (p) { return new Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [prop('useValue'), function (p) { return new Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [prop('useExisting'), function (p) { return new Resolvable(token(p), identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = pattern([\n        [pipe(prop(\"val\"), isString), function (tuple) { return new Resolvable(tuple.token, identity, [tuple.val], tuple.policy); }],\n        [pipe(prop(\"val\"), isArray), function (tuple) { return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [pipe(prop(\"val\"), isFunction), function (tuple) { return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = pattern([\n        [is(Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (isString(name) && !isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!isString(name) || !isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent, undefined, false)) {\n            return null;\n        }\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        // name = 'foo.bar.baz.**'\n        var name = state.name || \"\";\n        // segments = ['foo', 'bar', 'baz', '.**']\n        var segments = name.split('.');\n        // segments = ['foo', 'bar', 'baz']\n        var lastSegment = segments.pop();\n        // segments = ['foo', 'bar'] (ignore .** segment for future states)\n        if (lastSegment === '**')\n            segments.pop();\n        if (segments.length) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            // 'foo.bar'\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\n\n/** @module state */ /** for typedoc */\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n        if (matchGlob === void 0) { matchGlob = true; }\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr && matchGlob) {\n            var _states = values(this._states);\n            var matches = _states.filter(function (state) {\n                return state.__stateObjectCache.nameGlob &&\n                    state.__stateObjectCache.nameGlob.matches(name);\n            });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\n\n/** @module state */ /** for typedoc */\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n        this.matcher = $registry.matcher;\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (stateDecl) {\n        var queue = this.queue;\n        var state = StateObject.create(stateDecl);\n        var name = state.name;\n        if (!isString(name))\n            throw new Error(\"State must have a valid name\");\n        if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))\n            throw new Error(\"State '\" + name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _this = this;\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        var getState = function (name) {\n            return _this.states.hasOwnProperty(name) && _this.states[name];\n        };\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var name_1 = state.name;\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = getState(name_1);\n                if (existingState && existingState.name === name_1) {\n                    throw new Error(\"State '\" + name_1 + \"' is already defined\");\n                }\n                var existingFutureState = getState(name_1 + \".**\");\n                if (existingFutureState) {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingFutureState);\n                }\n                states[name_1] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[name_1];\n            previousQueueLength[name_1] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\n\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new StateMatcher(this.states);\n        this.builder = new StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[StateObject]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[StateObject]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all$$1 = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all$$1.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {StateObject[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\n\n/**\n * @coreapi\n * @module url\n */\n/** for typedoc */\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop$$1, fn) {\n    return obj[prop$$1] = obj[prop$$1] || fn();\n};\n/** @hidden */\nvar splitOnSlash = splitOnDelim('/');\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern$$1, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this] };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern$$1;\n        this.config = defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern$$1 + \"'\");\n            if (find(_this._params, propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern$$1 + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\\\s\\\\S]*' : null);\n            var makeRegexpType = function (regexp) { return inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern$$1.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern$$1))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern$$1.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                    // check if ?&\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern$$1) { return quoteRegExp.apply(null, pattern$$1); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                unnest(_this._cache.path.map(prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values$$1 = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = map(split, reverseString);\n            return map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (isDefined(value))\n                value = param.type.decode(value);\n            values$$1[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (isDefined(value))\n                value = param.type.decode(value);\n            values$$1[param.id] = param.value(value);\n        });\n        if (hash)\n            values$$1[\"#\"] = hash;\n        return values$$1;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return unnest(this._cache.path.map(function (matcher) { return matcher._params; }));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        var findParam = function () {\n            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n                var param = _a[_i];\n                if (param.id === id)\n                    return param;\n            }\n        };\n        var parent = this._cache.parent;\n        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var validParamVal = function (param, val$$1) {\n            return !param || param.validates(val$$1);\n        };\n        params = params || {};\n        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });\n        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values$$1) {\n        if (values$$1 === void 0) { values$$1 = {}; }\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params (processed as ParamDetails)\n        // into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n            .reduce(unnestR, [])\n            .map(function (x) { return isString(x) ? x : getDetails(x); });\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams)\n            .reduce(unnestR, [])\n            .map(getDetails);\n        var isInvalid = function (param) { return param.isValid === false; };\n        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n            return null;\n        }\n        /**\n         * Given a Param, applies the parameter value, then returns detailed information about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values$$1[param.id]);\n            var isValid = param.validates(value);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (isString(x))\n                return acc + x;\n            // Otherwise, it's a ParamDetails.\n            var squash = x.squash, encoded = x.encoded, param = x.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (isArray(encoded))\n                return acc + map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (paramDetails) {\n            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = map(encoded, encodeURIComponent);\n            return encoded.map(function (val$$1) { return param.id + \"=\" + val$$1; });\n        }).filter(identity).reduce(unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values$$1[\"#\"] ? \"#\" + values$$1[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === exports.DefType.PATH; });\n        return arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(unnestR, [])\n            .filter(function (x) { return x !== \"\" && isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === exports.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         * Caches the result as `matcher._cache.segments`\n         */\n        var segments = function (matcher) {\n            return matcher._cache.segments = matcher._cache.segments ||\n                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                    .reduce(unnestR, [])\n                    .reduce(joinNeighborsR, [])\n                    .map(function (x) { return isString(x) ? splitOnSlash(x) : x; })\n                    .reduce(unnestR, []);\n        };\n        /**\n         * Gets the sort weight for each segment of a UrlMatcher\n         *\n         * Caches the result as `matcher._cache.weights`\n         */\n        var weights = function (matcher) {\n            return matcher._cache.weights = matcher._cache.weights ||\n                segments(matcher).map(function (segment) {\n                    // Sort slashes first, then static strings, the Params\n                    if (segment === '/')\n                        return 1;\n                    if (isString(segment))\n                        return 2;\n                    if (segment instanceof Param)\n                        return 3;\n                });\n        };\n        /**\n         * Pads shorter array in-place (mutates)\n         */\n        var padArrays = function (l, r, padVal) {\n            var len = Math.max(l.length, r.length);\n            while (l.length < len)\n                l.push(padVal);\n            while (r.length < len)\n                r.push(padVal);\n        };\n        var weightsA = weights(a), weightsB = weights(b);\n        padArrays(weightsA, weightsB, 0);\n        var cmp, i, pairs$$1 = arrayTuples(weightsA, weightsB);\n        for (i = 0; i < pairs$$1.length; i++) {\n            cmp = pairs$$1[i][0] - pairs$$1[i][1];\n            if (cmp !== 0)\n                return cmp;\n        }\n        return 0;\n    };\n    /** @hidden */\n    UrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n    return UrlMatcher;\n}());\n\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new Param(id, type, config, exports.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new Param(id, type, config, exports.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new Param(id, type, config, exports.DefType.SEARCH, _this);\n            },\n        };\n        extend(this, { UrlMatcher: UrlMatcher, Param: Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (isDefined(value) && value !== true && value !== false && !isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!isObject(object))\n            return false;\n        var result = true;\n        forEach(UrlMatcher.prototype, function (val, name) {\n            if (isFunction(val))\n                result = result && (isDefined(object[name]) && isFunction(object[name]));\n        });\n        return result;\n    };\n    \n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !isDefined(definition) ? type : this;\n    };\n    \n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    \n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\n\n/**\n * @coreapi\n * @module url\n */ /** */\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = pattern([\n            [isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [is(UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [isState, function (_what) { return _this.fromState(_what, _this.router); }],\n            [is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (is(UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return extend(new BaseUrlRule(match, _handler), details);\n    };\n    UrlRuleFactory.isUrlRule = function (obj) {\n        return obj && ['type', 'match', 'handler'].every(function (key) { return isDefined(obj[key]); });\n    };\n    return UrlRuleFactory;\n}());\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || identity;\n    }\n    return BaseUrlRule;\n}());\n\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar prioritySort = function (a, b) {\n    return (b.priority || 0) - (a.priority || 0);\n};\n/** @hidden */\nvar typeSort = function (a, b) {\n    var weights = { \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 };\n    return (weights[a.type] || 0) - (weights[b.type] || 0);\n};\n/** @hidden */\nvar urlMatcherSort = function (a, b) {\n    return !a.urlMatcher || !b.urlMatcher ? 0 : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);\n};\n/** @hidden */\nvar idSort = function (a, b) {\n    // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL\n    var useMatchPriority = { STATE: true, URLMATCHER: true };\n    var equal = useMatchPriority[a.type] && useMatchPriority[b.type];\n    return equal ? 0 : (a.$id || 0) - (b.$id || 0);\n};\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Rule registration order (for rule types other than STATE and URLMATCHER)\n *   - Equally sorted State and UrlMatcher rules will each match the URL.\n *     Then, the *best* match is chosen based on how many parameter values were matched.\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = function (a, b) {\n    var cmp = prioritySort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    cmp = typeSort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    cmp = urlMatcherSort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    return idSort(a, b);\n};\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        /** @hidden */ this._sorted = false;\n        this._router = router;\n        this.urlRuleFactory = new UrlRuleFactory(router);\n        createProxyFunctions(val(UrlRouter.prototype), this, val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules = this.stableSort(this._rules, this._sortFn = compareFn || this._sortFn);\n        this._sorted = true;\n    };\n    UrlRouter.prototype.ensureSorted = function () {\n        this._sorted || this.sort();\n    };\n    UrlRouter.prototype.stableSort = function (arr, compareFn) {\n        var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });\n        arrOfWrapper.sort(function (wrapperA, wrapperB) {\n            var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);\n            return cmpDiff === 0\n                ? wrapperA.idx - wrapperB.idx\n                : cmpDiff;\n        });\n        return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        this.ensureSorted();\n        url = extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash(),\n        };\n        var best = this.match(url);\n        var applyResult = pattern([\n            [isString, function (newurl) { return $url.url(newurl, true); }],\n            [TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [is(TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        var url = urlMatcher.format(params);\n        if (url == null)\n            return null;\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this._sorted = false;\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        removeFrom(this._rules, rule);\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () {\n        this.ensureSorted();\n        return this._rules.slice();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);\n        this._sorted = false;\n    };\n    \n    /** @inheritdoc */\n    UrlRouter.prototype.initial = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        var matchFn = function (urlParts, router) {\n            return router.globals.transitionHistory.size() === 0 && !!/^\\/?$/.exec(urlParts.path);\n        };\n        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));\n    };\n    \n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    \n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    \n    return UrlRouter;\n}());\nfunction getHandlerFn(handler) {\n    if (!isFunction(handler) && !isString(handler) && !is(TargetState)(handler) && !TargetState.isDef(handler)) {\n        throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n    }\n    return isFunction(handler) ? handler : val(handler);\n}\n\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    \n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(applyPairs, {});\n        // Return a weighted depth value for a uiView.\n        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)\n        // plus the depth of the state that is populating the uiView\n        function uiViewDepth(uiView) {\n            var stateDepth = function (context) {\n                return context && context.parent ? stateDepth(context.parent) + 1 : 1;\n            };\n            return (uiView.fqn.split(\".\").length * 10000) + stateDepth(uiView.creationContext);\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        // Sort views by FQN and state depth. Process uiviews nearest the root first.\n        var pairs$$1 = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);\n        trace.traceViewSync(pairs$$1);\n        pairs$$1.forEach(configureUIView);\n    };\n    \n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };\n        if (uiViews.filter(fqnAndTypeMatches).length)\n            trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            removeFrom(uiViews)(uiView);\n        };\n    };\n    \n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(prop(\"$config\")).map(prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    /**\n     * Given a ui-view and a ViewConfig, determines if they \"match\".\n     *\n     * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n     * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n     *\n     * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n     * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n     *\n     * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n     *\n     * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n     * - the ui-view's name matches the ViewConfig's target name\n     * - the ui-view's context matches the ViewConfig's anchor\n     *\n     * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n     * - There exists a parent ui-view where:\n     *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n     *    - the parent ui-view's context matches the ViewConfig's anchor\n     * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n     *\n     * Example:\n     *\n     * DOM:\n     * <ui-view>                        <!-- created in the root context (name: \"\") -->\n     *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n     *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n     *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n     *       </ui-view>\n     *     </ui-view>\n     *   </ui-view>\n     * </ui-view>\n     *\n     * uiViews: [\n     *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n     *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n     *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n     *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n     * ]\n     *\n     * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n     *\n     * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n     * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n     * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n     * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n     *\n     * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n     * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n     * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n     *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n     *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n     * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n     *   the tail of the ui-view's fqn \"default.bar\"\n     *\n     * @internalapi\n     */\n    ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n        // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n        if (uiView.$type !== viewConfig.viewDecl.$type)\n            return false;\n        // Split names apart from both viewConfig and uiView into segments\n        var vc = viewConfig.viewDecl;\n        var vcSegments = vc.$uiViewName.split(\".\");\n        var uivSegments = uiView.fqn.split(\".\");\n        // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n        // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n        if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n            return false;\n        // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n        // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n        var negOffset = (1 - vcSegments.length) || undefined;\n        var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n        var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n        return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n    }; };\n    return ViewService;\n}());\n\n/**\n * @coreapi\n * @module core\n */ /** */\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar UIRouterGlobals = (function () {\n    function UIRouterGlobals() {\n        /**\n         * Current parameter values\n         *\n         * The parameter values from the latest successful transition\n         */\n        this.params = new StateParams();\n        /** @internalapi */\n        this.lastStartedTransitionId = -1;\n        /** @internalapi */\n        this.transitionHistory = new Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new Queue([], 1);\n    }\n    UIRouterGlobals.prototype.dispose = function () {\n        this.transitionHistory.clear();\n        this.successfulTransitions.clear();\n        this.transition = null;\n    };\n    return UIRouterGlobals;\n}());\n\n/**\n * @coreapi\n * @module url\n */ /** */\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = notImplemented(key), acc); }, { dispose: noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"initial\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    \n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    \n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    \n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    \n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    \n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    \n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    /** @hidden */\n    UrlService.locationServiceStub = makeStub(locationServicesFns);\n    /** @hidden */\n    UrlService.locationConfigStub = makeStub(locationConfigFns);\n    return UrlService;\n}());\n\n/**\n * @coreapi\n * @module core\n */ /** */\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */ this.$id = _routerInstance++;\n        /** @hidden */ this._disposed = false;\n        /** @hidden */ this._disposables = [];\n        /** Provides trace information to the console */\n        this.trace = trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new TransitionService(this);\n        /** Global router state */\n        this.globals = new UIRouterGlobals();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlMatcherFactory = new UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlRouter = new UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new UrlService(this);\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.globals);\n        this.disposable(this.stateService);\n        this.disposable(this.stateRegistry);\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposed = true;\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : values(this._plugins);\n    };\n    return UIRouter;\n}());\n\n/** @module hooks */ /** */\nfunction addCoreResolvables(trans) {\n    trans.addResolvable({ token: UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, \"\");\n    trans.addResolvable({ token: Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, \"\");\n    trans.entering().forEach(function (state) {\n        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);\n    });\n}\nvar registerAddCoreResolvables = function (transitionService) {\n    return transitionService.onCreate({}, addCoreResolvables);\n};\n\n/** @module hooks */ /** */\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof TargetState)\n            return result;\n        if (isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (isFunction(redirect)) {\n        return services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nvar registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var _state = state.$$state();\n        var hookFn = _state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nvar registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nvar registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nvar registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n\n/** @module hooks */\n/** for typedoc */\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(noop);\n};\nvar registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new ResolveContext(trans.treeChanges().to)\n        .subContext(state.$$state())\n        .resolvePath(\"LAZY\", trans)\n        .then(noop);\n};\nvar registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: val(true) }, lazyResolveState, { priority: 1000 });\n};\n\n/** @module hooks */ /** for typedoc */\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(noop);\n};\nvar registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nvar registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n\n/**\n * A [[TransitionHookFn]] which updates global UI-Router state\n *\n * Registered using `transitionService.onBefore({}, updateGlobalState);`\n *\n * Before a [[Transition]] starts, updates the global value of \"the current transition\" ([[Globals.transition]]).\n * After a successful [[Transition]], updates the global values of \"the current state\"\n * ([[Globals.current]] and [[Globals.$current]]) and \"the current param values\" ([[Globals.params]]).\n *\n * See also the deprecated properties:\n * [[StateService.transition]], [[StateService.current]], [[StateService.params]]\n */\nvar updateGlobalState = function (trans) {\n    var globals = trans.router.globals;\n    var transitionSuccessful = function () {\n        globals.successfulTransitions.enqueue(trans);\n        globals.$current = trans.$to();\n        globals.current = globals.$current.self;\n        copy(trans.params(), globals.params);\n    };\n    var clearCurrentTransition = function () {\n        // Do not clear globals.transition if a different transition has started in the meantime\n        if (globals.transition === trans)\n            globals.transition = null;\n    };\n    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n};\nvar registerUpdateGlobalState = function (transitionService) {\n    return transitionService.onCreate({}, updateGlobalState);\n};\n\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nvar registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return services.$q.all(promises).then(retryTransition);\n};\nvar registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\n\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.synchronous = synchronous;\n    }\n    return TransitionEventType;\n}());\n\n/** @module hooks */ /** */\n/**\n * A [[TransitionHookFn]] that skips a transition if it should be ignored\n *\n * This hook is invoked at the end of the onBefore phase.\n *\n * If the transition should be ignored (because no parameter or states changed)\n * then the transition is ignored and not processed.\n */\nfunction ignoredHook(trans) {\n    var ignoredReason = trans._ignoredReason();\n    if (!ignoredReason)\n        return;\n    trace.traceTransitionIgnored(trans);\n    var pending = trans.router.globals.transition;\n    // The user clicked a link going back to the *current state* ('A')\n    // However, there is also a pending transition in flight (to 'B')\n    // Abort the transition to 'B' because the user now wants to be back at 'A'.\n    if (ignoredReason === 'SameAsCurrent' && pending) {\n        pending.abort();\n    }\n    return Rejection.ignored().toPromise();\n}\nvar registerIgnoredTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n};\n\n/** @module hooks */ /** */\n/**\n * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n *\n * This hook is invoked at the end of the onBefore phase.\n * If the transition is invalid (for example, param values do not validate)\n * then the transition is rejected.\n */\nfunction invalidTransitionHook(trans) {\n    if (!trans.valid()) {\n        throw new Error(trans.error());\n    }\n}\nvar registerInvalidTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n};\n\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nvar defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = createProxyFunctions(val(this), {}, val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineCorePaths();\n        this._defineCoreEvents();\n        this._registerCoreTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCoreEvents = function () {\n        var Phase = exports.TransitionHookPhase;\n        var TH = TransitionHook;\n        var paths = this._criteriaPaths;\n        var NORMAL_SORT = false, REVERSE_SORT = true;\n        var ASYNCHRONOUS = false, SYNCHRONOUS = true;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to);\n        this._defineEvent(\"onStart\", Phase.RUN, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.RUN, 100, paths.exiting, REVERSE_SORT);\n        this._defineEvent(\"onRetain\", Phase.RUN, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.RUN, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.RUN, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCorePaths = function () {\n        var STATE = exports.TransitionHookScope.STATE, TRANSITION = exports.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        var eventType = new TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);\n        this._eventTypes.push(eventType);\n        makeEvent(this, this, eventType);\n    };\n    \n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerCoreTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        fns.addCoreResolves = registerAddCoreResolvables(this);\n        fns.ignored = registerIgnoredTransitionHook(this);\n        fns.invalid = registerInvalidTransitionHook(this);\n        // Wire up redirectTo hook\n        fns.redirectTo = registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = registerOnExitHook(this);\n        fns.onRetain = registerOnRetainHook(this);\n        fns.onEnter = registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = registerEagerResolvePath(this);\n        fns.lazyResolve = registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = registerLoadEnteringViews(this);\n        fns.activateViews = registerActivateViews(this);\n        // Updates global state after a transition\n        fns.updateGlobals = registerUpdateGlobalState(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\n\n/**\n * @coreapi\n * @module state\n */\n/** */\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));\n        createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[StateObject]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = PathUtils.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new Queue(this.invalidCallbacks.slice());\n        var injector = new ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid()) {\n                return Rejection.invalid(target.error()).toPromise();\n            }\n            if (latestThing() !== latest) {\n                return Rejection.superseded().toPromise();\n            }\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false,\n        });\n    };\n    \n    /**\n     * Transition to a different state and/or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n     * inherit from the current parameter values (because of `inherit: true`).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to Absolute state name, state object, or relative state path (relative to current state).\n     *\n     * Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to the parent state\n     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = defaults(options, defautGoOpts, defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    \n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new TargetState(identifier, stateDefinition, params, options);\n    };\n    \n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        options = defaults(options, defaultTransOpts);\n        var getCurrent = function () {\n            return globals.transition;\n        };\n        options = extend(options, { current: getCurrent });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof Rejection) {\n                var isLatest = router.globals.lastStartedTransitionId === transition.$id;\n                if (error.type === exports.RejectType.IGNORED) {\n                    isLatest && router.urlRouter.update();\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    return services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === exports.RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === exports.RejectType.ABORTED) {\n                    isLatest && router.urlRouter.update();\n                    return services.$q.reject(error);\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return extend(transitionToPromise, { transition: transition });\n    };\n    \n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return Param.equals(schema, Param.values(schema, params), this.params);\n    };\n    \n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = defaults(options, { relative: this.$current });\n        var glob = isString(stateOrName) && Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!isDefined(state))\n            return undefined;\n        if (!isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return Param.equals(schema, Param.values(schema, params), this.params);\n    };\n    \n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current,\n        };\n        options = defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, params, {\n            absolute: options.absolute,\n        });\n    };\n    \n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = PathUtils.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\n\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nvar $q = {\n    /** Normalizes a value as a promise */\n    when: function (val$$1) { return new Promise(function (resolve, reject) { return resolve(val$$1); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val$$1) { return new Promise(function (resolve, reject) { reject(val$$1); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (isArray(promises)) {\n            return Promise.all(promises);\n        }\n        if (isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val$$1) { return ({ key: key, val: val$$1 }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return $q.all(chain).then(function (values$$1) {\n                return values$$1.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nvar $injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return $injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all$$1 = extend({}, globals, locals || {});\n        var params = $injector.annotate(fn);\n        var ensureExist = assertPredicate(function (key) { return all$$1.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all$$1[x]; });\n        if (isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar beforeAfterSubstr$1 = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nvar splitHash = beforeAfterSubstr$1(\"#\");\nvar splitQuery = beforeAfterSubstr$1(\"?\");\nvar splitEqual = beforeAfterSubstr$1(\"=\");\nvar trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nvar keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val$$1 = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val$$1;\n    }\n    else if (isArray(accum[key])) {\n        accum[key].push(val$$1);\n    }\n    else {\n        accum[key] = [accum[key], val$$1];\n    }\n    return accum;\n};\nvar getParams = function (queryString) {\n    return queryString.split(\"&\").filter(identity).map(splitEqual).reduce(keyValsToObjectR, {});\n};\nfunction parseUrl$1(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nvar buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = isArray(param) ? param : [param];\n        return vals.map(function (val$$1) { return key + \"=\" + val$$1; });\n    }).reduce(unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\n\n/**\n * @internalapi\n * @module vanilla\n */ /** */\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return parseUrl$1(_this._get()).hash; };\n        this.path = function () { return parseUrl$1(_this._get()).path; };\n        this.search = function () { return getParams(parseUrl$1(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(BaseLocationServices));\n\nvar __extends$1 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends$1(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(BaseLocationServices));\n\nvar __extends$2 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends$2(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    \n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = splitQuery(search)[1]; // strip ? if found\n        hash = splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(BaseLocationServices));\n\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = noop;\n    }\n    return MemoryLocationConfig;\n}());\n\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        if (location.port) {\n            return Number(location.port);\n        }\n        return this.protocol() === 'https' ? 443 : 80;\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol.replace(/:/g, '');\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.hostname;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    \n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\n\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nfunction servicesPlugin(router) {\n    services.$injector = $injector;\n    services.$q = $q;\n    return { name: \"vanilla.services\", $q: $q, $injector: $injector, dispose: function () { return null; } };\n}\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nvar hashLocationPlugin = locationPluginFactory('vanilla.hashBangLocation', false, HashLocationService, BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nvar pushStateLocationPlugin = locationPluginFactory(\"vanilla.pushStateLocation\", true, PushStateLocationService, BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nvar memoryLocationPlugin = locationPluginFactory(\"vanilla.memoryLocation\", false, MemoryLocationService, MemoryLocationConfig);\n\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n\n/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\n\n/**\n * @coreapi\n * @module common\n */ /** */\n\nexports.fromJson = fromJson;\nexports.toJson = toJson;\nexports.copy = copy;\nexports.forEach = forEach;\nexports.extend = extend;\nexports.equals = equals;\nexports.identity = identity;\nexports.noop = noop;\nexports.createProxyFunctions = createProxyFunctions;\nexports.inherit = inherit;\nexports.inArray = inArray;\nexports._inArray = _inArray;\nexports.removeFrom = removeFrom;\nexports._removeFrom = _removeFrom;\nexports.pushTo = pushTo;\nexports._pushTo = _pushTo;\nexports.deregAll = deregAll;\nexports.defaults = defaults;\nexports.mergeR = mergeR;\nexports.ancestors = ancestors;\nexports.pick = pick;\nexports.omit = omit;\nexports.pluck = pluck;\nexports.filter = filter;\nexports.find = find;\nexports.mapObj = mapObj;\nexports.map = map;\nexports.values = values;\nexports.allTrueR = allTrueR;\nexports.anyTrueR = anyTrueR;\nexports.unnestR = unnestR;\nexports.flattenR = flattenR;\nexports.pushR = pushR;\nexports.uniqR = uniqR;\nexports.unnest = unnest;\nexports.flatten = flatten;\nexports.assertPredicate = assertPredicate;\nexports.assertMap = assertMap;\nexports.assertFn = assertFn;\nexports.pairs = pairs;\nexports.arrayTuples = arrayTuples;\nexports.applyPairs = applyPairs;\nexports.tail = tail;\nexports._extend = _extend;\nexports.silenceUncaughtInPromise = silenceUncaughtInPromise;\nexports.silentRejection = silentRejection;\nexports.notImplemented = notImplemented;\nexports.services = services;\nexports.Glob = Glob;\nexports.curry = curry;\nexports.compose = compose;\nexports.pipe = pipe;\nexports.prop = prop;\nexports.propEq = propEq;\nexports.parse = parse;\nexports.not = not;\nexports.and = and;\nexports.or = or;\nexports.all = all;\nexports.any = any;\nexports.is = is;\nexports.eq = eq;\nexports.val = val;\nexports.invoke = invoke;\nexports.pattern = pattern;\nexports.isUndefined = isUndefined;\nexports.isDefined = isDefined;\nexports.isNull = isNull;\nexports.isNullOrUndefined = isNullOrUndefined;\nexports.isFunction = isFunction;\nexports.isNumber = isNumber;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isArray = isArray;\nexports.isDate = isDate;\nexports.isRegExp = isRegExp;\nexports.isState = isState;\nexports.isInjectable = isInjectable;\nexports.isPromise = isPromise;\nexports.Queue = Queue;\nexports.maxLength = maxLength;\nexports.padString = padString;\nexports.kebobString = kebobString;\nexports.functionToString = functionToString;\nexports.fnToString = fnToString;\nexports.stringify = stringify;\nexports.beforeAfterSubstr = beforeAfterSubstr;\nexports.splitOnDelim = splitOnDelim;\nexports.joinNeighborsR = joinNeighborsR;\nexports.Trace = Trace;\nexports.trace = trace;\nexports.Param = Param;\nexports.ParamTypes = ParamTypes;\nexports.StateParams = StateParams;\nexports.ParamType = ParamType;\nexports.PathNode = PathNode;\nexports.PathUtils = PathUtils;\nexports.resolvePolicies = resolvePolicies;\nexports.defaultResolvePolicy = defaultResolvePolicy;\nexports.Resolvable = Resolvable;\nexports.NATIVE_INJECTOR_TOKEN = NATIVE_INJECTOR_TOKEN;\nexports.ResolveContext = ResolveContext;\nexports.resolvablesBuilder = resolvablesBuilder;\nexports.StateBuilder = StateBuilder;\nexports.StateObject = StateObject;\nexports.StateMatcher = StateMatcher;\nexports.StateQueueManager = StateQueueManager;\nexports.StateRegistry = StateRegistry;\nexports.StateService = StateService;\nexports.TargetState = TargetState;\nexports.HookBuilder = HookBuilder;\nexports.matchState = matchState;\nexports.RegisteredHook = RegisteredHook;\nexports.makeEvent = makeEvent;\nexports.Rejection = Rejection;\nexports.Transition = Transition;\nexports.TransitionHook = TransitionHook;\nexports.TransitionEventType = TransitionEventType;\nexports.defaultTransOpts = defaultTransOpts;\nexports.TransitionService = TransitionService;\nexports.UrlMatcher = UrlMatcher;\nexports.UrlMatcherFactory = UrlMatcherFactory;\nexports.UrlRouter = UrlRouter;\nexports.UrlRuleFactory = UrlRuleFactory;\nexports.BaseUrlRule = BaseUrlRule;\nexports.UrlService = UrlService;\nexports.ViewService = ViewService;\nexports.UIRouterGlobals = UIRouterGlobals;\nexports.UIRouter = UIRouter;\nexports.$q = $q;\nexports.$injector = $injector;\nexports.BaseLocationServices = BaseLocationServices;\nexports.HashLocationService = HashLocationService;\nexports.MemoryLocationService = MemoryLocationService;\nexports.PushStateLocationService = PushStateLocationService;\nexports.MemoryLocationConfig = MemoryLocationConfig;\nexports.BrowserLocationConfig = BrowserLocationConfig;\nexports.splitHash = splitHash;\nexports.splitQuery = splitQuery;\nexports.splitEqual = splitEqual;\nexports.trimHashVal = trimHashVal;\nexports.keyValsToObjectR = keyValsToObjectR;\nexports.getParams = getParams;\nexports.parseUrl = parseUrl$1;\nexports.buildUrl = buildUrl;\nexports.locationPluginFactory = locationPluginFactory;\nexports.servicesPlugin = servicesPlugin;\nexports.hashLocationPlugin = hashLocationPlugin;\nexports.pushStateLocationPlugin = pushStateLocationPlugin;\nexports.memoryLocationPlugin = memoryLocationPlugin;\nexports.UIRouterPluginBase = UIRouterPluginBase;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=ui-router-core.js.map\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@uirouter/core/_bundles/ui-router-core.js\n ** module id = 6\n ** module chunks = 0\n **/","(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['angular'], factory);\n  } else if (root.hasOwnProperty('angular')) {\n    // Browser globals (root is window), we don't register it.\n    factory(root.angular);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('angular'));\n  }\n}(this , function (angular) {\n    'use strict';\n\n    // In cases where Angular does not get passed or angular is a truthy value\n    // but misses .module we can fall back to using window.\n    angular = (angular && angular.module ) ? angular : window.angular;\n\n\n    function isStorageSupported($window, storageType) {\n\n      // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n      // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n      // that error and allow execution to continue.\n\n      // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n      // when \"Block cookies\": \"Always block\" is turned on\n      var supported;\n      try {\n        supported = $window[storageType];\n      }\n      catch(err) {\n        supported = false;\n      }\n\n      // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage and sessionStorage\n      // is available, but trying to call .setItem throws an exception below:\n      // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n      if(supported) {\n        var key = '__' + Math.round(Math.random() * 1e7);\n        try {\n          $window[storageType].setItem(key, key);\n          $window[storageType].removeItem(key, key);\n        }\n        catch(err) {\n          supported = false;\n        }\n      }\n\n      return supported;\n    }\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    return angular.module('ngStorage', [])\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$localStorage', _storageProvider('localStorage'))\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\n    function _storageProvider(storageType) {\n        var providerWebStorage = isStorageSupported(window, storageType);\n\n        return function () {\n          var storageKeyPrefix = 'ngStorage-';\n\n          this.setKeyPrefix = function (prefix) {\n            if (typeof prefix !== 'string') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n            }\n            storageKeyPrefix = prefix;\n          };\n\n          var serializer = angular.toJson;\n          var deserializer = angular.fromJson;\n\n          this.setSerializer = function (s) {\n            if (typeof s !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n            }\n\n            serializer = s;\n          };\n\n          this.setDeserializer = function (d) {\n            if (typeof d !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n            }\n\n            deserializer = d;\n          };\n\n          this.supported = function() {\n            return !!providerWebStorage;\n          };\n\n          // Note: This is not very elegant at all.\n          this.get = function (key) {\n            return providerWebStorage && deserializer(providerWebStorage.getItem(storageKeyPrefix + key));\n          };\n\n          // Note: This is not very elegant at all.\n          this.set = function (key, value) {\n            return providerWebStorage && providerWebStorage.setItem(storageKeyPrefix + key, serializer(value));\n          };\n\n          this.remove = function (key) {\n            providerWebStorage && providerWebStorage.removeItem(storageKeyPrefix + key);\n          }\n\n          this.$get = [\n              '$rootScope',\n              '$window',\n              '$log',\n              '$timeout',\n              '$document',\n\n              function(\n                  $rootScope,\n                  $window,\n                  $log,\n                  $timeout,\n                  $document\n              ){\n\n                // The magic number 10 is used which only works for some keyPrefixes...\n                // See https://github.com/gsklee/ngStorage/issues/137\n                var prefixLength = storageKeyPrefix.length;\n\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                // Note: recheck mainly for testing (so we can use $window[storageType] rather than window[storageType])\n                var isSupported = isStorageSupported($window, storageType),\n                    webStorage = isSupported || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n                            }\n\n                            $storage.$sync();\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n                            }\n\n                            return $storage.$default(items);\n                        },\n                        $sync: function () {\n                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n                            }\n                        },\n                        $apply: function() {\n                            var temp$storage;\n\n                            _debounce = null;\n\n                            if (!angular.equals($storage, _last$storage)) {\n                                temp$storage = angular.copy(_last$storage);\n                                angular.forEach($storage, function(v, k) {\n                                    if (angular.isDefined(v) && '$' !== k[0]) {\n                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n                                        delete temp$storage[k];\n                                    }\n                                });\n\n                                for (var k in temp$storage) {\n                                    webStorage.removeItem(storageKeyPrefix + k);\n                                }\n\n                                _last$storage = angular.copy($storage);\n                            }\n                        },\n                        $supported: function() {\n                            return !!isSupported;\n                        }\n                    },\n                    _last$storage,\n                    _debounce;\n\n                $storage.$sync();\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if (!event.key) {\n                      return;\n                    }\n\n                    // Reference doc.\n                    var doc = $document[0];\n\n                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n                    $storage.$apply();\n                });\n\n                return $storage;\n              }\n          ];\n      };\n    }\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngstorage/ngStorage.js\n ** module id = 7\n ** module chunks = 0\n **/","routing.$inject = ['$urlRouterProvider', '$locationProvider'];\n\nexport default function routing($urlRouterProvider, $locationProvider) {\n\t$locationProvider.hashPrefix('');\n\t$locationProvider.html5Mode(true);\n\t$urlRouterProvider.otherwise('/');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.config.js\n **/","run.$inject = ['$rootScope', '$http', '$location', '$localStorage'];\n\nexport default function run($rootScope, $http, $location, $localStorage) {\n\tif ($localStorage.currentUser) {\n\t\t$http.defaults.headers.common.Authorization = 'Bearer ' + $localStorage.currentUser.token;\n\t}\n\n\t$rootScope.$on('$locationChangeStart', (event, next, current) => { //eslint-disable-line no-unused-vars\n\t\tconst publicPages = ['/', '/features', '/pricing', '/about', '/login'];\n\t\tlet restrictedPage = publicPages.indexOf($location.path()) === -1;\n\n\t\tif (restrictedPage && !$localStorage.currentUser) {\n\t\t\t$location.path('/login');\n\t\t}\n\t});\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.run.js\n **/","import './navbar.css';\n\nimport angular from 'angular';\n\nimport NavbarController from './navbar.controller';\nimport navbar from './navbar.directive';\n\nexport default angular.module('arrowfinds.navbar', [navbar])\n\t.controller('NavbarController', NavbarController)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/navbar/index.js\n **/","export default class NavbarController {\n\tconstructor($location) {\n\t\tthis.location = $location;\n\t\tthis.$ = window.$;\n\t\tthis.LoginStatus = 'Login';\n\t\tthis.loggedIn = false;\n\t}\n\n\tgotoAnchor(id) {\n\t\tthis.$('html, body').animate({\n\t\t\tscrollTop: this.$('#' + id).offset().top\n\t\t}, 1000);\n\t}\n\n\tlogin() {\n\t\tif (this.loggedIn) {\n\t\t\tthis.location.path('/');\n\t\t\tthis.LoginStatus = 'Login';\n\t\t} else {\n\t\t\tthis.location.hash('');\n\t\t\tthis.location.path('/login');\n\t\t}\n\t}\n}\n\nNavbarController.$inject = ['$location'];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/navbar/navbar.controller.js\n **/","import angular from 'angular';\nimport template  from './navbar.html';\n\nfunction navbar() {\n  return {\n    restrict: 'E',\n\t\ttemplate: template,\n\t\tcontroller: 'NavbarController',\n\t\tcontrollerAs: 'navbar'\n  }\n}\n\nexport default angular.module('directives.navbar', [])\n  .directive('navbar', navbar)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/navbar/navbar.directive.js\n **/","module.exports = \"<nav class=\\\"navbar navbar-expand-md navbar-dark bg-dark fixed-top\\\"> <a class=navbar-brand href=/ ng-click=\\\"navbar.gotoAnchor('home')\\\"> <img src=/images/logo-transparent.png width=30 height=30 class=\\\"d-inline-block align-top\\\" alt=\\\"\\\"> ArrowFinds </a> <button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarsExampleDefault aria-controls=navbarsExampleDefault aria-expanded=false aria-label=\\\"Toggle navigation\\\"> <span class=navbar-toggler-icon></span> </button> <div class=\\\"collapse navbar-collapse\\\" id=navbarsExampleDefault> <ul class=\\\"navbar-nav mr-auto\\\"> <li class=\\\"nav-item active\\\"> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('home')\\\">Home<span class=sr-only>(current)</span></a> </li> <li class=nav-item> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('features')\\\">Features</a> </li> <li class=nav-item> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('pricing')\\\">Pricing</a> </li> <li class=nav-item> <a class=nav-link href=/ ng-click=\\\"navbar.gotoAnchor('about')\\\">About</a> </li> <li class=nav-item> <a class=nav-link href=/login ng-click=navbar.login()>{{navbar.LoginStatus}}</a> </li> <li class=nav-item> <a class=nav-link href=/affiliate>Affiliate</a> </li> </ul> <form class=\\\"form-inline my-2 my-lg-0\\\"> <input class=\\\"form-control mr-sm-2\\\" type=text placeholder=Search aria-label=Search> <button class=\\\"btn btn-outline-info my-2 my-sm-0\\\" type=submit>Search</button> </form> </div> </nav> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/navbar/navbar.html\n ** module id = 14\n ** module chunks = 0\n **/","import './landing.css';\n\nimport angular from 'angular';\nimport uirouter from '@uirouter/angularjs';\nimport routing from './landing.routes';\n\nimport home from './home';\nimport features from './features';\nimport pricing from './pricing';\nimport about from './about';\n\nexport default angular.module('arrowfinds.landing', [uirouter, home, features, pricing, about])\n\t.config(routing)\n\t.name;\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/index.js\n **/","import template from './landing.html';\n\nroutes.$inject = ['$stateProvider'];\n\nexport default function routes($stateProvider) {\n  $stateProvider\n    .state('/', {\n      url: '/',\n      template: template\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/landing.routes.js\n **/","module.exports = \"<div id=sections> <home></home> <features></features> <pricing></pricing> <about></about> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/landing.html\n ** module id = 18\n ** module chunks = 0\n **/","import './home.css'\n\nimport angular from 'angular';\n\nimport home from './home.directive';\n\nexport default angular.module('arrowfinds.home', [home])\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/home/index.js\n **/","import angular from 'angular';\r\nimport template  from './home.html'\r\n\r\nfunction home() {\r\n  return {\r\n    restrict: 'E',\r\n    template: template \r\n  }\r\n}\r\n\r\nexport default angular.module('directives.home', [])\r\n  .directive('home', home)\r\n  .name;\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/home/home.directive.js\n **/","module.exports = \"<header id=home> <div class=\\\"col-lg-12 intro-text text-center\\\"> <img src=/images/logo-transparent.png /> <p class=name>ArrowFinds</p> <p class=description>DropShipping Products Finder</p> </div> </header> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/home/home.html\n ** module id = 22\n ** module chunks = 0\n **/","import './features.css';\n\nimport angular from 'angular';\n\nimport features from './features.directive';\nimport feature from './feature';\n\nexport default angular.module('arrowfinds.features', [features, feature])\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/features/index.js\n **/","import angular from 'angular';\nimport template  from './features.html';\n\nfunction features() {\n  return {\n    restrict: 'E',\n    template: template \n  }\n}\n\nexport default angular.module('directives.features', [])\n  .directive('features', features)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/features/features.directive.js\n **/","module.exports = \"<section id=features> <div class=container> <div class=row> <div class=\\\"col-12 text-truncate features-title\\\"> <p class=\\\"text-center font-weight-bold\\\">Our Features</p> </div> </div> <div class=row> <div class=\\\"card-deck features-card-fix\\\"> <feature image=magnifier.png text=\\\"Find the best DropShipping products for ebay\\\"></feature> <feature image=ecommerce.jpg text=\\\"Find droppers from the largest platforms\\\"></feature> <feature image=affiliate-marketing.jpg text=\\\"Earn money from affiliate program\\\"></feature> <feature image=monitor.jpg text=\\\"Upload your products to your favorite monitor\\\"></feature> </div> </div> </div> </section> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/features/features.html\n ** module id = 26\n ** module chunks = 0\n **/","import './feature.css';\n\nimport angular from 'angular';\n\nimport feature from './feature.directive';\n\nexport default angular.module('arrowfinds.features.feature', [feature])\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/features/feature/index.js\n **/","import angular from 'angular';\nimport template  from './feature.html';\n\nfunction feature() {\n  return {\n    restrict: 'E',\n\t\ttemplate: template,\n\t\treplace: true,\n\t\tscope: {\n\t\t\timage: '@',\n\t\t\ttext: '@',\n    }\n  }\n}\n\nexport default angular.module('directives.features.feature', [])\n  .directive('feature', feature)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/features/feature/feature.directive.js\n **/","module.exports = \"<div class=\\\"card feature border-info mb-3\\\"> <img class=\\\"card-img-top border border-top-0 border-right-0 border-left-0 border-bottom border-info\\\" src=/images/{{image}} alt={{image}}> <div class=card-body> <p class=card-text>{{text}}</p> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/features/feature/feature.html\n ** module id = 30\n ** module chunks = 0\n **/","import './pricing.css';\n\nimport angular from 'angular';\n\nimport pricing from './pricing.directive';\nimport price from './price';\n\nexport default angular.module('arrowfinds.pricing', [pricing, price])\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/pricing/index.js\n **/","import angular from 'angular';\nimport template  from './pricing.html';\n\nfunction pricing() {\n  return {\n    restrict: 'E',\n    template: template \n  }\n}\n\nexport default angular.module('directives.pricing', [])\n  .directive('pricing', pricing)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/pricing/pricing.directive.js\n **/","module.exports = \"<section id=pricing> <div class=\\\"container pricing-footer-margin\\\"> <div class=row> <div class=\\\"col-12 text-truncate pricing-title\\\"> <p class=\\\"text-center font-weight-bold\\\">Pricing</p> </div> </div> <div class=row> <price title=basic cost=9.99 months=1 products=1000></price> <div class=col></div> <price title=premium cost=29.90 months=2 products=5000></price> </div> </div> </section> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/pricing/pricing.html\n ** module id = 34\n ** module chunks = 0\n **/","import './price.css';\n\nimport angular from 'angular';\n\nimport price from './price.directive';\n\nexport default angular.module('arrowfinds.pricing.price', [price])\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/pricing/price/index.js\n **/","import angular from 'angular';\nimport template  from './price.html';\n\nfunction price() {\n  return {\n    restrict: 'E',\n\t\ttemplate: template,\n\t\treplace: true,\n\t\tscope: {\n\t\t\ttitle: '@',\n\t\t\tcost: '=',\n\t\t\tmonths: '=',\n\t\t\tproducts: '='\n    }\n  }\n}\n\nexport default angular.module('directives.pricing.price', [])\n  .directive('price', price)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/pricing/price/price.directive.js\n **/","module.exports = \"<div class=\\\"card card-pricing col-md-5 col-sm-8 text-center\\\"> <div class=\\\"card-header card-pricing-header\\\"> <h3 class=\\\"card-title white\\\">{{title}}</h3> </div> <div class=\\\"card-body card-pricing-body\\\"> <h4>{{cost | currency}}</h4> <ul class=list-group> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;{{months}} month use</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;{{products}} products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;hottest products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;products and sellers finding</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;24/7 support</i></li> </ul> </div> <div class=\\\"card-footer card-pricing-footer\\\"> <a href=/#!/premium class=\\\"btn btn-lg btn-block card-pricing-button white\\\">Buy now</a> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/pricing/price/price.html\n ** module id = 38\n ** module chunks = 0\n **/","import './about.css';\n\nimport angular from 'angular';\n\nimport about from './about.directive';\nimport card from './card';\n\nexport default angular.module('arrowfinds.about', [about, card])\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/about/index.js\n **/","import angular from 'angular';\r\nimport template  from './about.html';\r\n\r\nfunction about() {\r\n  return {\r\n    restrict: 'E',\r\n    template: template \r\n  }\r\n}\r\n\r\nexport default angular.module('directives.about', [])\r\n  .directive('about', about)\r\n  .name;\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/about/about.directive.js\n **/","module.exports = \"<section id=about> <div class=container> <div class=\\\"col-12 text-truncate about-title\\\"> <p class=\\\"text-center font-weight-bold\\\">About Us</p> </div> <div class=row> <card name=\\\"Ido Bleicher\\\" role=Co-Founder sentence=\\\"Crazy for money\\\" motto=\\\"To be or not to be..\\\" followers=1335 following=114 projects=58 facebook=https://www.facebook.com/ido.bleicher linkedin=https://www.linkedin.com/in/ido-bleicher-223818137/ github=https://github.com/iuyt9003></card> <card name=\\\"Yonatan Kreiner\\\" role=Co-Founder sentence=\\\"Crazy for motorcycles\\\" motto=\\\"It's not about timing the market it's about time in the market\\\" followers=500 following=110 projects=39 facebook=https://www.facebook.com/yonatankreiner linkedin=https://www.linkedin.com/in/yonatan-kreiner/ github=https://github.com/yonatanKreiner></card> </div> </div> </section> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/about/about.html\n ** module id = 42\n ** module chunks = 0\n **/","import './card.css';\n\nimport angular from 'angular';\n\nimport card from './card.directive';\n\nexport default angular.module('arrowfinds.about.card', [card])\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/about/card/index.js\n **/","import angular from 'angular';\nimport template  from './card.html';\n\nfunction card() {\n  return {\n    restrict: 'E',\n\t\ttemplate: template,\n\t\treplace: true,\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\trole: '@',\n\t\t\tsentence: '@',\n\t\t\tmotto: '@',\n\t\t\tfollowers: '@',\n\t\t\tfollowing: '@',\n\t\t\tprojects: '@',\n\t\t\tfacebook: '@',\t\t\n\t\t\tlinkedin: '@',\t\t\n\t\t\tgithub: '@'\n\t\t}\n  }\n}\n\nexport default angular.module('directives.about.card', [])\n  .directive('card', card)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/landing/about/card/card.directive.js\n **/","module.exports = \"<div class=\\\"col-md-6 col-sm-6\\\"> <div class=card-container> <div class=card> <div class=front> <div class=cover> <img src=/images/beach-beverage-caribbean-cocktail.jpg /> </div> <div class=user> <img class=img-circle src=/images/{{name}}.png /> </div> <div class=content> <div class=main> <h3 class=name>{{name}}</h3> <p class=profession>{{role}}</p> <p class=text-center>\\\"{{sentence}}\\\"</p> </div> </div> <div class=footer> <i class=\\\"fa fa-male\\\" aria-hidden=true></i>&nbsp;&nbsp;ArrowFinds team </div> </div> <div class=back> <div class=header> <h5 class=motto>{{name}}</h5> </div> <div class=content> <div class=main> <h4 class=text-center>{{role}}</h4> <p class=text-center>\\\"{{motto}}\\\"</p> <div class=stats-container> <div class=stats> <h4>{{followers}}</h4> <p>Followers</p> </div> <div class=stats> <h4>{{following}}</h4> <p>Following</p> </div> <div class=stats> <h4>{{projects}}</h4> <p>Projects</p> </div> </div> </div> </div> <div class=footer> <div class=\\\"social-links text-center\\\"> <a href={{facebook}} class=facebook> <i class=\\\"fa fa-facebook fa-fw\\\"></i> </a> <a href={{linkedin}} class=linkedin> <i class=\\\"fa fa-linkedin\\\" aria-hidden=true></i> </a> <a href={{github}} class=github> <i class=\\\"fa fa-github\\\" aria-hidden=true></i> </a> </div> </div> </div> </div> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/landing/about/card/card.html\n ** module id = 46\n ** module chunks = 0\n **/","import './login.css'\n\nimport angular from 'angular';\nimport uirouter from '@uirouter/angularjs';\n\nimport routing from './login.routes';\nimport LoginController from './login.controller';\nimport authentication from '../../services/authentication.service';\n\nexport default angular.module('arrowfinds.login', [uirouter, authentication])\n  .config(routing)\n  .controller('LoginController', LoginController)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/login/index.js\n **/","import template from './login.html';\n\nroutes.$inject = ['$stateProvider'];\n\nexport default function routes($stateProvider) {\n  $stateProvider\n    .state('login', {\n      url: '/login',\n      template: template,\n      controller: 'LoginController',\n      controllerAs: 'login'\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/login/login.routes.js\n **/","module.exports = \"<section id=login-section> <div class=container> <div class=row> <div class=col-2></div> <div class=col-8> <div class=box> <div class=box-icon> <div class=\\\"fa fa-4x fa-user\\\"></div> </div> <h4 class=\\\"title text-center\\\">Register / Login User</h4> <form name=sign novalidate> <div class=\\\"input-group form-row input\\\"> <div class=input-group-addon> <i class=\\\"fa fa-envelope\\\"></i> </div> <input type=email name=email class=\\\"form-control email validate valid\\\" ng-model=login.email placeholder=Email required> <div class=invalid-feedback ng-show=sign.email.$invalid> Email is not valid </div> </div> <div class=\\\"input-group form-row input\\\"> <div class=\\\"input-group-addon lock\\\"> <i class=\\\"fa fa-lock\\\"></i> </div> <input type=password name=password class=\\\"form-control password validate valid\\\" ng-model=login.password placeholder=Password ng-minlength=6 required> <div class=invalid-feedback ng-show=\\\"sign.password.$error.minlength || sign.password.$invalid\\\"> Password must be at least 6 digits </div> </div> <div class=text-center ng-show=login.error> <h3 class=error-show><i class=\\\"fa fa-exclamation-triangle\\\"></i>{{login.error}}</h3> </div> <br/> <div class=\\\"form-group form-row\\\"> <div class=col-4>\\t</div> <div class=col-2> <button type=submit class=\\\"btn btn-success\\\" ng-click=\\\"login.signIn(login.email, login.password)\\\" ng-disabled=\\\"sign.password.$error.minlength || sign.password.$invalid || sign.email.$invalid\\\">Login <i class=\\\"fa fa-sign-in\\\"></i> </button> </div> <div class=col-2> <button type=submit class=\\\"btn btn-success\\\" ng-click=\\\"login.signUp(login.email, login.password)\\\" ng-disabled=\\\"sign.password.$error.minlength || sign.password.$invalid || sign.email.$invalid\\\">Register <i class=\\\"fa fa-user-plus\\\"></i> </button> </div> </div> </form> </div> </div> <div class=col-2></div> </div> </div> </section> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/login/login.html\n ** module id = 50\n ** module chunks = 0\n **/","export default class LoginController {\n  constructor($location, authentication) {\n\t\tthis.location = $location;\n\t\tthis.authentication = authentication;\n    this.error = '';\n  }\n\n\tsignUp(email, password){\n\t\tthis.authentication.register(email, password).then(\n\t\t\tresult => {\n\t\t\t\tif (result) {\n\t\t\t\t\tthis.window.ga('send', 'event', 'Users', 'register');\n\t\t\t\t\tthis.error = 'An email was sent to your address';\n\t\t\t\t} else {\n\t\t\t\t\tthis.error = 'Could not create user. Please try again';\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tsignIn(email, password){\n\t\tthis.authentication.login(email, password).then(\n\t\t\tresult => {\n\t\t\t\tif (result) {\n\t\t\t\t\tthis.location.path('/monitor');\n\t\t\t\t} else {\n\t\t\t\t\tthis.error = 'Email or password is incorrect';\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n}\n\nLoginController.$inject = ['$location', 'authentication'];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/login/login.controller.js\n **/","import angular from 'angular';\n\nclass Authentication {\n  constructor($http, $window, $localStorage) {\n\t\tthis.http = $http;\n\t\tthis.window = $window;\n\t\tthis.localStorage = $localStorage;\n\t\tthis.api = 'http://127.0.0.1:5000/';\n\t}\n\t\n\tregister(email, password) {\n\t\treturn this.http.post(this.api + 'users', { email: email, password: password})\n\t\t.then(response => { //eslint-disable-line no-unused-vars\n\t\t\treturn true;\n\t\t}, err => {\n\t\t\tif (this.window.analytics) {\n\t\t\t\tthis.window.analytics('event', 'exception', {\n\t\t\t\t\tdescription: err.status + ': ' + err.message,\n\t\t\t\t\tfatal: false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n  login(email, password) {\n\t\treturn this.http.post(this.api + 'auth', { email: email, password: password})\n\t\t\t.then(response => {\n\t\t\t\tif (response.data) {\n\t\t\t\t\tthis.localStorage.currentUser = { email: email, token: response.data };\n\t\t\t\t\tthis.http.defaults.headers.common.Authorization = 'Bearer ' + response.data;\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}, err => {\n\t\t\t\tif (this.window.analytics) {\n\t\t\t\t\tthis.window.analytics('event', 'exception', {\n\t\t\t\t\t\tdescription: err.status + ': ' + err.data,\n\t\t\t\t\t\tfatal: false\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t});\n\t}\n\n\tlogout() {\n\t\tdelete this.localStorage.currentUser;\n\t\tthis.http.defaults.headers.common.Authorization = '';\n\t}\n\n\tgetTokenData(key) {\n\t\tconst encodedToken = this.localStorage.currentUser.token;\n\t\tconst decodedToken = atob(encodedToken.split('.')[1]);\n\t\tconst data = JSON.parse(decodedToken);\n\t\t\n\t\treturn data[key];\n\t}\n}\n\nexport default angular.module('services.authentication', [])\n  .service('authentication', Authentication)\n\t.name;\n\t\nAuthentication.$inject = ['$http', '$window', '$localStorage'];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/services/authentication.service.js\n **/","import './monitor.css';\n\nimport angular from 'angular';\nimport uirouter from '@uirouter/angularjs';\n\nimport routing from './monitor.routes';\nimport MonitorController from './monitor.controller';\n\nexport default angular.module('arrowfinds.monitor', [uirouter])\n\t.config(routing)\n\t.controller('MonitorController', MonitorController)\n\t.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/monitor/index.js\n **/","import template from './monitor.html';\n\nroutes.$inject = ['$stateProvider'];\n\nexport default function routes($stateProvider) {\n\t$stateProvider\n\t\t.state('monitor', {\n\t\t\turl: '/monitor',\n\t\t\ttemplate: template,\n\t\t\tcontroller: 'MonitorController',\n\t\t\tcontrollerAs: 'monitor'\n\t\t});\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/monitor/monitor.routes.js\n **/","module.exports = \"{{monitor.user}} \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/monitor/monitor.html\n ** module id = 56\n ** module chunks = 0\n **/","export default class MonitorController {\r\n\tconstructor($location, userdata) {\r\n\t\tthis.location = $location;\r\n\t\tthis.error = '';\r\n\t\tthis.userdata = userdata;\r\n\t}\r\n\r\n\tGetUserData() {\r\n\t\tthis.user = this.userdata.GetUserData();\r\n\t}\r\n\r\n}\r\n\r\nMonitorController.$inject = ['$location', 'userdata'];\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/monitor/monitor.controller.js\n **/","import './affiliate.css';\n\nimport angular from 'angular';\nimport uirouter from '@uirouter/angularjs';\n\nimport routing from './affiliate.routes';\nimport AffiliateController from './affiliate.controller';\nimport authentication from '../../services/authentication.service';\nimport userdata from '../../services/userdata.service';\n\nexport default angular.module('arrowfinds.affiliate', [uirouter, authentication, userdata])\n  .config(routing)\n  .controller('AffiliateController', AffiliateController)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/affiliate/index.js\n **/","import template from './affiliate.html';\n\nroutes.$inject = ['$stateProvider'];\n\nexport default function routes($stateProvider) {\n  $stateProvider\n    .state('affiliate', {\n      url: '/affiliate',\n      template: template,\n      controller: 'AffiliateController',\n      controllerAs: 'affiliate'\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/affiliate/affiliate.routes.js\n **/","module.exports = \"<section id=affliate> <div class=container> <div class=row> <div class=\\\"col-md-12 col-sm-12\\\"> <h1>Welcome to the affiliate page: {{affiliate.email}} </h1> <div> <h2>Here is your ref code: </h2> <div> <code><h4>https://arrowfinds.com/aff?ref={{affiliate.userCode}}</h4></code> </div> <br/> <h5>You Have: <span style=color:green>{{affiliate.needpay | currency:'USD$':2}}</span> </h5> <button class=\\\"btn btn-primary\\\"> <i class=\\\"fa fa-credit-card-alt\\\"></i> Checkout</button> <h5> <span style=color:red>Only when 10$+</span> </h5> </div> <div> <h4>Precentage: {{(affiliate.profit / affiliate.stage ) * 100 | currency:'%':2}} </h4> <div style=display:flex> <h5 style=margin-top:10%>{{affiliate.reward}}</h5> </div> </div> </div> </div> <div class=row> <div id=skillgraph class=\\\"panel panel-default row\\\"> <div class=\\\"panel-title text-Left\\\"></div> <div class=\\\"row skill-row\\\"> <span class=skillLabel>To Next level: </span> <code>More - {{(affiliate.stage - affiliate.profit) | currency:'USD$':2}} To go!</code> <br/> <span class=skillData-Wrapper> <span class=\\\"skillData bg\\\" style=background-color:green data-percent=100> {{affiliate.level}} - {{(affiliate.profit / affiliate.userStage) * 100 | currency:'%':2}}</span> </span> </div> <div class=\\\"row skill-row\\\"> <span class=skillLabel>Total Sold:</span> <code>Your Profit - {{affiliate.needpay | currency:'USD$':2}}</code> <br/> <span class=skillData-Wrapper> <span class=\\\"skillData bg-rust\\\" data-percent=100>{{affiliate.profit | currency:'USD$':2}}</span> </span> </div> <div class=\\\"row skill-row\\\"> <span class=skillLabel>Ref Joined Count:</span> <span class=skillData-Wrapper> <span class=\\\"skillData bg-blue\\\" data-percent=100>RefCounts - {{affiliate.usersReferred}}</span> </span> </div> </div> </div> </div> </section> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/affiliate/affiliate.html\n ** module id = 61\n ** module chunks = 0\n **/","export default class AffiliateController {\n  constructor(authentication, userdata) {\n\t\tthis.authentication = authentication;\n\t\tthis.userdata = userdata;\n\t\tthis.api = 'http://127.0.0.1:5000/';\n\t\tthis.userCode = this.getUserCode();\n\t}\n\t\n\tgetUserCode() {\n\t\treturn this.authentication.getTokenData('sub');\n\t}\n\n\tgetAffiliateData() {\n\t\tconst affiliateData = this.userdata.getAffiliateData();\n\t\tthis.paypal = affiliateData.paypal;\n\t\tthis.usersReferred = affiliateData.users_referred;\n\t\tthis.profit = affiliateData.profit;\n\t\tthis.checkout = affiliateData.checkout;\n\t}\n}\n\nAffiliateController.$inject = ['authentication', 'userdata'];\n\n\n\n// Maybe needs this if not remove\n\t\t// this.textRank = \"\";\n\t\t// this.reward = \"\";\n\t\t// this.userStage = 500;\n\t\t// this.level = \"level1\";\n\n\t\t// var USER_FIRST_PRICE = 500\n\t\t// var USER_SECOND_PRICE = 1500\n\t\t// var USER_THIRD_PRICE = 3000\n\t\t// var USER_FOURTH_PRICE = 6000\n\t\t// var USER_FIFTH_PRICE = 10000\n\n\t\t// var Userprofit = this.$rootScope.profit;\n\n\t\t// // Calculate User stage - i know about switch case, next version i will add it. (i know you reading it ;) )\n\t\t// if (Userprofit < USER_FIFTH_PRICE)\n\t\t// {\n\t\t// \tif (Userprofit < USER_FOURTH_PRICE)\n\t\t// \t{\n\t\t// \t\tif (Userprofit < USER_THIRD_PRICE)\n\t\t// \t\t{\n\t\t// \t\t\tif(Userprofit < USER_SECOND_PRICE)\n\t\t// \t\t\t{\n\t\t// \t\t\t\tif(Userprofit < USER_FIRST_PRICE)\n\t\t// \t\t\t\t{\n\t\t// \t\t\t\t\tthis.userStage = USER_FIRST_PRICE\n\t\t// \t\t\t\t\tthis.textRank = \"Level 1 - warrior you can rank better! Profit 10%\"\n\t\t// \t\t\t\t\tthis.level = \"Level1\"\n\t\t// \t\t\t\t}\n\t\t// \t\t\t\telse\n\t\t// \t\t\t\t{\n\t\t// \t\t\t\t\tthis.userStage = USER_SECOND_PRICE\n\t\t// \t\t\t\t\tthis.textRank = \"Level 2 - amazing! you are on the right way! Profit 15%\"\n\t\t// \t\t\t\t\tthis.level = \"Level2\"\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t\telse\n\t\t// \t\t\t{\n\t\t// \t\t\t\tthis.userStage = USER_THIRD_PRICE\n\t\t// \t\t\t\tthis.textRank = \"Level 3 - Achivement Unlocked! Professonial! Profit 20%\"\n\t\t// \t\t\t\tthis.level = \"Level3\"\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t\telse\n\t\t// \t\t{\n\t\t// \t\t\tthis.userStage = USER_FOURTH_PRICE\n\t\t// \t\t\tthis.textRank = \"Level 4 - Unbeliveable! Wow ... You are PRO! Profit 25%\"\n\t\t// \t\t\tthis.level = \"Level4\"\n\t\t// \t\t}\n\t\t// \t}\n\t\t// \telse\n\t\t// \t{\n\t\t// \t\tthis.userStage = USER_FIFTH_PRICE\n\t\t// \t\tthis.textRank = \"Level 5 - You are the master! tell me how you did that. Profit 30%\"\n\t\t// \t\tthis.level = \"Level5\"\n\t\t// \t}\n\t\t// }\n\t\t// this.reward = \"When passing this limit \"+ this.userStage + \" Get \" + this.userStage*0.05 + \"$USD as Reword!\"\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/affiliate/affiliate.controller.js\n **/","import angular from 'angular';\n\nclass UserData {\n\tconstructor($http, $window, $localStorage) {\n\t\tthis.http = $http;\n\t\tthis.window = $window;\n\t\tthis.localStorage = $localStorage;\n\t\tthis.api = 'http://127.0.0.1:5000/';\n\t}\n\n\tgetUserData() {\n\t\tif (this.localStorage.userdata != null) {\n\t\t\treturn this.localStorage.userdata;\n\t\t}\n\t\telse {\n\t\t\tthis.http.get('http://127.0.0.1:5000/api/GetUserData')\n\t\t\t\t.success(response => {\n\t\t\t\t\tthis.localStorage.userdata = response.data;\n\t\t\t\t\treturn this.localStorage.userdata;\n\t\t\t\t});\n\t\t}\n\t}\n\n\tgetAffiliateData() {\n\t\treturn this.http.get(this.api + 'affiliates')\n\t\t.then(response => {\n\t\t\treturn response.data;\n\t\t}, err => {\n\t\t\tif (this.window.analytics) {\n\t\t\t\tthis.window.analytics('event', 'exception', {\n\t\t\t\t\tdescription: err.status + ': ' + err.message,\n\t\t\t\t\tfatal: false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn null;\n\t\t});\n\t}\n}\n\nexport default angular.module('services.userdata', [])\n\t.service('userdata', UserData)\n\t.name;\n\nUserData.$inject = ['$http', '$window', '$localStorage'];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/services/userdata.service.js\n **/","import './deals.css'\n\nimport angular from 'angular';\nimport uirouter from '@uirouter/angularjs';\n\nimport routing from './deals.routes';\nimport DealsController from './deals.controller';\n\nexport default angular.module('arrowfinds.deals', [uirouter])\n  .config(routing)\n  .controller('DealsController', DealsController)\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/deals/index.js\n **/","import template from './deals.html';\n\nroutes.$inject = ['$stateProvider'];\n\nexport default function routes($stateProvider) {\n  $stateProvider\n    .state('deals', {\n      url: '/deals',\n      template: template,\n      controller: 'DealsController',\n      controllerAs: 'deals'\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/deals/deals.routes.js\n **/","module.exports = \" <section id=deals-section> <div class=\\\"container pricing-footer-margin\\\"> <div class=row> <div class=\\\"col-12 text-truncate pricing-title\\\"> <p class=\\\"text-center font-weight-bold\\\">Pricing</p> </div> </div> <div class=row> <div class=\\\"card card-pricing col-md-5 col-sm-8 text-center\\\"> <div class=\\\"card-header card-pricing-header\\\"> <h3 class=\\\"card-title white\\\">Basic</h3> </div> <div class=\\\"card-body card-pricing-body\\\"> <h4>$9.90</h4> <ul class=list-group> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;one month use</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;hottest products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;products and sellers finding</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;24/7 support</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;up to 12,000 products for month!</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;free week use</i></li> </ul> </div> <div class=\\\"card-footer card-pricing-footer\\\"> <button id=paypal-button></button> </div> </div> <div class=col></div> <div class=\\\"card card-pricing col-md-5 col-sm-8 text-center\\\"> <div class=\\\"card-header card-pricing-header\\\"> <h3 class=\\\"card-title white\\\">Premium</h3> </div> <div class=\\\"card-body card-pricing-body\\\"> <h4>$29.90</h4> <ul class=list-group> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;3 monthes use</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;hottest products</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;products and sellers finding</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;24/7 support</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;up to 16,000 products for month!</i></li> <li class=list-group-item><i class=\\\"fa fa-check\\\">&nbsp;free week use</i></li> </ul> </div> <div class=\\\"card-footer card-pricing-footer\\\"> <button id=paypal-button1></button> </div> </div> </div> </div> </section> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/deals/deals.html\n ** module id = 67\n ** module chunks = 0\n **/","export default class DealsController {\r\n  constructor(http,window) {\r\n\t\tthis.urlTest = 'http://127.0.0.1:5000';\r\n\t\tthis.$http = http;\r\n\t\tthis.$window = window;\r\n\r\n\r\n\t\tthis.$http.get('/api/checkifuserlogged', {\r\n        headers: {}\r\n    }\r\n    )\r\n    .then(function(response) {\r\n\t\t\tif(response.data == \"false\")\r\n\t\t\t{\r\n\t\t\t\tthis.$window.location.href = \"/Login\"\r\n\t\t\t}\r\n    }, function(x) {\r\n\t\t\talert(x);\r\n    });\r\n  }\r\n}\r\n\r\nDealsController.$inject = ['$http','$window'];\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/deals/deals.controller.js\n **/"],"sourceRoot":""}